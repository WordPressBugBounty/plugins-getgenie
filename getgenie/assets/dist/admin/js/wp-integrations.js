(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/pluralize/pluralize.js
  var require_pluralize = __commonJS({
    "node_modules/pluralize/pluralize.js"(exports, module) {
      (function(root, pluralize2) {
        if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
          module.exports = pluralize2();
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return pluralize2();
          });
        } else {
          root.pluralize = pluralize2();
        }
      })(exports, function() {
        var pluralRules = [];
        var singularRules = [];
        var uncountables = {};
        var irregularPlurals = {};
        var irregularSingles = {};
        function sanitizeRule(rule) {
          if (typeof rule === "string") {
            return new RegExp("^" + rule + "$", "i");
          }
          return rule;
        }
        function restoreCase(word, token) {
          if (word === token)
            return token;
          if (word === word.toLowerCase())
            return token.toLowerCase();
          if (word === word.toUpperCase())
            return token.toUpperCase();
          if (word[0] === word[0].toUpperCase()) {
            return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
          }
          return token.toLowerCase();
        }
        function interpolate3(str, args) {
          return str.replace(/\$(\d{1,2})/g, function(match, index2) {
            return args[index2] || "";
          });
        }
        function replace(word, rule) {
          return word.replace(rule[0], function(match, index2) {
            var result = interpolate3(rule[1], arguments);
            if (match === "") {
              return restoreCase(word[index2 - 1], result);
            }
            return restoreCase(match, result);
          });
        }
        function sanitizeWord(token, word, rules) {
          if (!token.length || uncountables.hasOwnProperty(token)) {
            return word;
          }
          var len = rules.length;
          while (len--) {
            var rule = rules[len];
            if (rule[0].test(word))
              return replace(word, rule);
          }
          return word;
        }
        function replaceWord(replaceMap, keepMap, rules) {
          return function(word) {
            var token = word.toLowerCase();
            if (keepMap.hasOwnProperty(token)) {
              return restoreCase(word, token);
            }
            if (replaceMap.hasOwnProperty(token)) {
              return restoreCase(word, replaceMap[token]);
            }
            return sanitizeWord(token, word, rules);
          };
        }
        function checkWord(replaceMap, keepMap, rules, bool) {
          return function(word) {
            var token = word.toLowerCase();
            if (keepMap.hasOwnProperty(token))
              return true;
            if (replaceMap.hasOwnProperty(token))
              return false;
            return sanitizeWord(token, token, rules) === token;
          };
        }
        function pluralize2(word, count, inclusive) {
          var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
          return (inclusive ? count + " " : "") + pluralized;
        }
        pluralize2.plural = replaceWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize2.isPlural = checkWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize2.singular = replaceWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize2.isSingular = checkWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize2.addPluralRule = function(rule, replacement) {
          pluralRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize2.addSingularRule = function(rule, replacement) {
          singularRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize2.addUncountableRule = function(word) {
          if (typeof word === "string") {
            uncountables[word.toLowerCase()] = true;
            return;
          }
          pluralize2.addPluralRule(word, "$0");
          pluralize2.addSingularRule(word, "$0");
        };
        pluralize2.addIrregularRule = function(single, plural) {
          plural = plural.toLowerCase();
          single = single.toLowerCase();
          irregularSingles[single] = plural;
          irregularPlurals[plural] = single;
        };
        [
          ["I", "we"],
          ["me", "us"],
          ["he", "they"],
          ["she", "they"],
          ["them", "them"],
          ["myself", "ourselves"],
          ["yourself", "yourselves"],
          ["itself", "themselves"],
          ["herself", "themselves"],
          ["himself", "themselves"],
          ["themself", "themselves"],
          ["is", "are"],
          ["was", "were"],
          ["has", "have"],
          ["this", "these"],
          ["that", "those"],
          ["echo", "echoes"],
          ["dingo", "dingoes"],
          ["volcano", "volcanoes"],
          ["tornado", "tornadoes"],
          ["torpedo", "torpedoes"],
          ["genus", "genera"],
          ["viscus", "viscera"],
          ["stigma", "stigmata"],
          ["stoma", "stomata"],
          ["dogma", "dogmata"],
          ["lemma", "lemmata"],
          ["schema", "schemata"],
          ["anathema", "anathemata"],
          ["ox", "oxen"],
          ["axe", "axes"],
          ["die", "dice"],
          ["yes", "yeses"],
          ["foot", "feet"],
          ["eave", "eaves"],
          ["goose", "geese"],
          ["tooth", "teeth"],
          ["quiz", "quizzes"],
          ["human", "humans"],
          ["proof", "proofs"],
          ["carve", "carves"],
          ["valve", "valves"],
          ["looey", "looies"],
          ["thief", "thieves"],
          ["groove", "grooves"],
          ["pickaxe", "pickaxes"],
          ["passerby", "passersby"]
        ].forEach(function(rule) {
          return pluralize2.addIrregularRule(rule[0], rule[1]);
        });
        [
          [/s?$/i, "s"],
          [/[^\u0000-\u007F]$/i, "$0"],
          [/([^aeiou]ese)$/i, "$1"],
          [/(ax|test)is$/i, "$1es"],
          [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
          [/(e[mn]u)s?$/i, "$1s"],
          [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
          [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
          [/(seraph|cherub)(?:im)?$/i, "$1im"],
          [/(her|at|gr)o$/i, "$1oes"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
          [/sis$/i, "ses"],
          [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
          [/([^aeiouy]|qu)y$/i, "$1ies"],
          [/([^ch][ieo][ln])ey$/i, "$1ies"],
          [/(x|ch|ss|sh|zz)$/i, "$1es"],
          [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
          [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
          [/(pe)(?:rson|ople)$/i, "$1ople"],
          [/(child)(?:ren)?$/i, "$1ren"],
          [/eaux$/i, "$0"],
          [/m[ae]n$/i, "men"],
          ["thou", "you"]
        ].forEach(function(rule) {
          return pluralize2.addPluralRule(rule[0], rule[1]);
        });
        [
          [/s$/i, ""],
          [/(ss)$/i, "$1"],
          [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
          [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
          [/ies$/i, "y"],
          [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
          [/\b(mon|smil)ies$/i, "$1ey"],
          [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
          [/(seraph|cherub)im$/i, "$1"],
          [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
          [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
          [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
          [/(test)(?:is|es)$/i, "$1is"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
          [/(alumn|alg|vertebr)ae$/i, "$1a"],
          [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
          [/(matr|append)ices$/i, "$1ix"],
          [/(pe)(rson|ople)$/i, "$1rson"],
          [/(child)ren$/i, "$1"],
          [/(eau)x?$/i, "$1"],
          [/men$/i, "man"]
        ].forEach(function(rule) {
          return pluralize2.addSingularRule(rule[0], rule[1]);
        });
        [
          "adulthood",
          "advice",
          "agenda",
          "aid",
          "aircraft",
          "alcohol",
          "ammo",
          "analytics",
          "anime",
          "athletics",
          "audio",
          "bison",
          "blood",
          "bream",
          "buffalo",
          "butter",
          "carp",
          "cash",
          "chassis",
          "chess",
          "clothing",
          "cod",
          "commerce",
          "cooperation",
          "corps",
          "debris",
          "diabetes",
          "digestion",
          "elk",
          "energy",
          "equipment",
          "excretion",
          "expertise",
          "firmware",
          "flounder",
          "fun",
          "gallows",
          "garbage",
          "graffiti",
          "hardware",
          "headquarters",
          "health",
          "herpes",
          "highjinks",
          "homework",
          "housework",
          "information",
          "jeans",
          "justice",
          "kudos",
          "labour",
          "literature",
          "machinery",
          "mackerel",
          "mail",
          "media",
          "mews",
          "moose",
          "music",
          "mud",
          "manga",
          "news",
          "only",
          "personnel",
          "pike",
          "plankton",
          "pliers",
          "police",
          "pollution",
          "premises",
          "rain",
          "research",
          "rice",
          "salmon",
          "scissors",
          "series",
          "sewage",
          "shambles",
          "shrimp",
          "software",
          "species",
          "staff",
          "swine",
          "tennis",
          "traffic",
          "transportation",
          "trout",
          "tuna",
          "wealth",
          "welfare",
          "whiting",
          "wildebeest",
          "wildlife",
          "you",
          /pok[eé]mon$/i,
          /[^aeiou]ese$/i,
          /deer$/i,
          /fish$/i,
          /measles$/i,
          /o[iu]s$/i,
          /pox$/i,
          /sheep$/i
        ].forEach(pluralize2.addUncountableRule);
        return pluralize2;
      });
    }
  });

  // node_modules/normalize-strings/charmap.json
  var require_charmap = __commonJS({
    "node_modules/normalize-strings/charmap.json"(exports, module) {
      module.exports = { "105": "i", "192": "A", "193": "A", "194": "A", "195": "A", "196": "A", "197": "A", "199": "C", "200": "E", "201": "E", "202": "E", "203": "E", "204": "I", "205": "I", "206": "I", "207": "I", "209": "N", "210": "O", "211": "O", "212": "O", "213": "O", "214": "O", "216": "O", "217": "U", "218": "U", "219": "U", "220": "U", "221": "Y", "224": "a", "225": "a", "226": "a", "227": "a", "228": "a", "229": "a", "231": "c", "232": "e", "233": "e", "234": "e", "235": "e", "236": "i", "237": "i", "238": "i", "239": "i", "241": "n", "242": "o", "243": "o", "244": "o", "245": "o", "246": "o", "248": "o", "249": "u", "250": "u", "251": "u", "252": "u", "253": "y", "255": "y", "256": "A", "257": "a", "258": "A", "259": "a", "260": "A", "261": "a", "262": "C", "263": "c", "264": "C", "265": "c", "266": "C", "267": "c", "268": "C", "269": "c", "270": "D", "271": "d", "272": "D", "273": "d", "274": "E", "275": "e", "276": "E", "277": "e", "278": "E", "279": "e", "280": "E", "281": "e", "282": "E", "283": "e", "284": "G", "285": "g", "286": "G", "287": "g", "288": "G", "289": "g", "290": "G", "291": "g", "292": "H", "293": "h", "294": "H", "295": "h", "296": "I", "297": "i", "298": "I", "299": "i", "300": "I", "301": "i", "302": "I", "303": "i", "304": "I", "308": "J", "309": "j", "310": "K", "311": "k", "313": "L", "314": "l", "315": "L", "316": "l", "317": "L", "318": "l", "319": "L", "320": "l", "321": "L", "322": "l", "323": "N", "324": "n", "325": "N", "326": "n", "327": "N", "328": "n", "332": "O", "333": "o", "334": "O", "335": "o", "336": "O", "337": "o", "338": "O", "339": "o", "340": "R", "341": "r", "342": "R", "343": "r", "344": "R", "345": "r", "346": "S", "347": "s", "348": "S", "349": "s", "350": "S", "351": "s", "352": "S", "353": "s", "354": "T", "355": "t", "356": "T", "357": "t", "358": "T", "359": "t", "360": "U", "361": "u", "362": "U", "363": "u", "364": "U", "365": "u", "366": "U", "367": "u", "368": "U", "369": "u", "370": "U", "371": "u", "372": "W", "373": "w", "374": "Y", "375": "y", "376": "Y", "377": "Z", "378": "z", "379": "Z", "380": "z", "381": "Z", "382": "z", "384": "b", "385": "B", "386": "B", "387": "b", "390": "O", "391": "C", "392": "c", "393": "D", "394": "D", "395": "D", "396": "d", "398": "E", "400": "E", "401": "F", "402": "f", "403": "G", "407": "I", "408": "K", "409": "k", "410": "l", "412": "M", "413": "N", "414": "n", "415": "O", "416": "O", "417": "o", "420": "P", "421": "p", "422": "R", "427": "t", "428": "T", "429": "t", "430": "T", "431": "U", "432": "u", "434": "V", "435": "Y", "436": "y", "437": "Z", "438": "z", "461": "A", "462": "a", "463": "I", "464": "i", "465": "O", "466": "o", "467": "U", "468": "u", "477": "e", "484": "G", "485": "g", "486": "G", "487": "g", "488": "K", "489": "k", "490": "O", "491": "o", "500": "G", "501": "g", "504": "N", "505": "n", "512": "A", "513": "a", "514": "A", "515": "a", "516": "E", "517": "e", "518": "E", "519": "e", "520": "I", "521": "i", "522": "I", "523": "i", "524": "O", "525": "o", "526": "O", "527": "o", "528": "R", "529": "r", "530": "R", "531": "r", "532": "U", "533": "u", "534": "U", "535": "u", "536": "S", "537": "s", "538": "T", "539": "t", "542": "H", "543": "h", "544": "N", "545": "d", "548": "Z", "549": "z", "550": "A", "551": "a", "552": "E", "553": "e", "558": "O", "559": "o", "562": "Y", "563": "y", "564": "l", "565": "n", "566": "t", "567": "j", "570": "A", "571": "C", "572": "c", "573": "L", "574": "T", "575": "s", "576": "z", "579": "B", "580": "U", "581": "V", "582": "E", "583": "e", "584": "J", "585": "j", "586": "Q", "587": "q", "588": "R", "589": "r", "590": "Y", "591": "y", "592": "a", "593": "a", "595": "b", "596": "o", "597": "c", "598": "d", "599": "d", "600": "e", "603": "e", "604": "e", "605": "e", "606": "e", "607": "j", "608": "g", "609": "g", "610": "g", "613": "h", "614": "h", "616": "i", "618": "i", "619": "l", "620": "l", "621": "l", "623": "m", "624": "m", "625": "m", "626": "n", "627": "n", "628": "n", "629": "o", "633": "r", "634": "r", "635": "r", "636": "r", "637": "r", "638": "r", "639": "r", "640": "r", "641": "r", "642": "s", "647": "t", "648": "t", "649": "u", "651": "v", "652": "v", "653": "w", "654": "y", "655": "y", "656": "z", "657": "z", "663": "c", "665": "b", "666": "e", "667": "g", "668": "h", "669": "j", "670": "k", "671": "l", "672": "q", "686": "h", "688": "h", "690": "j", "691": "r", "692": "r", "694": "r", "695": "w", "696": "y", "737": "l", "738": "s", "739": "x", "780": "v", "829": "x", "851": "x", "867": "a", "868": "e", "869": "i", "870": "o", "871": "u", "872": "c", "873": "d", "874": "h", "875": "m", "876": "r", "877": "t", "878": "v", "879": "x", "7424": "a", "7427": "b", "7428": "c", "7429": "d", "7431": "e", "7432": "e", "7433": "i", "7434": "j", "7435": "k", "7436": "l", "7437": "m", "7438": "n", "7439": "o", "7440": "o", "7441": "o", "7442": "o", "7443": "o", "7446": "o", "7447": "o", "7448": "p", "7449": "r", "7450": "r", "7451": "t", "7452": "u", "7453": "u", "7454": "u", "7455": "m", "7456": "v", "7457": "w", "7458": "z", "7522": "i", "7523": "r", "7524": "u", "7525": "v", "7680": "A", "7681": "a", "7682": "B", "7683": "b", "7684": "B", "7685": "b", "7686": "B", "7687": "b", "7690": "D", "7691": "d", "7692": "D", "7693": "d", "7694": "D", "7695": "d", "7696": "D", "7697": "d", "7698": "D", "7699": "d", "7704": "E", "7705": "e", "7706": "E", "7707": "e", "7710": "F", "7711": "f", "7712": "G", "7713": "g", "7714": "H", "7715": "h", "7716": "H", "7717": "h", "7718": "H", "7719": "h", "7720": "H", "7721": "h", "7722": "H", "7723": "h", "7724": "I", "7725": "i", "7728": "K", "7729": "k", "7730": "K", "7731": "k", "7732": "K", "7733": "k", "7734": "L", "7735": "l", "7738": "L", "7739": "l", "7740": "L", "7741": "l", "7742": "M", "7743": "m", "7744": "M", "7745": "m", "7746": "M", "7747": "m", "7748": "N", "7749": "n", "7750": "N", "7751": "n", "7752": "N", "7753": "n", "7754": "N", "7755": "n", "7764": "P", "7765": "p", "7766": "P", "7767": "p", "7768": "R", "7769": "r", "7770": "R", "7771": "r", "7774": "R", "7775": "r", "7776": "S", "7777": "s", "7778": "S", "7779": "s", "7786": "T", "7787": "t", "7788": "T", "7789": "t", "7790": "T", "7791": "t", "7792": "T", "7793": "t", "7794": "U", "7795": "u", "7796": "U", "7797": "u", "7798": "U", "7799": "u", "7804": "V", "7805": "v", "7806": "V", "7807": "v", "7808": "W", "7809": "w", "7810": "W", "7811": "w", "7812": "W", "7813": "w", "7814": "W", "7815": "w", "7816": "W", "7817": "w", "7818": "X", "7819": "x", "7820": "X", "7821": "x", "7822": "Y", "7823": "y", "7824": "Z", "7825": "z", "7826": "Z", "7827": "z", "7828": "Z", "7829": "z", "7835": "s", "7840": "A", "7841": "a", "7842": "A", "7843": "a", "7864": "E", "7865": "e", "7866": "E", "7867": "e", "7868": "E", "7869": "e", "7880": "I", "7881": "i", "7882": "I", "7883": "i", "7884": "O", "7885": "o", "7886": "O", "7887": "o", "7908": "U", "7909": "u", "7910": "U", "7911": "u", "7922": "Y", "7923": "y", "7924": "Y", "7925": "y", "7926": "Y", "7927": "y", "7928": "Y", "7929": "y", "8305": "i", "8341": "h", "8342": "k", "8343": "l", "8344": "m", "8345": "n", "8346": "p", "8347": "s", "8348": "t", "8450": "c", "8458": "g", "8459": "h", "8460": "h", "8461": "h", "8464": "i", "8465": "i", "8466": "l", "8467": "l", "8468": "l", "8469": "n", "8472": "p", "8473": "p", "8474": "q", "8475": "r", "8476": "r", "8477": "r", "8484": "z", "8488": "z", "8492": "b", "8493": "c", "8495": "e", "8496": "e", "8497": "f", "8498": "F", "8499": "m", "8500": "o", "8506": "q", "8513": "g", "8514": "l", "8515": "l", "8516": "y", "8517": "d", "8518": "d", "8519": "e", "8520": "i", "8521": "j", "8526": "f", "8579": "C", "8580": "c", "8765": "s", "8766": "s", "8959": "z", "8999": "x", "9746": "x", "9776": "i", "9866": "i", "10005": "x", "10006": "x", "10007": "x", "10008": "x", "10625": "z", "10626": "z", "11362": "L", "11364": "R", "11365": "a", "11366": "t", "11373": "A", "11374": "M", "11375": "A", "11390": "S", "11391": "Z", "19904": "i", "42893": "H", "42922": "H", "42923": "E", "42924": "G", "42925": "L", "42928": "K", "42929": "T", "62937": "x" };
    }
  });

  // node_modules/normalize-strings/index.js
  var require_normalize_strings = __commonJS({
    "node_modules/normalize-strings/index.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(function() {
            return factory(global2, global2.document);
          });
        } else if (typeof module !== "undefined" && module.exports) {
          module.exports = factory(global2, global2.document);
        } else {
          global2.normalize = factory(global2, global2.document);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, document2) {
        var charmap = require_charmap();
        var regex = null;
        var current_charmap;
        var old_charmap;
        function normalize2(str, custom_charmap) {
          old_charmap = current_charmap;
          current_charmap = custom_charmap || charmap;
          regex = regex && old_charmap === current_charmap ? regex : buildRegExp(current_charmap);
          return str.replace(regex, function(charToReplace) {
            return current_charmap[charToReplace.charCodeAt(0)] || charToReplace;
          });
        }
        function buildRegExp(charmap2) {
          return new RegExp("[" + Object.keys(charmap2).map(function(code) {
            return String.fromCharCode(code);
          }).join(" ") + "]", "g");
        }
        return normalize2;
      });
    }
  });

  // node_modules/syllable/problematic.js
  var problematic;
  var init_problematic = __esm({
    "node_modules/syllable/problematic.js"() {
      problematic = {
        abalone: 4,
        abare: 3,
        abbruzzese: 4,
        abed: 2,
        aborigine: 5,
        abruzzese: 4,
        acreage: 3,
        adame: 3,
        adieu: 2,
        adobe: 3,
        anemone: 4,
        anyone: 3,
        apache: 3,
        aphrodite: 4,
        apostrophe: 4,
        ariadne: 4,
        cafe: 2,
        calliope: 4,
        catastrophe: 4,
        chile: 2,
        chloe: 2,
        circe: 2,
        coyote: 3,
        daphne: 2,
        epitome: 4,
        eurydice: 4,
        euterpe: 3,
        every: 2,
        everywhere: 3,
        forever: 3,
        gethsemane: 4,
        guacamole: 4,
        hermione: 4,
        hyperbole: 4,
        jesse: 2,
        jukebox: 2,
        karate: 3,
        machete: 3,
        maybe: 2,
        naive: 2,
        newlywed: 3,
        penelope: 4,
        people: 2,
        persephone: 4,
        phoebe: 2,
        pulse: 1,
        queue: 1,
        recipe: 3,
        riverbed: 3,
        sesame: 3,
        shoreline: 2,
        simile: 3,
        snuffleupagus: 5,
        sometimes: 2,
        syncope: 3,
        tamale: 3,
        waterbed: 3,
        wednesday: 2,
        yosemite: 4,
        zoe: 2
      };
    }
  });

  // node_modules/syllable/index.js
  function syllable(value2) {
    const values = (0, import_normalize_strings.default)(String(value2)).toLowerCase().replace(/['’]/g, "").split(/\b/g);
    let index2 = -1;
    let sum = 0;
    while (++index2 < values.length) {
      sum += one(values[index2].replace(/[^a-z]/g, ""));
    }
    return sum;
  }
  function one(value2) {
    let count = 0;
    if (value2.length === 0) {
      return count;
    }
    if (value2.length < 3) {
      return 1;
    }
    if (own.call(problematic, value2)) {
      return problematic[value2];
    }
    const singular = (0, import_pluralize.default)(value2, 1);
    if (own.call(problematic, singular)) {
      return problematic[singular];
    }
    const addOne = returnFactory(1);
    const subtractOne = returnFactory(-1);
    value2 = value2.replace(EXPRESSION_TRIPLE, countFactory(3)).replace(EXPRESSION_DOUBLE, countFactory(2)).replace(EXPRESSION_SINGLE, countFactory(1));
    const parts2 = value2.split(/[^aeiouy]+/);
    let index2 = -1;
    while (++index2 < parts2.length) {
      if (parts2[index2] !== "") {
        count++;
      }
    }
    value2.replace(EXPRESSION_MONOSYLLABIC_ONE, subtractOne).replace(EXPRESSION_MONOSYLLABIC_TWO, subtractOne);
    value2.replace(EXPRESSION_DOUBLE_SYLLABIC_ONE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_TWO, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_THREE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_FOUR, addOne);
    return count || 1;
    function countFactory(addition) {
      return counter;
      function counter() {
        count += addition;
        return "";
      }
    }
    function returnFactory(addition) {
      return returner;
      function returner($0) {
        count += addition;
        return $0;
      }
    }
  }
  var import_pluralize, import_normalize_strings, own, EXPRESSION_MONOSYLLABIC_ONE, EXPRESSION_MONOSYLLABIC_TWO, EXPRESSION_DOUBLE_SYLLABIC_ONE, EXPRESSION_DOUBLE_SYLLABIC_TWO, EXPRESSION_DOUBLE_SYLLABIC_THREE, EXPRESSION_DOUBLE_SYLLABIC_FOUR, EXPRESSION_SINGLE, EXPRESSION_DOUBLE, EXPRESSION_TRIPLE;
  var init_syllable = __esm({
    "node_modules/syllable/index.js"() {
      import_pluralize = __toESM(require_pluralize(), 1);
      import_normalize_strings = __toESM(require_normalize_strings(), 1);
      init_problematic();
      own = {}.hasOwnProperty;
      EXPRESSION_MONOSYLLABIC_ONE = new RegExp(
        [
          "awe($|d|so)",
          "cia(?:l|$)",
          "tia",
          "cius",
          "cious",
          "[^aeiou]giu",
          "[aeiouy][^aeiouy]ion",
          "iou",
          "sia$",
          "eous$",
          "[oa]gue$",
          ".[^aeiuoycgltdb]{2,}ed$",
          ".ely$",
          "^jua",
          "uai",
          "eau",
          "^busi$",
          "(?:[aeiouy](?:" + [
            "[bcfgklmnprsvwxyz]",
            "ch",
            "dg",
            "g[hn]",
            "lch",
            "l[lv]",
            "mm",
            "nch",
            "n[cgn]",
            "r[bcnsv]",
            "squ",
            "s[chkls]",
            "th"
          ].join("|") + ")ed$)",
          "(?:[aeiouy](?:" + [
            "[bdfklmnprstvy]",
            "ch",
            "g[hn]",
            "lch",
            "l[lv]",
            "mm",
            "nch",
            "nn",
            "r[nsv]",
            "squ",
            "s[cklst]",
            "th"
          ].join("|") + ")es$)"
        ].join("|"),
        "g"
      );
      EXPRESSION_MONOSYLLABIC_TWO = new RegExp(
        "[aeiouy](?:" + [
          "[bcdfgklmnprstvyz]",
          "ch",
          "dg",
          "g[hn]",
          "l[lv]",
          "mm",
          "n[cgns]",
          "r[cnsv]",
          "squ",
          "s[cklst]",
          "th"
        ].join("|") + ")e$",
        "g"
      );
      EXPRESSION_DOUBLE_SYLLABIC_ONE = new RegExp(
        "(?:" + [
          "([^aeiouy])\\1l",
          "[^aeiouy]ie(?:r|s?t)",
          "[aeiouym]bl",
          "eo",
          "ism",
          "asm",
          "thm",
          "dnt",
          "snt",
          "uity",
          "dea",
          "gean",
          "oa",
          "ua",
          "react?",
          "orbed",
          "shred",
          "eings?",
          "[aeiouy]sh?e[rs]"
        ].join("|") + ")$",
        "g"
      );
      EXPRESSION_DOUBLE_SYLLABIC_TWO = new RegExp(
        [
          "creat(?!u)",
          "[^gq]ua[^auieo]",
          "[aeiou]{3}",
          "^(?:ia|mc|coa[dglx].)",
          "^re(app|es|im|us)",
          "(th|d)eist"
        ].join("|"),
        "g"
      );
      EXPRESSION_DOUBLE_SYLLABIC_THREE = new RegExp(
        [
          "[^aeiou]y[ae]",
          "[^l]lien",
          "riet",
          "dien",
          "iu",
          "io",
          "ii",
          "uen",
          "[aeilotu]real",
          "real[aeilotu]",
          "iell",
          "eo[^aeiou]",
          "[aeiou]y[aeiou]"
        ].join("|"),
        "g"
      );
      EXPRESSION_DOUBLE_SYLLABIC_FOUR = /[^s]ia/;
      EXPRESSION_SINGLE = new RegExp(
        [
          "^(?:" + [
            "un",
            "fore",
            "ware",
            "none?",
            "out",
            "post",
            "sub",
            "pre",
            "pro",
            "dis",
            "side",
            "some"
          ].join("|") + ")",
          "(?:" + [
            "ly",
            "less",
            "some",
            "ful",
            "ers?",
            "ness",
            "cians?",
            "ments?",
            "ettes?",
            "villes?",
            "ships?",
            "sides?",
            "ports?",
            "shires?",
            "[gnst]ion(?:ed|s)?"
          ].join("|") + ")$"
        ].join("|"),
        "g"
      );
      EXPRESSION_DOUBLE = new RegExp(
        [
          "^(?:" + [
            "above",
            "anti",
            "ante",
            "counter",
            "hyper",
            "afore",
            "agri",
            "infra",
            "intra",
            "inter",
            "over",
            "semi",
            "ultra",
            "under",
            "extra",
            "dia",
            "micro",
            "mega",
            "kilo",
            "pico",
            "nano",
            "macro",
            "somer"
          ].join("|") + ")",
          "(?:fully|berry|woman|women|edly|union|((?:[bcdfghjklmnpqrstvwxz])|[aeiou])ye?ing)$"
        ].join("|"),
        "g"
      );
      EXPRESSION_TRIPLE = /(creations?|ology|ologist|onomy|onomist)$/g;
    }
  });

  // node_modules/flekin/index.js
  var getWords, getSentenceCount, getSyllableCount, getSyllableCountByWord, stripSpecialTitles, stripOutSpecialCharacters, readingEaseTest, gradeLevelTest, flekin;
  var init_flekin = __esm({
    "node_modules/flekin/index.js"() {
      init_syllable();
      getWords = (txt) => {
        let result = [];
        let words = txt.trim().split(/[\s/]/);
        for (const i2 in words) {
          let word = words[i2].trim();
          if (word.length > 0 && word !== ".") {
            if (word.match(/[\w\d][.?!]$/))
              word = word.replace(/[.?!]/, "");
            result.push(word);
          }
        }
        return result;
      };
      getSentenceCount = (txt) => {
        txt = txt.trim();
        return txt.replace(/([.?!])\s+(?=\w)/g, "$1|").split("|").length;
      };
      getSyllableCount = (words) => {
        let words_array = getWords(words);
        let result = 0;
        for (const i2 in words_array) {
          result += getSyllableCountByWord(words_array[i2]);
        }
        return result;
      };
      getSyllableCountByWord = (word) => {
        return syllable(word);
      };
      stripSpecialTitles = (txt) => {
        txt = txt.replace(/\s(prof{1,2})\./g, " professor");
        txt = txt.replace(/\s(rev)\./g, " reverend");
        txt = txt.replace(/\s(rt\.\shon)\./g, " right honorary");
        txt = txt.replace(/\s(msgr)\./g, " monsignor");
        return txt.replace(/\s(dr|mr|mrs|jr|sr|esq|messrs|mmes)\./g, " title");
      };
      stripOutSpecialCharacters = (txt) => {
        txt = txt.replace(/(\(|\)|;|:|,|-|—)/g, "");
        txt = txt.replace(/^\s*[\r\n]/gm, "");
        return txt;
      };
      readingEaseTest = (totalWords, totalSentences, totalSyllables) => {
        return 206.835 - 1.015 * (totalWords / totalSentences) - 84.6 * (totalSyllables / totalWords);
      };
      gradeLevelTest = (totalWords, totalSentences, totalSyllables) => {
        return 0.39 * (totalWords / totalSentences) + 11.8 * (totalSyllables / totalWords) - 15.59;
      };
      flekin = (text) => {
        if (typeof text !== "string")
          throw new Error("text is not of type string");
        if (!text.length)
          throw new Error("text must not be an empty string");
        text = text.toLowerCase().trim();
        text = stripSpecialTitles(text);
        text = stripOutSpecialCharacters(text);
        let words = getWords(text);
        let wordcount = words.length;
        let sentencecount = getSentenceCount(text);
        let syllablecount = getSyllableCount(text);
        return {
          grade_level: parseFloat(gradeLevelTest(wordcount, sentencecount, syllablecount).toFixed(2)),
          reading_ease: parseFloat(readingEaseTest(wordcount, sentencecount, syllablecount).toFixed(2)),
          word_count: wordcount,
          syllable_count: syllablecount,
          sentence_count: sentencecount
        };
      };
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/KeywordFinder.js
  var KeywordFinder;
  var init_KeywordFinder = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/KeywordFinder.js"() {
      KeywordFinder = class {
        content = "";
        constructor(content = "") {
          this.content = content;
        }
        escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        findAllMatch(content = this.content, keywords = []) {
          const matchedKeywords = [];
          for (let i2 = 0; i2 < keywords.length; i2++) {
            const keyword = keywords[i2];
            let count = this.findSingleMatch(content, keyword);
            matchedKeywords.push({ keyword, count });
          }
          return matchedKeywords;
        }
        findSingleMatch(content = this.content, keyword = "") {
          const escapedChars = this.escapeRegExp(keyword);
          const arr = escapedChars.split(" ");
          const pattern = arr.join(String.raw`(\s+\w+\s+|\s+)`);
          const matched = content?.match(new RegExp(pattern, "gmi"));
          if (matched && matched.length > 0) {
            return matched.length;
          }
          return 0;
        }
      };
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/ContentAnalysis.js
  var ContentAnalysis;
  var init_ContentAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/ContentAnalysis.js"() {
      init_flekin();
      init_KeywordFinder();
      ContentAnalysis = class {
        feedbacks = {
          problems: [],
          results: [],
          improvements: []
        };
        statistics = {
          word: {},
          heading: {},
          focusKeyword: {
            score: {
              heading: 0,
              content: 0,
              metaDescription: 0,
              metaTitle: 0,
              imgAltText: 0
            }
          },
          secondaryKeywords: {
            score: {
              heading: 0,
              content: 0
            }
          },
          keywords: {},
          image: {},
          internalLink: {},
          externalLink: {},
          imgAltText: {},
          nlp: {}
        };
        contentStats = {
          totalScore: 0,
          readabilityScore: 0,
          readabilityTooltipText: ""
        };
        constructor(sourceContent = {}, recommendation = {}) {
          this.recommendation = recommendation;
          this.url = sourceContent.url;
          this.title = sourceContent?.title || "";
          this.description = sourceContent?.description || "";
          let dom = document.createElement("div");
          dom.innerHTML = sourceContent.content;
          this.sourceContent = dom.outerHTML;
        }
        getStat = () => {
          if (!this.sourceContent || Object.keys(this.recommendation || {}).length === 0) {
            return false;
          }
          this.initScoreStats();
          this.calculateTotalContent();
          return { statistics: this.statistics, feedbacks: this.feedbacks, contentStats: this.contentStats };
        };
        getReadabilityText = (score) => {
          let value2 = parseInt(score);
          switch (true) {
            case value2 >= 90:
              return "Very easy to read. Easily understood by an average 11-year-old student.";
            case value2 >= 80:
              return "Easy to read. Conversational English for consumers.";
            case value2 >= 70:
              return "Fairly easy to read.";
            case value2 >= 60:
              return "Plain English. Easily understood by 13- to 15-year-old students.";
            case value2 >= 50:
              return "Fairly difficult to read.";
            case value2 >= 30:
              return "Difficult to read.";
            case value2 >= 0:
              return "Very difficult to read. Best understood by university graduates.";
          }
        };
        initScoreStats = () => {
          const sourceAnalysis = flekin(this.sourceContent.replace(/<[^>]*>/gmi, " "));
          this.contentStats.readabilityScore = Math.max(0, Math.ceil(sourceAnalysis?.reading_ease));
          this.contentStats.readabilityScore = Math.min(100, this.contentStats.readabilityScore);
          this.contentStats.readabilityTooltipText = this.getReadabilityText(this.contentStats.readabilityScore);
          const htmlTagUsage = this.recommendation?.HtmlTagUsage;
          let wordUsage = htmlTagUsage?.wordUsage, headingUsage = htmlTagUsage?.headingUsage, imageUsage = htmlTagUsage?.imageUsage, internalLinkUsage = htmlTagUsage?.internalLinkUsage, externalLinkUsage = htmlTagUsage?.externalLinkUsage;
          let totalImgTags = this.sourceContent.match(/<img [^>]*src="[^"]*"[^>]*>/gi)?.length || 0, totalNumberOfWords = sourceAnalysis?.word_count || 0;
          let totalHtags = this.sourceContent.match(/<h[1-6][^>]*>/gm)?.length || 0;
          let internalLinkFound = 0, externalLinkFound = 0;
          let allLinks = this.sourceContent.match(/<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/gmi);
          if (allLinks && this.url) {
            internalLinkFound = allLinks.filter((link) => {
              return link.includes(this.url);
            }).length;
            externalLinkFound = allLinks.length - internalLinkFound;
          }
          const defaultUsage = [1, 1];
          this.statistics.word = {
            analyzedRecommendation: wordUsage || defaultUsage,
            count: totalNumberOfWords,
            title: "Words"
          };
          this.statistics.heading = {
            analyzedRecommendation: headingUsage || defaultUsage,
            count: totalHtags || 0,
            title: "Headings"
          };
          this.statistics.image = {
            analyzedRecommendation: imageUsage || defaultUsage,
            count: totalImgTags || 0,
            title: "Images"
          };
          this.statistics.internalLink = {
            analyzedRecommendation: internalLinkUsage || defaultUsage,
            count: internalLinkFound || 0,
            title: "Internal Links"
          };
          this.statistics.externalLink = {
            analyzedRecommendation: externalLinkUsage || defaultUsage,
            count: externalLinkFound || 0,
            title: "External Links"
          };
          this.statistics.imgAltText = {
            analyzedRecommendation: defaultUsage,
            count: 0,
            title: "Img Alt Text"
          };
          this.statistics.nlp = {
            analyzedRecommendation: defaultUsage,
            count: 0,
            scoreRecommendation: 80,
            title: "NLP"
          };
          this.#commonScoreStats();
          this.#keywords();
        };
        #commonScoreStats = () => {
          let excludeStats = [
            "secondaryKeywords",
            "focusKeyword",
            "keywords",
            "imgAltText",
            "nlp"
          ];
          Object.keys(this.statistics).forEach((stat) => {
            let currentStats = this.statistics[stat];
            if (excludeStats.indexOf(stat) === -1) {
              this.statistics[stat] = {
                ...this.statistics[stat],
                score: this.measureScore(currentStats.analyzedRecommendation, currentStats.count, ["word", "image"].includes(stat))
              };
              let recommended = currentStats?.analyzedRecommendation || [0, 0], count = currentStats?.count, min = recommended[0], max = recommended[1];
              if (this[stat + "Callback"]) {
                this[stat + "Callback"](count, min, max);
              }
            }
          });
        };
        wordCallback = (count, min, max) => {
          if (count < min) {
            let text = `You need to write at least ${min} words to improve your content quality and the score`;
            this.addFeedback(text, "problems");
          } else if (count <= max) {
            let text = `You have successfully covered ${count} number of words, according to the suggested range`;
            this.addFeedback(text, "results");
          }
        };
        paragraphCallback = (count, min, max) => {
          if (count < min) {
            let text = `You need to have at least ${min - count} paragraph in the content`;
            this.addFeedback(text, "problems");
          }
          if (count >= min && count <= max) {
            let text = "Number of paragraphs matches recommendation to get good results";
            this.addFeedback(text, "results");
          }
        };
        imageCallback = (count, min, max) => {
          if (count < min) {
            let text = `Include at least ${min} images inside the content to improve the content score`;
            this.addFeedback(text, "problems");
          } else if (count <= max) {
            let text = `You have successfully added ${count} number of images`;
            this.addFeedback(text, "results");
          }
        };
        internalLinkCallback = (count, min, max) => {
          if (count < min) {
            let text = "Add internal links to improve the content score";
            this.addFeedback(text, "improvements");
          }
          if (count > min) {
            let text = `You have successfully added ${count} internal link(s) inside your content`;
            this.addFeedback(text, "results");
          }
        };
        externalLinkCallback = (count, min, max) => {
          if (count < 1) {
            let text = "Add at least 1 external link to improve the content score";
            this.addFeedback(text, "improvements");
          } else {
            let text = `You have successfully added ${count} external link(s) inside your content`;
            this.addFeedback(text, "results");
          }
        };
        #keywords = () => {
          const keywords = this.recommendation?.keywords || {};
          const parser = new DOMParser();
          const doc = parser.parseFromString(this.sourceContent, "text/html");
          let elements = "h1, h2, h3, h4, h5, h6";
          let headings = jQuery(doc).find(elements);
          let content = this.sourceContent.replace(/<h[1-6].*?>(.*?)<\/h[1-6]>/gm, "").replace(/<[^>]*>/gmi, " ");
          let secondaryKeywords = {
            count: 0,
            score: {
              heading: 0,
              content: 0
            }
          };
          if (Object.keys(keywords) === 0) {
            return;
          }
          const keywordFinder5 = new KeywordFinder();
          let keywordUsage = {}, keywordsInHeading = 0, keywordsInContent = 0;
          let greenKeywordCount = 0, totalNlpKeywords = 0;
          let focusKeywordDetails = {};
          for (const [keyword, keywordAnalysis] of Object.entries(keywords)) {
            let headingCount = 0, contentCount = 0, foundIn = [];
            headingCount = keywordFinder5.findSingleMatch(headings.text(), keyword);
            contentCount = keywordFinder5.findSingleMatch(content, keyword);
            let totalCount = headingCount + contentCount;
            let recommendation2 = {};
            let usage2 = {
              heading: headingCount,
              content: contentCount,
              all: totalCount
            };
            if (keywordAnalysis?.heading) {
              recommendation2.heading = keywordAnalysis?.heading;
              foundIn.push("heading");
            }
            if (keywordAnalysis?.content) {
              foundIn.push("content");
              recommendation2.content = keywordAnalysis.content;
            }
            if (keywordAnalysis?.total) {
              recommendation2.all = keywordAnalysis.total;
            }
            if (keywordAnalysis?.type === "nlp") {
              totalNlpKeywords++;
              if (totalCount >= keywordAnalysis?.total?.[0] && totalCount <= keywordAnalysis?.total?.[1]) {
                greenKeywordCount++;
              }
            }
            if (keywordAnalysis?.type === "focus") {
              usage2.metaTitle = keywordFinder5.findSingleMatch(this.title, keyword);
              usage2.metaDescription = keywordFinder5.findSingleMatch(this.description, keyword);
              let altText = (this.sourceContent.match(/<img\s+(?:[^>]*?\s+)?alt=(["'])(.*?)\1/gi) || []).join(" ");
              usage2.imgAltText = keywordFinder5.findSingleMatch(altText, keyword);
              foundIn.push("metaTitle");
              recommendation2.metaTitle = keywordAnalysis?.metaTitle || [1, 1];
              foundIn.push("metaDescription");
              recommendation2.metaDescription = keywordAnalysis?.metaDescription || [1, 1];
              foundIn.push("imgAltText");
              recommendation2.imgAltText = keywordAnalysis?.imgAltText || [1, 1];
              let focusKeywordScore = {};
              focusKeywordScore.heading = this.measureScore(recommendation2?.heading || [1, 1], usage2.heading);
              focusKeywordScore.content = this.measureScore(recommendation2?.content || [1, 1], usage2.content);
              focusKeywordScore.metaTitle = this.measureScore(recommendation2?.metaTitle, usage2.metaTitle);
              focusKeywordScore.metaDescription = this.measureScore(recommendation2?.metaDescription, usage2.metaDescription);
              focusKeywordScore.imgAltText = this.measureScore(recommendation2.imgAltText, usage2.imgAltText);
              this.statistics.imgAltText.analyzedRecommendation = recommendation2.imgAltText;
              this.statistics.imgAltText.count = usage2.imgAltText;
              this.statistics.focusKeyword = {
                "keyword": keyword,
                "score": focusKeywordScore
              };
              focusKeywordDetails = {
                keyword,
                usage: usage2,
                recommendation: recommendation2
              };
            } else {
              secondaryKeywords.count++;
              if (recommendation2?.heading) {
                keywordsInHeading++;
                secondaryKeywords.score.heading += this.measureScore(recommendation2.heading, usage2.heading);
              }
              if (recommendation2?.content) {
                keywordsInContent++;
                secondaryKeywords.score.content += this.measureScore(recommendation2.content, usage2.content);
              }
            }
            if (!keywordUsage[keywordAnalysis?.type]) {
              keywordUsage[keywordAnalysis?.type] = [];
            }
            keywordUsage[keywordAnalysis?.type].push({
              keyword,
              usage: usage2,
              recommendation: recommendation2,
              foundIn
            });
          }
          let { usage, recommendation } = focusKeywordDetails;
          if (recommendation?.heading) {
            if (usage.heading < recommendation.heading?.[0]) {
              this.addFeedback(`Include the focus keyword ${recommendation.heading?.[0]} times in the headings to increase the score`, "problems");
            } else if (usage.heading > recommendation.heading?.[1]) {
              this.addFeedback(`You have overused the focus keyword inside the headings. Decrease the keywords to at most 
                ${recommendation.heading?.[1] - usage.heading} number of keywords.`, "problems");
            } else {
              this.addFeedback(`You have successfully added the focus keyword ${usage.heading} times inside your headings, well within the suggested range`, "results");
            }
          }
          if (recommendation?.content) {
            if (usage.content < recommendation.content?.[0]) {
              this.addFeedback(`Include the focus keyword ${recommendation.content?.[0]} times in the content to increase the score`, "problems");
            } else if (usage.content > recommendation.content?.[1]) {
              this.addFeedback(`You have overused the focus keyword inside the content. Decrease the keywords to at most
                    ${recommendation.content?.[1] - usage.content} number of keywords.`, "problems");
            } else {
              this.addFeedback(`You have successfully added the focus keyword ${usage.content} times inside your content, well within the suggested range`, "results");
            }
          }
          if (recommendation?.metaTitle) {
            if (usage.metaTitle < 1) {
              this.addFeedback("Include the focus keyword at least once in your meta title to increase the score", "problems");
            } else {
              this.addFeedback("You have successfully added the focus keyword in the meta title", "results");
            }
          }
          if (recommendation?.metaDescription) {
            if (usage.metaDescription < 1) {
              this.addFeedback("Include the focus keyword at least once in your meta description to increase the score", "problems");
            } else {
              this.addFeedback("You have successfully added the focus keyword in the meta description", "results");
            }
          }
          this.statistics.keywords = keywordUsage;
          this.statistics.secondaryKeywords = {
            "count": secondaryKeywords.count,
            "score": {
              "heading": Math.ceil(secondaryKeywords.score.heading / keywordsInHeading),
              "content": Math.ceil(secondaryKeywords.score.content / keywordsInContent)
            }
          };
          this.statistics.nlp.count = isNaN(greenKeywordCount / totalNlpKeywords) || totalNlpKeywords == 0 ? 0 : Math.ceil(greenKeywordCount / totalNlpKeywords * 100);
          if (this.statistics.nlp.count < this.statistics.nlp?.scoreRecommendation || 80) {
            this.addFeedback("Please utilize more NLP keywords according to the recommended usage to improve your content quality.", "improvements");
          }
        };
        addFeedback = (text, type) => {
          if (!text || !type || !this.feedbacks?.[type]) {
            return false;
          }
          if (!this.feedbacks[type].includes(text)) {
            this.feedbacks[type].push(text);
          }
        };
        calculateTotalContent = () => {
          let stats = {
            "word": 15,
            "image": 10,
            "internalLink": 5,
            "externalLink": 2,
            "focusKeywordInAltText": 3,
            "focusKeywordInMetaTitle": 5,
            "focusKeywordInMetaDescription": 5,
            "focusKeywordInHeading": 10,
            "focusKeywordInContent": 12,
            "secondaryKeywordsInHeading": 10,
            "secondaryKeywordsInContent": 23
          };
          let scores = {
            word: this.statistics.word.score,
            image: this.statistics.image.score,
            internalLink: this.statistics.internalLink.score,
            externalLink: this.statistics.externalLink.score,
            focusKeywordInAltText: this.statistics.focusKeyword.score.imgAltText,
            focusKeywordInMetaTitle: this.statistics.focusKeyword.score.metaTitle,
            focusKeywordInMetaDescription: this.statistics.focusKeyword.score.metaDescription,
            focusKeywordInHeading: this.statistics.focusKeyword.score.heading,
            focusKeywordInContent: this.statistics.focusKeyword.score.content,
            secondaryKeywordsInHeading: this.statistics.secondaryKeywords.score.heading,
            secondaryKeywordsInContent: this.statistics.secondaryKeywords.score.content
          };
          let finalScore = 0;
          for (const [item, impact] of Object.entries(stats)) {
            finalScore += (scores[item] || 0) / 100 * impact;
          }
          this.contentStats.totalScore = Math.min(100, Math.ceil(finalScore));
        };
        measureScore = (analysisStats, count = 0, extendable = false) => {
          if (!analysisStats || analysisStats?.length !== 2) {
            return 0;
          }
          let avg = analysisStats[0] || 0, max = analysisStats[1] || 0, result = 100;
          if (max === 0 && count >= 0) {
            return 100;
          }
          if (count <= max) {
            result = count / (max * 0.8) * 100;
          } else if (count > max) {
            if (extendable) {
              result = 100;
            } else {
              let fine = count / max;
              result = Math.abs(100 - fine);
            }
          }
          return Math.min(100, result);
        };
      };
    }
  });

  // assets/src/admin/js/RequestManager/EndPoints.js
  var EndPoints_exports = {};
  __export(EndPoints_exports, {
    clearHistoryUrl: () => clearHistoryUrl,
    competitorData: () => competitorData,
    contentFeedback: () => contentFeedback,
    continueWriting: () => continueWriting,
    createHistoryUrl: () => createHistoryUrl,
    expandOutline: () => expandOutline,
    filterNlpKeywordsUrl: () => filterNlpKeywordsUrl,
    genieChat: () => genieChat,
    genieChatClear: () => genieChatClear,
    genieChatList: () => genieChatList,
    genieChatSave: () => genieChatSave,
    genieImage: () => genieImage,
    genieImageSave: () => genieImageSave,
    genieMode: () => genieMode,
    getLicenseToken: () => getLicenseToken,
    historyData: () => historyData,
    keywordsData: () => keywordsData,
    limitUsage: () => limitUsage,
    nlpKeywords: () => nlpKeywords,
    nlpKeywordsUrl: () => nlpKeywordsUrl,
    oneClickBlog: () => oneClickBlog,
    outlines: () => outlines,
    plagiarismData: () => plagiarismData,
    relatedKeywords: () => relatedKeywords,
    removeLicenseToken: () => removeLicenseToken,
    semanticKeywords: () => semanticKeywords,
    storeApiUrl: () => storeApiUrl,
    subscriptionUpdateUrl: () => subscriptionUpdateUrl,
    topicalMap: () => topicalMap,
    updateUsageUrl: () => updateUsageUrl,
    webviewDataCreate: () => webviewDataCreate,
    webviewDataList: () => webviewDataList,
    webviewDeletePost: () => webviewDeletePost,
    webviewGetBlogWizardData: () => webviewGetBlogWizardData,
    writeIntro: () => writeIntro,
    writeTemplates: () => writeTemplates,
    writeTitle: () => writeTitle
  });
  var allUrls, parserApiUrl, licenseApiUrl, historyData, createHistoryUrl, clearHistoryUrl, updateUsageUrl, writeTemplates, writeIntro, writeTitle, outlines, nlpKeywordsUrl, filterNlpKeywordsUrl, keywordsData, competitorData, plagiarismData, continueWriting, expandOutline, genieMode, oneClickBlog, contentFeedback, storeApiUrl, getLicenseToken, removeLicenseToken, limitUsage, subscriptionUpdateUrl, genieImage, genieImageSave, genieChat, genieChatSave, genieChatList, genieChatClear, webviewDataCreate, webviewDeletePost, webviewDataList, webviewGetBlogWizardData, relatedKeywords, nlpKeywords, semanticKeywords, topicalMap;
  var init_EndPoints = __esm({
    "assets/src/admin/js/RequestManager/EndPoints.js"() {
      allUrls = window.getGenie.config;
      parserApiUrl = allUrls.parserApi;
      licenseApiUrl = allUrls.licenseApi;
      historyData = allUrls.historyApi + "list";
      createHistoryUrl = allUrls.historyApi + "create";
      clearHistoryUrl = allUrls.historyApi + "clear";
      updateUsageUrl = allUrls.baseApi + "user_usage_log";
      writeTemplates = parserApiUrl + "writer-default/generate-templates-content";
      writeIntro = parserApiUrl + "writer-wizard/generate-intro";
      writeTitle = parserApiUrl + "writer-wizard/generate-title";
      outlines = parserApiUrl + "writer-wizard/generate-outline";
      nlpKeywordsUrl = parserApiUrl + "writer-wizard/keyword-cluster";
      filterNlpKeywordsUrl = parserApiUrl + "writer-wizard/filter-nlp-keyword";
      keywordsData = parserApiUrl + "writer-wizard/keyword-doctor";
      competitorData = parserApiUrl + "writer-wizard/serp-data";
      plagiarismData = parserApiUrl + "writer-wizard/plagiarism-checker";
      continueWriting = parserApiUrl + "advanced-writing/continue-writing";
      expandOutline = parserApiUrl + "advanced-writing/outline-expand";
      genieMode = parserApiUrl + "advanced-writing/genie-mode";
      oneClickBlog = parserApiUrl + "writer-wizard/generate-one-click-blog";
      contentFeedback = allUrls.feedbackApi;
      storeApiUrl = allUrls.storeApi + window.getGenie.blogWizardData?.post_id;
      getLicenseToken = licenseApiUrl + "get-token";
      removeLicenseToken = licenseApiUrl + "remove-token";
      limitUsage = allUrls.usageLimitStatsApi;
      subscriptionUpdateUrl = allUrls.subscriptionUpgradeUrlApi;
      genieImage = parserApiUrl + "genie-image/generate-image";
      genieImageSave = allUrls.baseApi + "genie-image/upload";
      genieChat = parserApiUrl + "chat/default";
      genieChatSave = allUrls.genieChatApi + "create";
      genieChatList = allUrls.genieChatApi + "list";
      genieChatClear = allUrls.genieChatApi + "clear";
      webviewDataCreate = allUrls.webviewBaseApi + "save";
      webviewDeletePost = allUrls.webviewBaseApi + "delete";
      webviewDataList = allUrls.webviewBaseApi + "list";
      webviewGetBlogWizardData = allUrls.webviewBaseApi + "doc_meta";
      relatedKeywords = parserApiUrl + "writer-wizard/related-keywords";
      nlpKeywords = parserApiUrl + "writer-wizard/nlp-keywords";
      semanticKeywords = parserApiUrl + "writer-wizard/semantic-keywords";
      topicalMap = parserApiUrl + "writer-wizard/topical-map";
    }
  });

  // assets/src/admin/js/Common/Libs/Notification.js
  var notification;
  var init_Notification = __esm({
    "assets/src/admin/js/Common/Libs/Notification.js"() {
      ({ notification } = window.antd);
    }
  });

  // assets/src/admin/js/RequestManager/HandleResponse.js
  var Modal;
  var init_HandleResponse = __esm({
    "assets/src/admin/js/RequestManager/HandleResponse.js"() {
      init_Notification();
      ({ Modal } = window.antd);
    }
  });

  // assets/src/admin/js/RequestManager/index.js
  var init_RequestManager = __esm({
    "assets/src/admin/js/RequestManager/index.js"() {
      init_EndPoints();
      init_HandleResponse();
    }
  });

  // node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks2() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback2) {
          hookCallback = callback2;
        }
        function isArray2(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject3(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber2(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate2(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map3(arr, fn) {
          var res = [], i2, arrLen = arr.length;
          for (i2 = 0; i2 < arrLen; ++i2) {
            res.push(fn(arr[i2], i2));
          }
          return res;
        }
        function extend(a, b) {
          for (var i2 in b) {
            if (hasOwnProp(b, i2)) {
              a[i2] = b[i2];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i2;
            for (i2 = 0; i2 < len; i2++) {
              if (i2 in t && fun.call(this, t[i2], i2, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i2) {
              return i2 != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks2.momentProperties = [], updateInProgress = false;
        function copyConfig(to3, from3) {
          var i2, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from3._isAMomentObject)) {
            to3._isAMomentObject = from3._isAMomentObject;
          }
          if (!isUndefined(from3._i)) {
            to3._i = from3._i;
          }
          if (!isUndefined(from3._f)) {
            to3._f = from3._f;
          }
          if (!isUndefined(from3._l)) {
            to3._l = from3._l;
          }
          if (!isUndefined(from3._strict)) {
            to3._strict = from3._strict;
          }
          if (!isUndefined(from3._tzm)) {
            to3._tzm = from3._tzm;
          }
          if (!isUndefined(from3._isUTC)) {
            to3._isUTC = from3._isUTC;
          }
          if (!isUndefined(from3._offset)) {
            to3._offset = from3._offset;
          }
          if (!isUndefined(from3._pf)) {
            to3._pf = getParsingFlags(from3);
          }
          if (!isUndefined(from3._locale)) {
            to3._locale = from3._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i2 = 0; i2 < momentPropertiesLen; i2++) {
              prop = momentProperties[i2];
              val = from3[prop];
              if (!isUndefined(val)) {
                to3[prop] = val;
              }
            }
          }
          return to3;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks2.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks2.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks2.deprecationHandler != null) {
              hooks2.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i2, key, argLen = arguments.length;
              for (i2 = 0; i2 < argLen; i2++) {
                arg = "";
                if (typeof arguments[i2] === "object") {
                  arg += "\n[" + i2 + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i2];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks2.deprecationHandler != null) {
            hooks2.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks2.suppressDeprecationWarnings = false;
        hooks2.deprecationHandler = null;
        function isFunction2(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set2(config) {
          var prop, i2;
          for (i2 in config) {
            if (hasOwnProp(config, i2)) {
              prop = config[i2];
              if (isFunction2(prop)) {
                this[i2] = prop;
              } else {
                this["_" + i2] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject3(parentConfig[prop]) && isObject3(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject3(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i2, res = [];
            for (i2 in obj) {
              if (hasOwnProp(obj, i2)) {
                res.push(i2);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction2(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
          return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback2) {
          var func = callback2;
          if (typeof callback2 === "string") {
            func = function() {
              return this[callback2]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i2, length2;
          for (i2 = 0, length2 = array.length; i2 < length2; i2++) {
            if (formatTokenFunctions[array[i2]]) {
              array[i2] = formatTokenFunctions[array[i2]];
            } else {
              array[i2] = removeFormattingTokens(array[i2]);
            }
          }
          return function(mom) {
            var output = "", i3;
            for (i3 = 0; i3 < length2; i3++) {
              output += isFunction2(array[i3]) ? array[i3].call(mom, format2) : array[i3];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i2 = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i2 >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i2 -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value2 = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value2 = absFloor(coercedNumber);
          }
          return value2;
        }
        function makeGetSet(unit, keepTime) {
          return function(value2) {
            if (value2 != null) {
              set$1(this, unit, value2);
              hooks2.updateOffset(this, keepTime);
              return this;
            } else {
              return get2(this, unit);
            }
          };
        }
        function get2(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value2) {
          if (mom.isValid() && !isNaN(value2)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value2 = toInt(value2);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                value2,
                mom.month(),
                daysInMonth(value2, mom.month())
              );
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction2(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value2) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
            for (i2 = 0; i2 < prioritizedLen; i2++) {
              this[prioritized[i2].unit](units[prioritized[i2].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction2(this[units])) {
              return this[units](value2);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(
            s.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token2, callback2) {
          var i2, func = callback2, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber2(callback2)) {
            func = function(input, array) {
              array[callback2] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i2 = 0; i2 < tokenLen; i2++) {
            tokens[token2[i2]] = func;
          }
        }
        function addWeekParseToken(token2, callback2) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback2(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i2;
            for (i2 = 0; i2 < this.length; ++i2) {
              if (this[i2] === o) {
                return i2;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray2(this._months) ? this._months : this._months["standalone"];
          }
          return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i2, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i2 = 0; i2 < 12; ++i2) {
              mom = createUTC([2e3, i2]);
              this._shortMonthsParse[i2] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i2, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i2 = 0; i2 < 12; i2++) {
            mom = createUTC([2e3, i2]);
            if (strict && !this._longMonthsParse[i2]) {
              this._longMonthsParse[i2] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i2] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i2]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
              return i2;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
              return i2;
            } else if (!strict && this._monthsParse[i2].test(monthName)) {
              return i2;
            }
          }
        }
        function setMonth(mom, value2) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value2 === "string") {
            if (/^\d+$/.test(value2)) {
              value2 = toInt(value2);
            } else {
              value2 = mom.localeData().monthsParse(value2);
              if (!isNumber2(value2)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
          return mom;
        }
        function getSetMonth(value2) {
          if (value2 != null) {
            setMonth(this, value2);
            hooks2.updateOffset(this, true);
            return this;
          } else {
            return get2(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
          for (i2 = 0; i2 < 12; i2++) {
            mom = createUTC([2e3, i2]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i2 = 0; i2 < 12; i2++) {
            shortPieces[i2] = regexEscape(shortPieces[i2]);
            longPieces[i2] = regexEscape(longPieces[i2]);
          }
          for (i2 = 0; i2 < 24; i2++) {
            mixedPieces[i2] = regexEscape(mixedPieces[i2]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks2.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks2.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks2.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          doy: 6
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i2 = 0; i2 < 7; ++i2) {
              mom = createUTC([2e3, 1]).day(i2);
              this._minWeekdaysParse[i2] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i2] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i2, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i2 = 0; i2 < 7; i2++) {
            mom = createUTC([2e3, 1]).day(i2);
            if (strict && !this._fullWeekdaysParse[i2]) {
              this._fullWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i2]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
              return i2;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
          for (i2 = 0; i2 < 7; i2++) {
            mom = createUTC([2e3, 1]).day(i2);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i2, minl = Math.min(arr1.length, arr2.length);
          for (i2 = 0; i2 < minl; i2 += 1) {
            if (arr1[i2] !== arr2[i2]) {
              return i2;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names2) {
          var i2 = 0, j, next, locale2, split;
          while (i2 < names2.length) {
            split = normalizeLocale(names2[i2]).split("-");
            j = split.length;
            next = normalizeLocale(names2[i2 + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i2++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return name.match("^[^/\\\\]*$") != null;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray2(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
              if (isoDates[i2][1].exec(match[1])) {
                dateFormat = isoDates[i2][0];
                allowTime = isoDates[i2][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
                if (isoTimes[i2][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i2][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks2.createFromInputFallback(config);
          }
        }
        hooks2.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults3(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks2.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults3(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
            config._a[i2] = input[i2] = currentDate[i2];
          }
          for (; i2 < 7; i2++) {
            config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults3(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults3(w.W, 1);
            weekday = defaults3(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults3(w.gg, config._a[YEAR], curWeek.year);
            week = defaults3(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks2.ISO_8601 = function() {
        };
        hooks2.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks2.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks2.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i2 = 0; i2 < tokenLen; i2++) {
            token2 = tokens2[i2];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i2 = 0; i2 < configfLen; i2++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i2];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
          config._a = map3(
            [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate2(input)) {
            config._d = input;
          } else if (isArray2(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks2.now());
          } else if (isDate2(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray2(input)) {
            config._a = map3(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject3(input)) {
            configFromObject(config);
          } else if (isNumber2(input)) {
            config._d = new Date(input);
          } else {
            hooks2.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject3(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy(fn, moments) {
          var res, i2;
          if (moments.length === 1 && isArray2(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i2 = 1; i2 < moments.length; ++i2) {
            if (!moments[i2].isValid() || moments[i2][fn](res)) {
              res = moments[i2];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i2, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i2 = 0; i2 < orderLen; ++i2) {
            if (m[ordering[i2]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign3 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign3 = "-";
            }
            return sign3 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts2, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts2 = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts2[1] * 60) + toInt(parts2[2]);
          return minutes2 === 0 ? 0 : parts2[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks2.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks2.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks2.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign3, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber2(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign3 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign3,
              h: toInt(match[HOUR]) * sign3,
              m: toInt(match[MINUTE]) * sign3,
              s: toInt(match[SECOND]) * sign3,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign3
            };
          } else if (match = isoRegex.exec(input)) {
            sign3 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign3),
              M: parseIso(match[3], sign3),
              w: parseIso(match[4], sign3),
              d: parseIso(match[5], sign3),
              h: parseIso(match[6], sign3),
              m: parseIso(match[7], sign3),
              s: parseIso(match[8], sign3)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign3) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign3;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get2(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks2.updateOffset(mom, days2 || months2);
          }
        }
        var add2 = createAdder(1, "add"), subtract2 = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate2(input) || isString(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i2, property, propertyLen = properties.length;
          for (i2 = 0; i2 < propertyLen; i2 += 1) {
            property = properties[i2];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray2(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber2(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i2, property;
          for (i2 = 0; i2 < properties.length; i2 += 1) {
            property = properties[i2];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks2.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now2))
          );
        }
        function clone2() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from3, to3, units, inclusivity) {
          var localFrom = isMoment(from3) ? from3 : createLocal(from3), localTo = isMoment(to3) ? to3 : createLocal(to3);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks2.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks2.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString2() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction2(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix2, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix2 = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix2 + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks2.defaultFormatUtc : hooks2.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from2(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to2(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks2.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks2.updateOffset(this, true);
          return this;
        }
        function valueOf2() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token2) {
            var era = config._locale.erasParse(input, token2, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i2, l, date, eras = this._eras || getLocale("en")._eras;
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            switch (typeof eras[i2].since) {
              case "string":
                date = hooks2(eras[i2].since).startOf("day");
                eras[i2].since = date.valueOf();
                break;
            }
            switch (typeof eras[i2].until) {
              case "undefined":
                eras[i2].until = Infinity;
                break;
              case "string":
                date = hooks2(eras[i2].until).startOf("day").valueOf();
                eras[i2].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i2, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            name = eras[i2].name.toUpperCase();
            abbr = eras[i2].abbr.toUpperCase();
            narrow = eras[i2].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i2];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i2];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i2];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i2];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks2(era.since).year();
          } else {
            return hooks2(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].name;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].narrow;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].abbr;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i2, l, dir, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            dir = eras[i2].since <= eras[i2].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
              return (this.year() - hooks2(eras[i2].since).year()) * dir + eras[i2].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, eras = this.eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            namePieces.push(regexEscape(eras[i2].name));
            abbrPieces.push(regexEscape(eras[i2].abbr));
            narrowPieces.push(regexEscape(eras[i2].narrow));
            mixedPieces.push(regexEscape(eras[i2].name));
            mixedPieces.push(regexEscape(eras[i2].abbr));
            mixedPieces.push(regexEscape(eras[i2].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks2.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add2;
        proto.calendar = calendar$1;
        proto.clone = clone2;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from2;
        proto.fromNow = fromNow;
        proto.to = to2;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract2;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString2;
        proto.unix = unix;
        proto.valueOf = valueOf2;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set2;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index2, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index2);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index2, field) {
          if (isNumber2(format2)) {
            index2 = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index2 != null) {
            return get$1(format2, index2, field, "month");
          }
          var i2, out = [];
          for (i2 = 0; i2 < 12; i2++) {
            out[i2] = get$1(format2, i2, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index2, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber2(format2)) {
              index2 = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index2 = format2;
            localeSorted = false;
            if (isNumber2(format2)) {
              index2 = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
          if (index2 != null) {
            return get$1(format2, (index2 + shift) % 7, field, "day");
          }
          for (i2 = 0; i2 < 7; i2++) {
            out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index2) {
          return listMonthsImpl(format2, index2, "months");
        }
        function listMonthsShort(format2, index2) {
          return listMonthsImpl(format2, index2, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks2.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks2.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value2, direction) {
          var other = createDuration(input, value2);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value2) {
          return addSubtract$1(this, input, value2, 1);
        }
        function subtract$1(input, value2) {
          return addSubtract$1(this, input, value2, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$12() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round2 = Math.round, thresholds = {
          ss: 44,
          s: 45,
          m: 45,
          h: 22,
          d: 26,
          w: null,
          M: 11
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round2;
          }
          if (typeof roundingFunction === "function") {
            round2 = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign2(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
          daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
          hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$12;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks2.version = "2.29.4";
        setHookCallback(createLocal);
        hooks2.fn = proto;
        hooks2.min = min;
        hooks2.max = max;
        hooks2.now = now;
        hooks2.utc = createUTC;
        hooks2.unix = createUnix;
        hooks2.months = listMonths;
        hooks2.isDate = isDate2;
        hooks2.locale = getSetGlobalLocale;
        hooks2.invalid = createInvalid;
        hooks2.duration = createDuration;
        hooks2.isMoment = isMoment;
        hooks2.weekdays = listWeekdays;
        hooks2.parseZone = createInZone;
        hooks2.localeData = getLocale;
        hooks2.isDuration = isDuration;
        hooks2.monthsShort = listMonthsShort;
        hooks2.weekdaysMin = listWeekdaysMin;
        hooks2.defineLocale = defineLocale;
        hooks2.updateLocale = updateLocale;
        hooks2.locales = listLocales;
        hooks2.weekdaysShort = listWeekdaysShort;
        hooks2.normalizeUnits = normalizeUnits;
        hooks2.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks2.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks2.calendarFormat = getCalendarFormat;
        hooks2.prototype = proto;
        hooks2.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          DATE: "YYYY-MM-DD",
          TIME: "HH:mm",
          TIME_SECONDS: "HH:mm:ss",
          TIME_MS: "HH:mm:ss.SSS",
          WEEK: "GGGG-[W]WW",
          MONTH: "YYYY-MM"
        };
        return hooks2;
      });
    }
  });

  // assets/src/admin/js/Common/Utilities/index.js
  var import_moment, Helpers, GenieHelpers;
  var init_Utilities = __esm({
    "assets/src/admin/js/Common/Utilities/index.js"() {
      init_RequestManager();
      import_moment = __toESM(require_moment());
      Helpers = class {
        storeTimeout = {};
        callStoreApi(name, data) {
          if (!window.getGenie.blogWizardData?.post_id) {
            return;
          }
          if (window.getGenie.config.saveData) {
            window.getGenie.config.saveData(name, data);
          } else {
            const url2 = EndPoints_exports.storeApiUrl + "/" + name + "/";
            fetch(url2, {
              method: "POST",
              body: JSON.stringify(data),
              headers: {
                "Content-type": "application/json; charset=UTF-8",
                "X-WP-Nonce": window.getGenie.config?.restNonce || ""
              }
            });
          }
        }
        storeData = (name) => {
          if (this.storeTimeout[name]) {
            clearTimeout(this.storeTimeout[name]);
          }
          this.storeTimeout[name] = setTimeout(() => {
            const inputs = wp.data.select("getgenie").getInputs();
            this.callStoreApi(name, inputs[name] || "");
          }, 3e3);
        };
        copyToClipboard(copyAbleText) {
          if (navigator?.clipboard && window?.isSecureContext) {
            return navigator.clipboard.writeText(copyAbleText);
          } else {
            let textArea = document.createElement("textarea");
            textArea.value = copyAbleText;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            return new Promise((resolve2, reject) => {
              document.execCommand("copy") ? resolve2() : reject();
              textArea.remove();
            });
          }
        }
        formatLargeNumber(n) {
          if (n < 1e3)
            return n;
          if (n >= 1e3 && n < 1e6)
            return +(n / 1e3).toFixed(1) + "K";
          if (n >= 1e6 && n < 1e9)
            return +(n / 1e6).toFixed(1) + "M";
          if (n >= 1e9 && n < 1e12)
            return +(n / 1e9).toFixed(1) + "B";
          if (n >= 1e12)
            return +(n / 1e12).toFixed(1) + "T";
        }
        getDomainName(url2) {
          try {
            const parsedUrl = new URL(url2);
            return parsedUrl.hostname.split(".").slice(-2).join(".");
          } catch (e) {
            return "";
          }
        }
        saveSidebarControllerOption(key, value2) {
          if (!key || !value2) {
            return;
          }
          localStorage.setItem(key, JSON.stringify(value2));
          if (key == "getgenie-language") {
            wp.data.dispatch("getgenie").setSidebar({
              currentLanguage: value2
            });
          }
        }
        snakeToTitleCase = (str) => {
          let initial = str.replace(/^[_]*(.)/, (_, char) => char.toUpperCase());
          let result = initial.replace(/[_]+(.)/g, (_, char) => " " + char.toUpperCase());
          return result;
        };
        camelCaseToTitleCase(text) {
          const result = text.replace(/([A-Z])/g, " $1").trim();
          const finalResult = result.charAt(0).toUpperCase() + result.slice(1).toLowerCase();
          return finalResult;
        }
        hyphenatedToCamelCase(text) {
          return text.replace(/-([a-z])/g, (g) => {
            return g[1].toUpperCase();
          });
        }
        joinArray(values, separator = "-") {
          if (values && values.length > 1) {
            return values.join(separator);
          }
          return "";
        }
        sortObjArray(a, b) {
          if (a.last_nom < b.last_nom) {
            return -1;
          }
          if (a.last_nom > b.last_nom) {
            return 1;
          }
          return 0;
        }
        convertToSlug(text) {
          return text?.toLowerCase().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
        }
        getCurrentDateTime = (date) => {
          const isPlayground = window.getGenie?.isPlayground;
          if (!isPlayground) {
            return date;
          }
          const format = "YYYY-MM-DD HH:mm:ssZ";
          const adjustedTime = (0, import_moment.default)(date, format).format("YYYY-MM-DD, h:mm:ss A");
          return adjustedTime;
        };
        isExistDomain = (siteURL) => {
          const domainList = ["shopify", "wikipedia", "youtube", "amazon", "aliexpress", "walmart", "alibaba", "bookshop", "etsy", "flipkart", "netflix", "reddit", "quora"];
          return domainList.some((domain) => siteURL?.includes(domain));
        };
      };
      GenieHelpers = new Helpers();
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/WebSourceAnalysis.js
  var WebSourceAnalysis;
  var init_WebSourceAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/WebSourceAnalysis.js"() {
      init_flekin();
      init_Utilities();
      init_KeywordFinder();
      WebSourceAnalysis = class {
        focusKeyword = "";
        scrapping(webSource, focusKeyword = "") {
          let html = webSource?.html || "";
          let rank = webSource?.rank || "";
          const article = webSource?.pageContent || {};
          this.focusKeyword = focusKeyword.trim();
          const scraping = {};
          scraping.content = [];
          const doc = new DOMParser().parseFromString(html, "text/html");
          let favicon = doc.querySelector("link[rel~='icon']")?.href || "";
          if (favicon.startsWith(location?.origin)) {
            favicon = "";
          }
          let result = {};
          let plainText = (article?.content || "").replace(/<(\/?(ul|ol|li|div|br|hr)|>)[^>]*>/gim, "\n").replace(/<(?!\/?(h1|h2|h3|h4|h5|h6|a|p|div)|>)[^>]*>/gim, "");
          plainText = this.cleanText(plainText);
          let headingList = this.getHeadings(plainText);
          if (headingList.count > 50) {
            return;
          }
          let content = this.getContents(headingList.headings) || [];
          let images = article?.content?.match(/<img [^>]*src="[^"]*"[^>]*>/gi)?.length || 0;
          if (images > 50) {
            return;
          }
          let allLinks = article?.content?.match(/<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/gmi);
          let internalLinks = 0, externalLinks = 0, url2 = GenieHelpers.getDomainName(article?.url);
          if (allLinks && url2) {
            internalLinks = allLinks.filter((link) => {
              return link.includes(url2);
            }).length;
            externalLinks = allLinks.filter((link) => {
              return !link.includes(url2);
            }).length;
          }
          let focusKeywordInAltText = 1;
          let keywordFinder5 = new KeywordFinder();
          let altText = article?.content?.match(/<img\s+(?:[^>]*?\s+)?alt=(["'])(.*?)\1/gi);
          if (altText) {
            let allTexts = altText.join(" ");
            focusKeywordInAltText = keywordFinder5.findSingleMatch(allTexts, this.focusKeyword);
            focusKeywordInAltText = focusKeywordInAltText ? 0 : 1;
          }
          let words = flekin((plainText || " ").replace(/<[^>]*>/gmi, " "))?.word_count || 0;
          if (words > 8e3) {
            return;
          }
          const isExistURL = GenieHelpers.isExistDomain(url2);
          result = {
            rank,
            url: webSource?.url,
            keySlug: webSource?.keySlug,
            title: article?.title,
            description: article?.excerpt,
            favicon,
            content,
            source: plainText,
            textContent: (plainText || "").replace(/<[^>]*>/gim, " ")
          };
          result.stat = {
            images: isExistURL ? 0 : images,
            internalLinks: isExistURL ? 0 : internalLinks,
            externalLinks: isExistURL ? 0 : externalLinks,
            focusKeywordInAltText: isExistURL ? 0 : focusKeywordInAltText,
            headings: isExistURL ? 0 : headingList.count,
            words: isExistURL ? 0 : words
          };
          return result;
        }
        getHeadings = (content, lowerLimit = 5, upperLimit = 50) => {
          let html = document.createElement("div");
          html.innerHTML = content;
          let elements = "h2, h3";
          let headings = jQuery(html).find(elements);
          for (const tag of ["h4", "h5", "h6"]) {
            if (headings?.length < lowerLimit && headings?.length < upperLimit) {
              elements += ", " + tag;
              headings = jQuery(html).find(elements);
            } else {
              break;
            }
          }
          return { headings, count: headings?.length || 0 };
        };
        getContents(headings) {
          if (!headings || headings?.length === 0) {
            return;
          }
          let cleaner = this.cleanText;
          let contents = [];
          headings.each(function(index2) {
            let tag = jQuery(this).prop("tagName").toLowerCase();
            let title = jQuery(this).text();
            title = cleaner(title.replace(/<(\/?(a)|>)[^>]*>/gim, ""));
            title = title.replace(/\&nbsp;/g, " ");
            if (title == "" || title.match(/\d*(,|\/)\d*/gis) || title.match(/(\w+)/gis)?.length < 2) {
              return;
            }
            let text = "";
            const analyzeElement = (el) => {
              let textContent = el?.textContent || "";
              if (textContent.trim() === "" || textContent.match(/(\w+)/gis)?.length < 5) {
                return;
              }
              text += jQuery(el).html();
            };
            if (index2 === headings.length - 1) {
              jQuery(this).nextAll("div, p").each(function(i2, el) {
                analyzeElement(el);
              });
            } else {
              jQuery(this).nextUntil(headings[index2 + 1]).each(function(i2, el) {
                analyzeElement(el);
              });
            }
            text = cleaner(text.replace(/<(\/?(p)|>)[^>]*>/gim, "\n"));
            if (text == "") {
              return;
            }
            contents.push({ tag, title, text });
          });
          return contents;
        }
        cleanText = (str) => {
          str = str.replace(/\s\s+/gm, " ");
          str = str.replace(/  +/gm, " ");
          str = str.replace(/\n+/gm, "\n");
          return str.trim();
        };
        getStat = (contentList, relatedKeywords2 = []) => {
          const statistics = {};
          const keywordUsage = {};
          const keywordFinder5 = new KeywordFinder();
          let allStats = {
            total: {},
            max: {}
          };
          for (const [index2, keywordObj] of relatedKeywords2.entries()) {
            const keyword = keywordObj?.keyword || "";
            let currentKeyword = keyword.trim().toLowerCase();
            let totalMaxCount = 0;
            let headingMaxCount = 0;
            let contentMaxCount = 0;
            let headingLength = 0;
            let contentLength = 0;
            let headingTotal = 0;
            let contentTotal = 0;
            let metaTitleMaxCount = 1;
            let metaDescriptionMaxCount = 1;
            let metaTitleLength = 0;
            let metaDescriptionLength = 0;
            let metaTitleTotal = 0;
            let metaDescriptionTotal = 0;
            contentList.map((item) => {
              if (index2 === 0) {
                for (const [stat, value2] of Object.entries(item?.stat || {})) {
                  if (!allStats?.total?.[stat]) {
                    allStats.total[stat] = 0;
                  }
                  if (!allStats?.max?.[stat]) {
                    allStats.max[stat] = 0;
                  }
                  allStats.total[stat] += value2;
                  if (allStats.max[stat] < value2) {
                    allStats.max[stat] = value2;
                  }
                }
              }
              let match = 0;
              let headingMatch = 0;
              let contentMatch = 0;
              item.content.map((item2) => {
                let title = (item2?.title || "").toLowerCase();
                let text = (item2?.text || "").toLowerCase();
                if (title) {
                  headingLength++;
                  headingMatch += keywordFinder5.findSingleMatch(title, currentKeyword);
                }
                if (text) {
                  contentLength++;
                  contentMatch += keywordFinder5.findSingleMatch(text, currentKeyword);
                }
              });
              if (headingMaxCount < headingMatch) {
                headingMaxCount = headingMatch;
              }
              if (contentMaxCount < contentMatch) {
                contentMaxCount = contentMatch;
              }
              match = headingMatch + contentMatch;
              if (totalMaxCount < match) {
                totalMaxCount = match;
              }
              headingTotal += headingMatch;
              contentTotal += contentMatch;
              if (keywordObj.type === "focus") {
                let countInMetaTitle = keywordFinder5.findSingleMatch(item.title, currentKeyword);
                let countInMetaDescription = keywordFinder5.findSingleMatch(item.description, currentKeyword);
                if (countInMetaTitle > 0) {
                  metaTitleTotal += item.title.split(currentKeyword)?.length - 1;
                  metaTitleLength++;
                  metaTitleMaxCount = metaTitleMaxCount < metaTitleTotal ? metaTitleTotal : metaTitleMaxCount;
                }
                if (countInMetaDescription > 0) {
                  metaDescriptionTotal += item.description.split(currentKeyword)?.length - 1;
                  metaDescriptionLength++;
                  metaDescriptionMaxCount = metaDescriptionMaxCount < metaDescriptionTotal ? metaDescriptionTotal : metaDescriptionMaxCount;
                }
                keywordUsage[keyword] = {
                  type: "focus"
                };
                if (totalMaxCount === 0) {
                  totalMaxCount = 1;
                }
              }
            });
            if (keywordObj.type === "focus") {
              if (!keywordUsage[keyword]) {
                keywordUsage[keyword] = {
                  type: "focus"
                };
              }
              keywordUsage[keyword].metaTitle = [Math.ceil(metaTitleTotal / metaTitleLength) || 1, metaTitleMaxCount];
              keywordUsage[keyword].metaDescription = [Math.ceil(metaDescriptionTotal / metaDescriptionLength) || 1, metaDescriptionMaxCount];
            }
            if (totalMaxCount === 0) {
              continue;
            }
            if (!keywordUsage[keyword]) {
              keywordUsage[keyword] = {
                type: keywordObj.type
              };
            }
            if (headingMaxCount > 0) {
              keywordUsage[keyword].heading = [Math.ceil(headingTotal / headingLength), headingMaxCount];
            }
            if (contentMaxCount > 0) {
              keywordUsage[keyword].content = [Math.ceil(contentTotal / contentLength), contentMaxCount];
            }
            if (totalMaxCount > 0) {
              let ceilValue = Math.ceil((headingTotal + contentTotal) / (headingLength + contentLength));
              keywordUsage[keyword].total = [ceilValue < 1 ? 1 : ceilValue, totalMaxCount];
            }
          }
          if (keywordUsage?.[this.focusKeyword]) {
            keywordUsage[this.focusKeyword].imgAltText = [
              Math.ceil(allStats.total["focusKeywordInAltText"] / allStats.total["images"]),
              allStats.max["focusKeywordInAltText"]
            ];
          }
          statistics.keywords = keywordUsage;
          statistics.HtmlTagUsage = {};
          statistics.HtmlTagUsage.paragraphUsage = [0, 0];
          statistics.HtmlTagUsage.headingUsage = [Math.ceil(allStats.total["headings"] / contentList.length) || 0, allStats.max["headings"]];
          statistics.HtmlTagUsage.imageUsage = [Math.ceil(allStats.total["images"] / contentList.length) || 0, allStats.max["images"]];
          statistics.HtmlTagUsage.wordUsage = [Math.round(allStats.total["words"] / contentList.length) || 0, allStats.max["words"]];
          let internalLinkRecommendation = [1, 1];
          if (allStats.max["internalLinks"] > 0) {
            internalLinkRecommendation = [Math.ceil(allStats.total["internalLinks"] / contentList.length) || 0, allStats.max["internalLinks"]];
          }
          let externalLinkRecommendation = [1, 1];
          if (allStats.max["externalLinks"] > 0) {
            externalLinkRecommendation = [Math.ceil(allStats.total["externalLinks"] / contentList.length) || 0, allStats.max["externalLinks"]];
          }
          statistics.HtmlTagUsage.internalLinkUsage = internalLinkRecommendation;
          statistics.HtmlTagUsage.externalLinkUsage = externalLinkRecommendation;
          return statistics;
        };
      };
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/InsertHandler.js
  var InsertHandler;
  var init_InsertHandler = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/InsertHandler.js"() {
      InsertHandler = class {
        insertionField = null;
        editorName = null;
        currentDocument = document;
        constructor(isBlockEditor) {
          if (isBlockEditor) {
            this.editorName = "gutenberg";
            this.insertionField = document.querySelector(".is-root-container.wp-block-post-content");
          } else {
            this.findInsertionField();
          }
        }
        findInsertionField = () => {
          const isClassicEditor = document.getElementById("wp-content-editor-container");
          const textarea = document.querySelector(".wp-editor-area");
          let textareaDisplay = "none";
          if (textarea) {
            textareaDisplay = window.getComputedStyle(textarea).display;
          }
          const iframe = document.getElementById("content_ifr");
          const iframeDocument = iframe?.contentDocument || iframe?.contentWindow?.document;
          if (isClassicEditor && iframeDocument) {
            this.editorName = "classic";
            this.currentDocument = iframeDocument;
            const iframeBody = iframeDocument.body;
            this.insertionField = iframeBody;
          }
          if (isClassicEditor && textareaDisplay === "block") {
            this.editorName = "classic";
            this.currentDocument = document;
            this.insertionField = textarea;
          }
          if (document.querySelector("#web-view-editor .ql-editor")) {
            this.insertionField = document.querySelector("#web-view-editor .ql-editor");
            this.editorName = "classic";
          }
        };
        insertInClassicEditor = (title, intro, outlines2, paragraphs) => {
          this.insertionField.innerHTML = "";
          if (document.getElementById("post-body-content") && document.getElementById("title")) {
            const titleField = document.getElementById("title");
            titleField.value = title;
            const label = document.getElementById("title-prompt-text");
            label.classList.add("screen-reader-text");
          }
          if (document.querySelector("#web-view-editor .ql-editor")) {
            const h12 = this.currentDocument.createElement("h1");
            h12.classList.add("blog-title");
            h12.innerHTML = title;
            this.insertionField.appendChild(h12);
          }
          intro = intro.replace(/\n+/gm, "\n").replace(/\n/gm, "<br/> <br/>");
          if (this.insertionField?.tagName === "TEXTAREA") {
            this.insertionField.value = this.insertionField.value + intro;
          } else {
            const p = this.currentDocument.createElement("p");
            p.innerHTML = intro;
            this.insertionField.appendChild(p);
          }
          this.appendInClassicEditor(outlines2, paragraphs);
        };
        appendInClassicEditor = (outlines2, paragraphs) => {
          let newOutlines = [];
          let existingHeadings = [];
          let allBlocks = Array.from(this.insertionField.children);
          allBlocks.forEach((item) => {
            existingHeadings.push(item?.textContent);
          });
          newOutlines = outlines2.filter((item) => existingHeadings.indexOf(item) === -1);
          for (const outline of newOutlines) {
            const h22 = this.currentDocument.createElement("h2");
            h22.innerHTML = outline;
            if (this.insertionField?.tagName === "TEXTAREA") {
              this.insertionField.value = this.insertionField.value + h22.outerHTML;
            } else {
              this.insertionField.appendChild(h22);
            }
            let obj = paragraphs[outline];
            if (!obj) {
              continue;
            }
            ;
            const p = this.currentDocument.createElement("p");
            p.innerHTML = obj?.paragraph;
            if (this.insertionField?.tagName === "TEXTAREA") {
              this.insertionField.value = this.insertionField.value + p.outerHTML;
            } else {
              this.insertionField.appendChild(p);
            }
          }
        };
        insertInGutenbergBlock = (title, intro, outlines2, paragraphs) => {
          intro = intro.replace(/\n+/gm, "\n").replace(/\n/gm, "<br/> <br/>");
          wp.data.dispatch("core/editor").editPost({ title });
          wp.data.dispatch("core/editor").editPost({
            excerpt: intro
          });
          wp.data.dispatch("core/block-editor").resetBlocks(wp.blocks.parse(""));
          wp.data.dispatch("core/block-editor").insertBlocks(
            wp.blocks.createBlock("core/paragraph", {
              content: intro
            })
          );
          this.appendInGutenbergBlock(outlines2, paragraphs);
        };
        appendInGutenbergBlock = (outlines2, paragraphs) => {
          let existingHeadings = [];
          let newOutlines = [];
          let allBlocks = wp.data.select("core/block-editor").getBlocks();
          for (const item of allBlocks) {
            if (item?.name == "core/heading") {
              if (item?.originalContent) {
                existingHeadings.push(item?.originalContent.replace(/<\/?[^>]+(>|$)/g, ""));
              } else {
                existingHeadings.push(item?.attributes?.content?.replace(/<\/?[^>]+(>|$)/g, ""));
              }
            }
          }
          newOutlines = outlines2.filter((item) => existingHeadings.indexOf(item) === -1);
          for (const outline of newOutlines) {
            wp.data.dispatch("core/block-editor").insertBlocks(
              wp.blocks.createBlock("core/heading", {
                content: outline
              })
            );
            let obj = paragraphs[outline];
            if (!obj) {
              continue;
            }
            ;
            wp.data.dispatch("core/block-editor").insertBlocks(
              wp.blocks.createBlock("core/paragraph", {
                content: obj?.paragraph
              })
            );
          }
        };
        appendOutlines = (outlines2, paragraphs) => {
          if (this.editorName === "classic") {
            this.appendInClassicEditor(outlines2, paragraphs);
          } else if (this.editorName === "gutenberg") {
            this.appendInGutenbergBlock(outlines2, paragraphs);
          }
          this.closeSidebar();
        };
        closeSidebar = () => {
          if (!window.getGenie?.isPlayground) {
            wp.data.dispatch("getgenie").setSidebar({
              open: false
            });
          } else {
            wp.data.dispatch("getgenie").setSidebar({
              open: true,
              component: "TemplateListScreen",
              currentTemplate: "list"
            });
          }
        };
        insertContent = (title, intro, outlines2, paragraphs) => {
          if (this.editorName === "classic") {
            this.insertInClassicEditor(title, intro, outlines2, paragraphs);
          } else if (this.editorName === "gutenberg") {
            this.insertInGutenbergBlock(title, intro, outlines2, paragraphs);
          }
          this.closeSidebar();
        };
        insertCompetitorContentGutenberg = (setIsInsertContent, content, heading, paragraph) => {
          let editor = wp.data.select("core/block-editor"), blocks = editor.getBlocks(), clientId = editor.getSelectedBlockClientId();
          let index2 = blocks.findIndex((item) => item.clientId === clientId);
          wp.data.dispatch("core/block-editor").insertBlocks(
            wp.blocks.createBlock("core/heading", {
              content: heading
            }),
            index2 + 1
          );
          wp.data.dispatch("core/block-editor").insertBlocks(
            wp.blocks.createBlock("core/paragraph", {
              content: paragraph
            }),
            index2 + 2
          );
          setIsInsertContent(content);
        };
        insertCompetitorContentIframe = (iframeId, setIsInsertContent, content, heading, paragraph) => {
          let iframe = document.getElementById(iframeId);
          let iframeWindow = iframe.contentDocument || iframe.contentWindow.document;
          let iframeSelectionElement = iframeWindow.getSelection().focusNode?.parentElement;
          let iframeHeadingNode = iframeWindow.createElement("h2");
          iframeHeadingNode.innerHTML = heading;
          let iframeParagraphNode = iframeWindow.createElement("p");
          iframeParagraphNode.innerHTML = paragraph;
          iframeSelectionElement.insertAdjacentElement("afterend", iframeHeadingNode);
          iframeHeadingNode.insertAdjacentElement("afterend", iframeParagraphNode);
          setIsInsertContent(content);
        };
        insertCompetitorContentWebview = (setIsInsertContent, content, heading, paragraph) => {
          const wrapper = document.querySelector("#web-view-editor .ql-editor");
          const h22 = document.createElement("h2");
          h22.innerHTML = heading;
          const p = document.createElement("p");
          p.innerHTML = paragraph;
          wrapper.appendChild(h22);
          wrapper.appendChild(p);
          setIsInsertContent(content);
        };
      };
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Competitor/index.js
  var Libs, Utilities, GenieHelpers2, Button, Card, Checkbox, Col, Divider, Row, Typography, Tooltip, ComposeComponents, useState, Competitor;
  var init_Competitor = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Competitor/index.js"() {
      init_InsertHandler();
      ({ Libs, Utilities } = window.getGenie.Components.Common);
      ({ GenieHelpers: GenieHelpers2 } = Utilities);
      ({ Button, Card, Checkbox, Col, Divider, Row, Typography, Tooltip } = window.antd);
      ({ ComposeComponents } = window.getGenie.Components.Common.ReduxManager);
      ({ useState } = window.React);
      Competitor = ComposeComponents(({ data, loading = false, loadingText = "", page = 0, getInputs, limitUsage: limitUsage2, setInput, sidebar: sidebar4, fetchData = null, setSidebar }) => {
        const [showTooltip, setShowTooltip] = useState("");
        const [isInsertContent, setIsInsertContent] = useState("");
        let insertHandler = new InsertHandler(window.getGenie.config.isBlockEditor);
        let selectedOutlines = getInputs["selectedOutlines"] || [];
        let competitorData2 = data;
        const onChange = (e, text) => {
          let items = [...selectedOutlines];
          if (items.indexOf(text) != -1) {
            items.splice(items.indexOf(text), 1);
          } else {
            items.push(text);
          }
          setInput("selectedOutlines", items);
        };
        const htmlDecode = (content) => {
          let e = document.createElement("div");
          e.innerHTML = content;
          e.querySelectorAll("a").forEach((item) => {
            item.setAttribute("target", "_blank");
          });
          return e.innerHTML;
        };
        const insertContent = (e, content) => {
          e.stopPropagation();
          if (isInsertContent === content)
            return;
          Libs.ConfirmModal("Insert Content?", `To avoid plagiarism from using someone else's content, 
							you're advised to either edit the content to add unique value or use GetGenie's 
							"text rewriter" template.`, () => {
            let contentArray = content.split(/<br\s*\/?>/gi);
            contentArray = contentArray.filter((item) => item !== "");
            let heading = contentArray[0];
            let paragraph = contentArray.slice(1).join("\n");
            if (window.getGenie.config.isBlockEditor) {
              insertHandler.insertCompetitorContentGutenberg(setIsInsertContent, content, heading, paragraph);
            }
            if (document.getElementById("post-body-content")) {
              insertHandler.insertCompetitorContentIframe("content_ifr", setIsInsertContent, content, heading, paragraph);
            }
            if (document.querySelector("#web-view-editor .ql-editor")) {
              insertHandler.insertCompetitorContentWebview(setIsInsertContent, content, heading, paragraph);
            }
          });
        };
        const copyContent = (e, content) => {
          e.stopPropagation();
          let copyAbleText = content.replace(/<br\s*\/?>/gi, "\n");
          copyAbleText = copyAbleText.replace(/<\/?[^>]+(>|$)/g, "");
          GenieHelpers2.copyToClipboard(copyAbleText).then(() => {
            setShowTooltip(content);
          }).catch(() => console.log("error"));
        };
        const isValidUrl = (url2) => {
          try {
            new URL(url2);
            return true;
          } catch (error) {
            return false;
          }
        };
        const loadMore = () => {
          fetchData();
        };
        let competitorList = competitorData2 || [];
        if (!Array.isArray(competitorList)) {
          competitorList = [];
        }
        let showLoadMore = (page < 3 || loading) && fetchData && getInputs["competitorData"]?.length > 0;
        const refetchCompetitorList = () => {
          setInput("competitorData", "");
          setSidebar({ analyzingCompetitors: true });
          fetchData();
        };
        return /* @__PURE__ */ React.createElement(React.Fragment, null, loading ? /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-loading-state"
        }, /* @__PURE__ */ React.createElement("span", null, loadingText), /* @__PURE__ */ React.createElement(Libs.Loading, {
          size: 22
        }), " ") : Array.isArray(getInputs["competitorData"]) ? showLoadMore ? /* @__PURE__ */ React.createElement("div", {
          className: "refetch-icon",
          onClick: refetchCompetitorList
        }, /* @__PURE__ */ React.createElement(Tooltip, {
          placement: "topLeft",
          title: "Refetch the competitor list"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "refetch-text"
        }, "Refetch")), /* @__PURE__ */ React.createElement("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          width: "22",
          height: "22",
          viewBox: "0 0 22 22",
          fill: "none"
        }, /* @__PURE__ */ React.createElement("circle", {
          cx: "11",
          cy: "11",
          r: "11",
          fill: "#031233",
          fillOpacity: "0.1"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M16.3793 10.3795H16.3787C16.2972 10.3796 16.2165 10.3957 16.1412 10.4269C16.066 10.4582 15.9976 10.504 15.94 10.5617C15.8824 10.6194 15.8367 10.6878 15.8056 10.7632C15.7745 10.8385 15.7585 10.9192 15.7586 11.0007C15.7578 11.871 15.5185 12.7243 15.0667 13.4681C14.6149 14.2118 13.9678 14.8175 13.1959 15.2192C12.424 15.621 11.5567 15.8034 10.6883 15.7468C9.81997 15.6902 8.98373 15.3966 8.27053 14.898C6.12132 13.3931 5.5971 10.4202 7.10202 8.27094C8.60693 6.1217 11.5798 5.59743 13.7291 7.1024C14.0542 7.32948 14.3497 7.59629 14.6087 7.89665H12.8619C12.6973 7.89665 12.5394 7.96205 12.423 8.07845C12.3066 8.19486 12.2412 8.35274 12.2412 8.51736C12.2412 8.68198 12.3066 8.83986 12.423 8.95627C12.5394 9.07268 12.6973 9.13807 12.8619 9.13807H15.7586C15.9232 9.13807 16.0811 9.07268 16.1975 8.95627C16.3139 8.83986 16.3793 8.68198 16.3793 8.51736V5.62071C16.3793 5.45609 16.3139 5.29821 16.1975 5.1818C16.0811 5.0654 15.9232 5 15.7586 5C15.594 5 15.4361 5.0654 15.3197 5.1818C15.2033 5.29821 15.1379 5.45609 15.1379 5.62071V6.65438C14.92 6.4477 14.6872 6.25752 14.4411 6.08539C13.7957 5.63347 13.0676 5.3131 12.2984 5.14257C11.5291 4.97204 10.7339 4.95469 9.95793 5.09151C9.182 5.22833 8.44061 5.51665 7.7761 5.93999C7.1116 6.36333 6.53698 6.91341 6.08506 7.55883C5.17237 8.8623 4.81486 10.475 5.09118 12.042C5.3675 13.6091 6.25502 15.0022 7.5585 15.9149C8.56207 16.6218 9.75954 17.0013 10.9871 17.0015C11.3406 17.0014 11.6935 16.9703 12.0417 16.9088C13.4309 16.6637 14.6893 15.9371 15.5961 14.8565C16.5028 13.7758 16.9999 12.4103 17 10.9997C16.9999 10.8351 16.9344 10.6774 16.818 10.5611C16.7016 10.4448 16.5438 10.3795 16.3793 10.3795Z",
          fill: "#57595F"
        }))) : "" : /* @__PURE__ */ React.createElement(Button, {
          className: "getgenie-fetch-competitor-btn",
          onClick: fetchData
        }, sidebar4.__("Fetch Data", "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-competitor-tab"
        }, competitorData2?.length === 0 ? /* @__PURE__ */ React.createElement(Typography.Title, {
          level: 5,
          className: "getgenie-not-found-title"
        }, sidebar4.__("No related data was found.", "getgenie")) : "", /* @__PURE__ */ React.createElement(Libs.BlurElement, {
          show: competitorList?.length > 3 && limitUsage2.subscription_type !== "pro",
          top: 960,
          text: "Analyze competitors for insights to stay ahead of them.",
          btnText: "Upgrade Now",
          href: "https://getgenie.ai/pricing/",
          textMargin: 0
        }, competitorList?.map(
          (item, index2, self2) => /* @__PURE__ */ React.createElement("div", {
            key: index2
          }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Row, {
            className: "getgenie-competitor-overview",
            gutter: 8
          }, /* @__PURE__ */ React.createElement(Col, {
            className: "gutter-row"
          }, loading ? "" : /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-text"
          }, sidebar4.__("Rank:", "getgenie"), " ", index2 + 1)), /* @__PURE__ */ React.createElement(Col, {
            className: "gutter-row"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-text"
          }, sidebar4.__("Words:", "getgenie"), " ", item?.stat?.words)), /* @__PURE__ */ React.createElement(Col, {
            className: "gutter-row"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-text"
          }, sidebar4.__("Heading:", "getgenie"), " ", item?.stat?.headings)), /* @__PURE__ */ React.createElement(Col, {
            className: "gutter-row"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-text"
          }, sidebar4.__("Images:", "getgenie"), " ", item?.stat?.images))), /* @__PURE__ */ React.createElement(Card, {
            className: "getgenie-competitor-card"
          }, /* @__PURE__ */ React.createElement("a", {
            href: item?.url,
            className: "getgenie-competitor-link",
            target: "_blank"
          }, isValidUrl(item?.favicon) ? /* @__PURE__ */ React.createElement("img", {
            className: "page-favicon",
            src: item?.favicon
          }) : /* @__PURE__ */ React.createElement("span", {
            className: "page-url getgenie-icon-earth"
          }), /* @__PURE__ */ React.createElement(Typography.Text, {
            className: "page-url",
            ellipsis: { tooltip: item?.url }
          }, item?.url)), /* @__PURE__ */ React.createElement(Typography.Title, {
            level: 5,
            className: "getgenie-competitor-title"
          }, item.title), /* @__PURE__ */ React.createElement("p", {
            className: "getgenie-competitor-text",
            dangerouslySetInnerHTML: { __html: htmlDecode(item?.description || "") }
          }), /* @__PURE__ */ React.createElement(Libs.Popover, {
            content: /* @__PURE__ */ React.createElement("div", {
              className: "getgenie-tags-popover"
            }, /* @__PURE__ */ React.createElement(Libs.Collapse, {
              showArrow: false,
              accordion: true
            }, item?.content?.map(
              (content, index3) => /* @__PURE__ */ React.createElement(Libs.Collapse.Panel, {
                key: index3,
                header: /* @__PURE__ */ React.createElement("div", {
                  className: "getgenie-competitor-tag-container"
                }, sidebar4.currentScreen === "outlineScreen" ? /* @__PURE__ */ React.createElement("div", {
                  onClick: (e) => e.stopPropagation()
                }, /* @__PURE__ */ React.createElement(Checkbox, {
                  checked: selectedOutlines.indexOf(content.title) != -1,
                  onChange: (e) => onChange(e, content?.title)
                }, /* @__PURE__ */ React.createElement("div", {
                  className: "tag-content"
                }, /* @__PURE__ */ React.createElement("h5", {
                  className: "tag-name"
                }, content?.tag), /* @__PURE__ */ React.createElement("h5", {
                  className: "tag-title"
                }, content?.title)))) : /* @__PURE__ */ React.createElement("div", {
                  className: "tag-content"
                }, /* @__PURE__ */ React.createElement("h5", {
                  className: "tag-name"
                }, content?.tag), /* @__PURE__ */ React.createElement("h5", {
                  className: "tag-title"
                }, content?.title)), /* @__PURE__ */ React.createElement("div", {
                  className: "actions"
                }, sidebar4.currentScreen !== "outlineScreen" ? /* @__PURE__ */ React.createElement("div", {
                  className: "item-button"
                }, /* @__PURE__ */ React.createElement("div", {
                  className: "copy"
                }, /* @__PURE__ */ React.createElement(Tooltip, {
                  placement: "bottom",
                  zIndex: 99999,
                  title: showTooltip === content?.title + " " + content?.text ? "Copied" : "Copy this content"
                }, /* @__PURE__ */ React.createElement("span", {
                  className: "copy-icon getgenie-icon-copy",
                  onClick: (e) => copyContent(e, content?.title + " " + content?.text)
                }))), /* @__PURE__ */ React.createElement("div", {
                  className: "insert"
                }, /* @__PURE__ */ React.createElement(Tooltip, {
                  title: isInsertContent !== content?.title + "<br>" + content?.text ? "Insert into the editor" : "Already inserted",
                  placement: "bottom",
                  zIndex: 99999
                }, /* @__PURE__ */ React.createElement("span", {
                  className: `insert-icon ${isInsertContent === content?.title + "<br>" + content?.text ? "getgenie-icon-check" : "getgenie-icon-insert"}`,
                  onClick: (e) => insertContent(e, content?.title + "<br>" + content?.text)
                })))) : " ", /* @__PURE__ */ React.createElement("span", {
                  className: "custom-collapse-icon getgenie-icon-arrow_down"
                })))
              }, /* @__PURE__ */ React.createElement("p", {
                dangerouslySetInnerHTML: { __html: htmlDecode(content?.text) }
              }))
            ))),
            overlayStyle: {
              width: "500px",
              height: "350px"
            },
            overlayClassName: "getgenie-competitor-popover",
            placement: "left"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-competitor-tag"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-competitor-tag-list"
          }, /* @__PURE__ */ React.createElement(Typography.Title, {
            level: 5,
            className: "getgenie-competitor-tag-name"
          }, item?.content[0]?.tag), /* @__PURE__ */ React.createElement(Typography.Title, {
            level: 5,
            className: "getgenie-competitor-tag-content"
          }, item?.content[0]?.title)), /* @__PURE__ */ React.createElement(Button, {
            disabled: item?.content?.length === 0,
            className: "getgenie-competitor-tag-moreBtn",
            type: "link"
          }, sidebar4.__("more contents", "getgenie"), /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-arrow-up-right"
          })))))), index2 != self2.length - 1 && /* @__PURE__ */ React.createElement(Divider, null))
        ), showLoadMore ? /* @__PURE__ */ React.createElement(Libs.Button, {
          loading,
          onClick: loadMore
        }, "Load More") : "")));
      }, ["sidebar", "getInputs", "setInput", "limitUsage", "setSidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/KeywordAnalysis.js
  var Col2, Row2, Typography2, Divider2, ComposeComponents2, KeywordAnalysis;
  var init_KeywordAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/KeywordAnalysis.js"() {
      ({ Col: Col2, Row: Row2, Typography: Typography2, Divider: Divider2 } = window.antd);
      ({ ComposeComponents: ComposeComponents2 } = window.getGenie.Components.Common.ReduxManager);
      KeywordAnalysis = ComposeComponents2(({ getInputs, sidebar: sidebar4 }) => {
        const analysisData = getInputs["searchVolume"];
        const data = [
          { title: "Last Month", value: analysisData?.searchVolume?.lastMonth },
          { title: "Average 12 month", value: analysisData?.searchVolume?.avg12Month },
          { title: "Highest", value: analysisData?.searchVolume?.highest },
          { title: "Lowest", value: analysisData?.searchVolume?.lowest }
        ];
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-keyword-analysis"
        }, /* @__PURE__ */ React.createElement(Typography2.Title, {
          level: 4,
          className: "getgenie-title"
        }, sidebar4.__("Keyword Analysis", "getgenie")), analysisData ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Row2, {
          gutter: 6
        }, /* @__PURE__ */ React.createElement(Col2, {
          className: "gutter-row",
          flex: "auto"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-keyword-result volume"
        }, /* @__PURE__ */ React.createElement(Typography2.Title, {
          level: 5,
          className: "getgenie-title"
        }, sidebar4.__("Search Volume", "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-result-item"
        }, /* @__PURE__ */ React.createElement(Typography2.Text, {
          className: "getgenie-text"
        }, analysisData?.searchVolume?.total || "-"), /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-search"
        })))), /* @__PURE__ */ React.createElement(Col2, {
          className: "gutter-row",
          flex: "auto"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-keyword-result competition"
        }, /* @__PURE__ */ React.createElement(Typography2.Title, {
          level: 5,
          className: "getgenie-title"
        }, sidebar4.__("Competition", "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-result-item"
        }, /* @__PURE__ */ React.createElement(Typography2.Text, {
          className: "getgenie-text"
        }, analysisData?.searchVolume?.competition || "-"), /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-competition_icon"
        })))), /* @__PURE__ */ React.createElement(Col2, {
          className: "gutter-row",
          flex: "auto"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-keyword-result cpc"
        }, /* @__PURE__ */ React.createElement(Typography2.Title, {
          level: 5,
          className: "getgenie-title"
        }, "CPC"), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-result-item"
        }, /* @__PURE__ */ React.createElement(Typography2.Text, {
          className: "getgenie-text"
        }, analysisData?.searchVolume?.cpc?.currency || "-", " ", analysisData?.searchVolume?.cpc?.value), /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-cpc_icon"
        }))))), data?.[1]?.value ? /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-list-data"
        }, data.map(
          (item, index2) => /* @__PURE__ */ React.createElement("div", {
            key: index2
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-list-data-container"
          }, /* @__PURE__ */ React.createElement(Typography2.Title, {
            level: 5,
            className: "getgenie-list-data-title"
          }, item.title), /* @__PURE__ */ React.createElement(Typography2.Title, {
            level: 5,
            className: "getgenie-list-data-value"
          }, item.value)), index2 !== data.length - 1 && /* @__PURE__ */ React.createElement(Divider2, null))
        )) : "") : /* @__PURE__ */ React.createElement(Typography2.Title, {
          level: 5,
          className: "getgenie-not-found-title"
        }, sidebar4.__("No magic found for this keyword. Maybe try a different one?", "getgenie")));
      }, ["getInputs", "sidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/GoogleTrendChart.js
  var Libs2, useState2, memo, useEffect, GoogleTrendChart, GoogleTrendChart_default;
  var init_GoogleTrendChart = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/GoogleTrendChart.js"() {
      ({ Libs: Libs2 } = window.getGenie.Components.Common);
      ({ useState: useState2, memo, useEffect } = window.React);
      GoogleTrendChart = memo(({ data }) => {
        const [url2, setUrl] = useState2(null);
        const [loading, setLoading] = useState2(true);
        useEffect(() => {
          if (!data) {
            return;
          }
          let keyword = encodeURIComponent(data);
          let modifiedUrl = `https://trends.google.com:443/trends/embed/explore/TIMESERIES?req=%7B%22comparisonItem%22%3A%5B%7B%22keyword%22%3A%22#ENCODED_KEYWORD#%22%2C%22geo%22%3A%22%22%2C%22time%22%3A%22today%2012-m%22%7D%5D%2C%22category%22%3A0%2C%22property%22%3A%22%22%7D&tz=-360&eq=q%3D#DOUBLE_ENCODED_KEYWORD#%26date%3Dtoday%2012-m`;
          modifiedUrl = modifiedUrl.replace("#ENCODED_KEYWORD#", keyword);
          modifiedUrl = modifiedUrl.replace("#DOUBLE_ENCODED_KEYWORD#", encodeURIComponent(keyword));
          setUrl(modifiedUrl);
        }, [data]);
        const onLoad = (e) => {
          e.target.style.display = "block";
          setLoading(false);
        };
        return url2 && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("iframe", {
          onLoad,
          id: "trends-widget-1",
          title: "trends-widget-1",
          src: url2,
          className: "getgenie-chart",
          frameBorder: "0",
          scrolling: "0",
          style: { height: "370px", width: "300px", padding: 0, display: "none" }
        }), loading ? /* @__PURE__ */ React.createElement(Libs2.Loading, null) : "");
      });
      GoogleTrendChart_default = GoogleTrendChart;
    }
  });

  // node_modules/chart.js/dist/chunks/helpers.segment.mjs
  function noop() {
  }
  function isNullOrUndef(value2) {
    return value2 === null || typeof value2 === "undefined";
  }
  function isArray(value2) {
    if (Array.isArray && Array.isArray(value2)) {
      return true;
    }
    const type = Object.prototype.toString.call(value2);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value2) {
    return value2 !== null && Object.prototype.toString.call(value2) === "[object Object]";
  }
  function finiteOrDefault(value2, defaultValue) {
    return isNumberFinite(value2) ? value2 : defaultValue;
  }
  function valueOrDefault(value2, defaultValue) {
    return typeof value2 === "undefined" ? defaultValue : value2;
  }
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each(loopable, fn, thisArg, reverse) {
    let i2, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i2 = len - 1; i2 >= 0; i2--) {
          fn.call(thisArg, loopable[i2], i2);
        }
      } else {
        for (i2 = 0; i2 < len; i2++) {
          fn.call(thisArg, loopable[i2], i2);
        }
      }
    } else if (isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[keys[i2]], keys[i2]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i2, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
      v0 = a0[i2];
      v1 = a1[i2];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone$1(source) {
    if (isArray(source)) {
      return source.map(clone$1);
    }
    if (isObject(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone$1(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone$1(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [source];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    for (let i2 = 0; i2 < ilen; ++i2) {
      source = sources[i2];
      if (!isObject(source)) {
        continue;
      }
      const keys = Object.keys(source);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, source, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, { merger: _mergerIf });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone$1(sval);
    }
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function _splitKey(key) {
    const parts2 = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts2) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value2) {
    const result = [];
    const sqrt = Math.sqrt(value2);
    let i2;
    for (i2 = 1; i2 < sqrt; i2++) {
      if (value2 % i2 === 0) {
        result.push(i2);
        result.push(value2 / i2);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i2, ilen, value2;
    for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
      value2 = array[i2][property];
      if (!isNaN(value2)) {
        target.min = Math.min(target.min, value2);
        target.max = Math.max(target.max, value2);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value2, min, max) {
    return Math.max(min, Math.min(max, value2));
  }
  function _int16Range(value2) {
    return _limitValue(value2, -32768, 32767);
  }
  function _isBetween(value2, start, end, epsilon = 1e-6) {
    return value2 >= Math.min(start, end) - epsilon && value2 <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value2, cmp) {
    cmp = cmp || ((index2) => table[index2] < value2);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return { lo, hi };
  }
  function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
      start++;
    }
    while (end > start && values[end - 1] > max) {
      end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = /* @__PURE__ */ new Set();
    let i2, ilen;
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      set2.add(items[i2]);
    }
    if (set2.size === ilen) {
      return items;
    }
    return Array.from(set2);
  }
  function throttled(fn, thisArg, updateFn) {
    const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
    let ticking = false;
    let args = [];
    return function(...rest) {
      args = updateArgs(rest);
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, args);
        });
      }
    };
  }
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(
          Math.min(
            _lookupByKey(_parsed, iScale.axis, min).lo,
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
          ),
          0,
          pointCount - 1
        );
      }
      if (maxDefined) {
        count = _limitValue(
          Math.max(
            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
          ),
          start,
          pointCount
        ) - start;
      } else {
        count = pointCount - start;
      }
    }
    return { start, count };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  function round(v) {
    return v + 0.5 | 0;
  }
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i2;
    if (w + b > 1) {
      i2 = 1 / (w + b);
      w *= i2;
      b *= i2;
    }
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] *= 1 - w - b;
      rgb[i2] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d, max) {
    if (r === max) {
      return (g - b) / d + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d + 2;
    }
    return (r - g) / d + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = hueValue(r, g, b, d, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i2, j, k, ok, nk;
    for (i2 = 0; i2 < keys.length; i2++) {
      ok = nk = keys[i2];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i2, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  function index_esm(input) {
    return new Color(input);
  }
  function isPatternOrGradient(value2) {
    if (value2 && typeof value2 === "object") {
      const type = value2.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value2) {
    return isPatternOrGradient(value2) ? value2 : index_esm(value2);
  }
  function getHoverColor(value2) {
    return isPatternOrGradient(value2) ? value2 : index_esm(value2).saturate(0.5).darken(0.1).hexString();
  }
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
      const k = keys[i2];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope2, values) {
    if (typeof scope2 === "string") {
      return merge(getScope$1(root, scope2), values);
    }
    return merge(getScope$1(root, ""), scope2);
  }
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache3) {
    cache3 = cache3 || {};
    let data = cache3.data = cache3.data || {};
    let gc = cache3.garbageCollect = cache3.garbageCollect || [];
    if (cache3.font !== font) {
      data = cache3.data = {};
      gc = cache3.garbageCollect = [];
      cache3.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i2, j, jlen, thing, nestedThing;
    for (i2 = 0; i2 < ilen; i2++) {
      thing = arrayOfThings[i2];
      if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i2 = 0; i2 < gcLen; i2++) {
        delete data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio2 = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio2) / devicePixelRatio2 + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + yOffset, y - xOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        break;
      case "star":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        rad += QUARTER_PI;
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(
      flip ? previous.cp1x : previous.cp2x,
      flip ? previous.cp1y : previous.cp2y,
      flip ? target.cp2x : target.cp1x,
      flip ? target.cp2y : target.cp1y,
      target.x,
      target.y
    );
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [text];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i2, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i2 = 0; i2 < lines.length; ++i2) {
      line = lines[i2];
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += font.lineHeight;
    }
    ctx.restore();
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top = y - metrics.actualBoundingBoxAscent;
      const bottom = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  function toLineHeight(value2, size) {
    const matches = ("" + value2).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value2 = +matches[2];
    switch (matches[3]) {
      case "px":
        return value2;
      case "%":
        value2 /= 100;
        break;
    }
    return size * value2;
  }
  function _readValueToProps(value2, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value2) ? objProps ? (prop) => valueOrDefault(value2[prop], value2[props[prop]]) : (prop) => value2[prop] : () => value2;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value2) {
    return _readValueToProps(value2, { top: "y", right: "x", bottom: "y", left: "x" });
  }
  function toTRBLCorners(value2) {
    return _readValueToProps(value2, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
  }
  function toPadding(value2) {
    const obj = toTRBL(value2);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = "";
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context2, index2, info) {
    let cacheable = true;
    let i2, ilen, value2;
    for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
      value2 = inputs[i2];
      if (value2 === void 0) {
        continue;
      }
      if (context2 !== void 0 && typeof value2 === "function") {
        value2 = value2(context2);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value2)) {
        value2 = value2[index2 % value2.length];
        cacheable = false;
      }
      if (value2 !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value2;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value2, add2) => beginAtZero && value2 === 0 ? 0 : value2 + add2;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context2) {
    return Object.assign(Object.create(parentContext), context2);
  }
  function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
    if (!defined(fallback)) {
      fallback = _resolve("_fallback", scopes);
    }
    const cache3 = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: rootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope2) => _createResolver([scope2, ...scopes], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache3, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(
          target,
          prop,
          () => _resolveWithPrefixes(prop, prefixes, scopes, target)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value2) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value2;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context2, subProxy, descriptorDefaults) {
    const cache3 = {
      _cacheable: false,
      _proxy: proxy,
      _context: context2,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope2) => _attachContext(proxy.override(scope2), context2, subProxy, descriptorDefaults)
    };
    return new Proxy(cache3, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(
          target,
          prop,
          () => _resolveWithContext(target, prop, receiver)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value2) {
        proxy[prop] = value2;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults3 = { scriptable: true, indexable: true }) {
    const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value2 = resolve2();
    target[prop] = value2;
    return value2;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value2 = _proxy[prop];
    if (isFunction(value2) && descriptors2.isScriptable(prop)) {
      value2 = _resolveScriptable(prop, value2, target, receiver);
    }
    if (isArray(value2) && value2.length) {
      value2 = _resolveArray(prop, value2, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value2)) {
      value2 = _attachContext(value2, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value2;
  }
  function _resolveScriptable(prop, value2, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    value2 = value2(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value2)) {
      value2 = createSubResolver(_proxy._scopes, _proxy, prop, value2);
    }
    return value2;
  }
  function _resolveArray(prop, value2, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (defined(_context.index) && isIndexable(prop)) {
      value2 = value2[_context.index % value2.length];
    } else if (isObject(value2[0])) {
      const arr = value2;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value2 = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value2.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value2;
  }
  function resolveFallback(fallback, prop, value2) {
    return isFunction(fallback) ? fallback(prop, value2) : fallback;
  }
  function addScopes(set2, parentScopes, key, parentFallback, value2) {
    for (const parent of parentScopes) {
      const scope2 = getScope(key, parent);
      if (scope2) {
        set2.add(scope2);
        const fallback = resolveFallback(scope2._fallback, key, value2);
        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope2 === false && defined(parentFallback) && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value2) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value2);
    const allScopes = [...parentScopes, ...rootScopes];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value2);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value2);
    if (key === null) {
      return false;
    }
    if (defined(fallback) && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value2);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(
      Array.from(set2),
      [""],
      rootScopes,
      fallback,
      () => subGetTarget(resolver, prop, value2)
    );
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value2) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value2)) {
      return value2;
    }
    return target;
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value2;
    for (const prefix2 of prefixes) {
      value2 = _resolve(readKey(prefix2, prop), scopes);
      if (defined(value2)) {
        return needsSubResolver(prop, value2) ? createSubResolver(scopes, proxy, prop, value2) : value2;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope2 of scopes) {
      if (!scope2) {
        continue;
      }
      const value2 = scope2[key];
      if (defined(value2)) {
        return value2;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope2 of scopes) {
      for (const key of Object.keys(scope2).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i2], 0, EPSILON)) {
        mK[i2] = mK[i2 + 1] = 0;
        continue;
      }
      alphaK = mK[i2] / deltaK[i2];
      betaK = mK[i2 + 1] / deltaK[i2];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i2] = alphaK * tauK * deltaK[i2];
      mK[i2 + 1] = betaK * tauK * deltaK[i2];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i2, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
    let i2, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i2];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i2, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev2 = loop ? points[points.length - 1] : points[0];
      for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
        point = points[i2];
        controlPoints = splineCurve(
          prev2,
          point,
          points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen],
          options.tension
        );
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev2 = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
  }
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i2 = 0; i2 < 4; i2++) {
      const pos = positions[i2];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return { x, y, box };
  }
  function getRelativePosition(evt, chart) {
    if ("native" in evt) {
      return evt;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(evt, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = deviceHeight / pixelRatio;
    chart.width = deviceWidth / pixelRatio;
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  function readUsedSize(element, property) {
    const value2 = getStyle(element, property);
    const matches = value2 && value2.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = { x: p1.cp2x, y: p1.cp2y };
    const cp2 = { x: p2.cp1x, y: p2.cp1y };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
  }
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter2 = intlCache.get(cacheKey);
    if (!formatter2) {
      formatter2 = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter2);
    }
    return formatter2;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start, end, count, loop, style }) {
    return {
      start: start % count,
      end: end % count,
      loop: loop && (end - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize: normalize2 } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i2, ilen;
    if (loop) {
      start += count;
      end += count;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        if (!between(normalize2(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end--;
      }
      start %= count;
      end %= count;
    }
    if (end < start) {
      end += count;
    }
    return { start, end, loop, style: segment.style };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [segment];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize: normalize2 } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value2, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value2) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value2) === 0 || between(endBound, prevValue, value2);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i2 = start, prev2 = start; i2 <= end; ++i2) {
      point = points[i2 % count];
      if (point.skip) {
        continue;
      }
      value2 = normalize2(point[property]);
      if (value2 === prevValue) {
        continue;
      }
      inside = between(value2, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value2, startBound) === 0 ? i2 : prev2;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({ start: subStart, end: i2, loop, count, style }));
        subStart = null;
      }
      prev2 = i2;
      prevValue = value2;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const sub = _boundSegment(segments[i2], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end += start;
    }
    while (end > start && points[end % count].skip) {
      end--;
    }
    end %= count;
    return { start, end };
  }
  function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev2 = points[start];
    let end;
    for (end = start + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev2.skip) {
          loop = false;
          result.push({ start: start % count, end: (end - 1) % count, loop });
          start = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev2.skip) {
          start = end;
        }
      }
      prev2 = cur;
    }
    if (last !== null) {
      result.push({ start: start % count, end: last % count, loop });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i2 = start;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({ start: s % count, end: e % count, loop: l, style: st });
        prevStyle = st;
        start = e % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev2 = points[start % count];
      let style;
      for (i2 = start + 1; i2 <= segment.end; i2++) {
        const pt = points[i2 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev2,
          p1: pt,
          p0DataIndex: (i2 - 1) % count,
          p1DataIndex: i2 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i2 - 1, segment.loop, prevStyle);
        }
        prev2 = pt;
        prevStyle = style;
      }
      if (start < i2 - 1) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
  }
  var uid, isNumberFinite, toPercentage, toDimension, keyResolvers, defined, isFunction, setsEqual, PI, TAU, PITAU, INFINITY, RAD_PER_DEG, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, log10, sign, _lookupByKey, _rlookupByKey, arrayEvents, requestAnimFrame, _toLeftRightCenter, _alignStartEnd, _textX, atEdge, elasticIn, elasticOut, effects, lim, map$1, hex, h1, h2, eq, isShort, alpha, HUE_RE, map, names$1, names, RGB_RE, to, from, Color, overrides, descriptors, Defaults, defaults, LINE_HEIGHT, FONT_STYLE, numberOrZero, readKey, needsSubResolver, getScope, EPSILON, getPoint, getValueAxis, getComputedStyle, positions, useOffsetPos, round1, supportsEventListenerOptions, intlCache, getRightToLeftAdapter, getLeftToRightAdapter;
  var init_helpers_segment = __esm({
    "node_modules/chart.js/dist/chunks/helpers.segment.mjs"() {
      uid = function() {
        let id = 0;
        return function() {
          return id++;
        };
      }();
      isNumberFinite = (value2) => (typeof value2 === "number" || value2 instanceof Number) && isFinite(+value2);
      toPercentage = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 : value2 / dimension;
      toDimension = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 * dimension : +value2;
      keyResolvers = {
        "": (v) => v,
        x: (o) => o.x,
        y: (o) => o.y
      };
      defined = (value2) => typeof value2 !== "undefined";
      isFunction = (value2) => typeof value2 === "function";
      setsEqual = (a, b) => {
        if (a.size !== b.size) {
          return false;
        }
        for (const item of a) {
          if (!b.has(item)) {
            return false;
          }
        }
        return true;
      };
      PI = Math.PI;
      TAU = 2 * PI;
      PITAU = TAU + PI;
      INFINITY = Number.POSITIVE_INFINITY;
      RAD_PER_DEG = PI / 180;
      HALF_PI = PI / 2;
      QUARTER_PI = PI / 4;
      TWO_THIRDS_PI = PI * 2 / 3;
      log10 = Math.log10;
      sign = Math.sign;
      _lookupByKey = (table, key, value2, last) => _lookup(table, value2, last ? (index2) => table[index2][key] <= value2 : (index2) => table[index2][key] < value2);
      _rlookupByKey = (table, key, value2) => _lookup(table, value2, (index2) => table[index2][key] >= value2);
      arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
      requestAnimFrame = function() {
        if (typeof window === "undefined") {
          return function(callback2) {
            return callback2();
          };
        }
        return window.requestAnimationFrame;
      }();
      _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
      _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
      _textX = (align, left, right, rtl) => {
        const check = rtl ? "left" : "right";
        return align === check ? right : align === "center" ? (left + right) / 2 : left;
      };
      atEdge = (t) => t === 0 || t === 1;
      elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
      elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
      effects = {
        linear: (t) => t,
        easeInQuad: (t) => t * t,
        easeOutQuad: (t) => -t * (t - 2),
        easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
        easeInCubic: (t) => t * t * t,
        easeOutCubic: (t) => (t -= 1) * t * t + 1,
        easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
        easeInQuart: (t) => t * t * t * t,
        easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
        easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: (t) => t * t * t * t * t,
        easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
        easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
        easeOutSine: (t) => Math.sin(t * HALF_PI),
        easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
        easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
        easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
        easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
        easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
        easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
        easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
        easeInOutElastic(t) {
          const s = 0.1125;
          const p = 0.45;
          return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
        },
        easeInBack(t) {
          const s = 1.70158;
          return t * t * ((s + 1) * t - s);
        },
        easeOutBack(t) {
          const s = 1.70158;
          return (t -= 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack(t) {
          let s = 1.70158;
          if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
          }
          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
        easeOutBounce(t) {
          const m = 7.5625;
          const d = 2.75;
          if (t < 1 / d) {
            return m * t * t;
          }
          if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
          }
          if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
          }
          return m * (t -= 2.625 / d) * t + 0.984375;
        },
        easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
      };
      lim = (v, l, h) => Math.max(Math.min(v, h), l);
      map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
      hex = [..."0123456789ABCDEF"];
      h1 = (b) => hex[b & 15];
      h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
      eq = (b) => (b & 240) >> 4 === (b & 15);
      isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
      alpha = (a, f) => a < 255 ? f(a) : "";
      HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      map = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
      };
      names$1 = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
      };
      RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
      from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
      Color = class {
        constructor(input) {
          if (input instanceof Color) {
            return input;
          }
          const type = typeof input;
          let v;
          if (type === "object") {
            v = fromObject(input);
          } else if (type === "string") {
            v = hexParse(input) || nameParse(input) || functionParse(input);
          }
          this._rgb = v;
          this._valid = !!v;
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var v = clone(this._rgb);
          if (v) {
            v.a = b2n(v.a);
          }
          return v;
        }
        set rgb(obj) {
          this._rgb = fromObject(obj);
        }
        rgbString() {
          return this._valid ? rgbString(this._rgb) : void 0;
        }
        hexString() {
          return this._valid ? hexString(this._rgb) : void 0;
        }
        hslString() {
          return this._valid ? hslString(this._rgb) : void 0;
        }
        mix(color2, weight) {
          if (color2) {
            const c1 = this.rgb;
            const c2 = color2.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight;
            const w = 2 * p - 1;
            const a = c1.a - c2.a;
            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            w2 = 1 - w1;
            c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
            c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
            c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
            c1.a = p * c1.a + (1 - p) * c2.a;
            this.rgb = c1;
          }
          return this;
        }
        interpolate(color2, t) {
          if (color2) {
            this._rgb = interpolate(this._rgb, color2._rgb, t);
          }
          return this;
        }
        clone() {
          return new Color(this.rgb);
        }
        alpha(a) {
          this._rgb.a = n2b(a);
          return this;
        }
        clearer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 - ratio;
          return this;
        }
        greyscale() {
          const rgb = this._rgb;
          const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
          rgb.r = rgb.g = rgb.b = val;
          return this;
        }
        opaquer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 + ratio;
          return this;
        }
        negate() {
          const v = this._rgb;
          v.r = 255 - v.r;
          v.g = 255 - v.g;
          v.b = 255 - v.b;
          return this;
        }
        lighten(ratio) {
          modHSL(this._rgb, 2, ratio);
          return this;
        }
        darken(ratio) {
          modHSL(this._rgb, 2, -ratio);
          return this;
        }
        saturate(ratio) {
          modHSL(this._rgb, 1, ratio);
          return this;
        }
        desaturate(ratio) {
          modHSL(this._rgb, 1, -ratio);
          return this;
        }
        rotate(deg) {
          rotate(this._rgb, deg);
          return this;
        }
      };
      overrides = /* @__PURE__ */ Object.create(null);
      descriptors = /* @__PURE__ */ Object.create(null);
      Defaults = class {
        constructor(_descriptors2) {
          this.animation = void 0;
          this.backgroundColor = "rgba(0,0,0,0.1)";
          this.borderColor = "rgba(0,0,0,0.1)";
          this.color = "#666";
          this.datasets = {};
          this.devicePixelRatio = (context2) => context2.chart.platform.getDevicePixelRatio();
          this.elements = {};
          this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ];
          this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          };
          this.hover = {};
          this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
          this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
          this.hoverColor = (ctx, options) => getHoverColor(options.color);
          this.indexAxis = "x";
          this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = void 0;
          this.scales = {};
          this.showLine = true;
          this.drawActiveElementsOnTop = true;
          this.describe(_descriptors2);
        }
        set(scope2, values) {
          return set(this, scope2, values);
        }
        get(scope2) {
          return getScope$1(this, scope2);
        }
        describe(scope2, values) {
          return set(descriptors, scope2, values);
        }
        override(scope2, values) {
          return set(overrides, scope2, values);
        }
        route(scope2, name, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope2);
          const targetScopeObject = getScope$1(this, targetScope);
          const privateName = "_" + name;
          Object.defineProperties(scopeObject, {
            [privateName]: {
              value: scopeObject[name],
              writable: true
            },
            [name]: {
              enumerable: true,
              get() {
                const local = this[privateName];
                const target = targetScopeObject[targetName];
                if (isObject(local)) {
                  return Object.assign({}, target, local);
                }
                return valueOrDefault(local, target);
              },
              set(value2) {
                this[privateName] = value2;
              }
            }
          });
        }
      };
      defaults = new Defaults({
        _scriptable: (name) => !name.startsWith("on"),
        _indexable: (name) => name !== "events",
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      });
      LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
      numberOrZero = (v) => +v || 0;
      readKey = (prefix2, name) => prefix2 ? prefix2 + _capitalize(name) : name;
      needsSubResolver = (prop, value2) => isObject(value2) && prop !== "adapters" && (Object.getPrototypeOf(value2) === null || value2.constructor === Object);
      getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
      EPSILON = Number.EPSILON || 1e-14;
      getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
      getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
      getComputedStyle = (element) => window.getComputedStyle(element, null);
      positions = ["top", "right", "bottom", "left"];
      useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
      round1 = (v) => Math.round(v * 10) / 10;
      supportsEventListenerOptions = function() {
        let passiveSupported = false;
        try {
          const options = {
            get passive() {
              passiveSupported = true;
              return false;
            }
          };
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        } catch (e) {
        }
        return passiveSupported;
      }();
      intlCache = /* @__PURE__ */ new Map();
      getRightToLeftAdapter = function(rectX, width) {
        return {
          x(x) {
            return rectX + rectX + width - x;
          },
          setWidth(w) {
            width = w;
          },
          textAlign(align) {
            if (align === "center") {
              return align;
            }
            return align === "right" ? "left" : "right";
          },
          xPlus(x, value2) {
            return x - value2;
          },
          leftForLtr(x, itemWidth) {
            return x - itemWidth;
          }
        };
      };
      getLeftToRightAdapter = function() {
        return {
          x(x) {
            return x;
          },
          setWidth(w) {
          },
          textAlign(align) {
            return align;
          },
          xPlus(x, value2) {
            return x + value2;
          },
          leftForLtr(x, _itemWidth) {
            return x;
          }
        };
      };
    }
  });

  // node_modules/chart.js/dist/chart.mjs
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const anim = animations[keys[i2]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value2) {
    let t, r, b, l;
    if (isObject(value2)) {
      t = value2.top;
      r = value2.right;
      b = value2.bottom;
      l = value2.left;
    } else {
      t = r = b = l = value2;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value2 === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      keys.push(metasets[i2].index);
    }
    return keys;
  }
  function applyStack(stack, value2, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i2, ilen, datasetIndex, otherValue;
    if (value2 === null) {
      return;
    }
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      datasetIndex = +keys[i2];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || (value2 === 0 || sign(value2) === sign(otherValue)))) {
        value2 += otherValue;
      }
    }
    return value2;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i2, ilen, key;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      key = keys[i2];
      adata[i2] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value2 = stack[meta.index];
      if (positive && value2 > 0 || !positive && value2 < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i2 = 0; i2 < ilen; ++i2) {
      const item = parsed[i2];
      const { [iAxis]: index2, [vAxis]: value2 } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value2;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(
      parent,
      {
        active: false,
        dataset: void 0,
        datasetIndex: index2,
        index: index2,
        mode: "default",
        type: "dataset"
      }
    );
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
    }
  }
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
        values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i2, ilen, curr, prev2;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev2)) {
        min = Math.min(min, Math.abs(curr - prev2) || min);
      }
      prev2 = curr;
    };
    for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForValue(values[i2]);
      updateMinAndPrev();
    }
    prev2 = void 0;
    for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForTick(i2);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev2 = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev2 === null) {
      prev2 = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev2;
    }
    const start = curr - (curr - Math.min(prev2, next)) / 2 * percent;
    const size = Math.abs(next - prev2) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i2) {
    const startValue = vScale.parse(entry[0], i2);
    const endValue = vScale.parse(entry[1], i2);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i2) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i2);
    } else {
      item[vScale.axis] = vScale.parse(entry, i2);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i2, ilen, item, entry;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      entry = data[i2];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
      parsed.push(parseValue(entry, item, vScale, i2));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end = "top";
    }
    if (reverse) {
      top = "end";
      bottom = "start";
    } else {
      top = "start";
      bottom = "end";
    }
    return { start, end, reverse, top, bottom };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
      return;
    }
    const { start, end, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom;
      } else {
        res[parseEdge(bottom, start, end, reverse)] = true;
        edge = top;
      }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return { ratioX, ratioY, offsetX, offsetY };
  }
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i2, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
        skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
      const factor = factors[i2];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (ticks[i2].major) {
        result.push(i2);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i2;
    spacing = Math.ceil(spacing);
    for (i2 = 0; i2 < ticks.length; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length2, i2, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length2 = majorEnd - majorStart;
      spacing = length2 / Math.floor(length2 / spacing);
    }
    next = start;
    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }
    for (i2 = Math.max(start, 0); i2 < end; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i2, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
      if (arr[i2] - arr[i2 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i2 = 0;
    for (; i2 < len; i2 += increment) {
      result.push(arr[Math.floor(i2)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length2 = scale.ticks.length;
    const validIndex2 = Math.min(index2, length2 - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length2 === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length2) {
    each(caches, (cache3) => {
      const gc = cache3.gc;
      const gcLen = gc.length / 2;
      let i2;
      if (gcLen > length2) {
        for (i2 = 0; i2 < gcLen; ++i2) {
          delete cache3.data[gc[i2]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top, left, bottom, right, chart } = scale;
    const { chartArea, scales } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        titleY = scales[positionAxisID].getPixelForValue(value2) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        titleX = scales[positionAxisID].getPixelForValue(value2) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom, top);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  function registerDefaults(item, scope2, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope2),
      item.defaults
    ]);
    defaults.set(scope2, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope2, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope2, item.descriptors);
    }
  }
  function routeDefaults(scope2, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [scope2].concat(propertyParts).join(".");
      const parts2 = routes[property].split(".");
      const targetName = parts2.pop();
      const targetScope = parts2.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  function binarySearch(metaset, axis, value2, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value2);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start = lookupMethod(data, axis, value2 - range);
          const end = lookupMethod(data, axis, value2 + range);
          return { lo: start.lo, hi: end.hi };
        }
      }
    }
    return { lo: 0, hi: data.length - 1 };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value2 = position[axis];
    for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const { index: index2, data } = metasets[i2];
      const { lo, hi } = binarySearch(metasets[i2], axis, value2, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
      const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [{ element, datasetIndex, index: index2 }];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i2, ilen, box, pos, stack, stackWeight;
    for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
      box = boxes[i2];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i2,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i2, ilen, layout2;
    for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
      layout2 = layouts2[i2];
      const { fullSize } = layout2.box;
      const stack = stacks[layout2.stack];
      const factor = stack && layout2.stackWeight / stack.weight;
      if (layout2.horizontal) {
        layout2.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout2.height = hBoxMaxHeight;
      } else {
        layout2.width = vBoxMaxWidth;
        layout2.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top),
      rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top.concat(bottom).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout2, stacks) {
    const { pos, box } = layout2;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout2.size) {
        chartArea[pos] -= layout2.size;
      }
      const stack = stacks[layout2.stack] || { size: 0, count: 1 };
      stack.size = Math.max(stack.size, layout2.horizontal ? box.height : box.width);
      layout2.size = stack.size / stack.count;
      chartArea[pos] += layout2.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout2.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions3) {
      const margin = { left: 0, top: 0, right: 0, bottom: 0 };
      positions3.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i2, ilen, layout2, box, refit, changed;
    for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
      layout2 = boxes[i2];
      box = layout2.box;
      box.update(
        layout2.width || chartArea.w,
        layout2.height || chartArea.h,
        getMargins(layout2.horizontal, chartArea)
      );
      const { same, other } = updateDims(chartArea, params, layout2, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout2);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout2 of boxes) {
      const box = layout2.box;
      const stack = stacks[layout2.stack] || { count: 1, placed: 0, weight: 1 };
      const weight = layout2.stackWeight / stack.weight || 1;
      if (layout2.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart, (args) => {
      const event = args[0];
      return [event, event.offsetX, event.offsetY];
    });
    addListener(canvas, type, proxy);
    return proxy;
  }
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i2 = 0; i2 < keys.length; i2++) {
      plugins.push(registry.getPlugin(keys[i2]));
    }
    const local = config.plugins || [];
    for (let i2 = 0; i2 < local.length; i2++) {
      const plugin2 = local[i2];
      if (plugins.indexOf(plugin2) === -1) {
        plugins.push(plugin2);
        localIds[plugin2.id] = true;
      }
    }
    return { plugins, localIds };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins, localIds }, options, all) {
    const result = [];
    const context2 = chart.getContext();
    for (const plugin2 of plugins) {
      const id = plugin2.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin: plugin2,
        options: pluginOpts(chart.config, { plugin: plugin2, local: localIds[id] }, opts, context2)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin: plugin2, local }, opts, context2) {
    const keys = config.pluginScopeKeys(plugin2);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin2.defaults) {
      scopes.push(plugin2.defaults);
    }
    return config.createResolver(scopes, context2, [""], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, scaleOptions) {
    if (id === "x" || id === "y") {
      return id;
    }
    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || { scales: {} };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const firstIDs = /* @__PURE__ */ Object.create(null);
    const scales = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      firstIDs[axis] = firstIDs[axis] || id;
      scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
        scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
      });
    });
    Object.keys(scales).forEach((key) => {
      const scale = scales[key];
      mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
    });
    return scales;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  function getResolver(resolverCache, scopes, prefixes) {
    let cache3 = resolverCache.get(scopes);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache3);
    }
    const cacheKey = prefixes.join();
    let cached = cache3.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache3.set(cacheKey, cached);
    }
    return cached;
  }
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value2 = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value2) || hasFunction(value2)) || indexable && isArray(value2)) {
        return true;
      }
    }
    return false;
  }
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions2 && animationOptions2.onComplete, [context2], chart);
  }
  function onAnimationProgress(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    callback(animationOptions2 && animationOptions2.onProgress, [context2], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value2 = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value2;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value2) {
    return _readValueToProps(value2, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y) {
    return {
      x: x + r * Math.cos(theta),
      y: y + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + circumference % TAU;
        if (circumference % TAU === 0) {
          endAngle += TAU;
        }
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawFullCircleBorders(ctx, element, inner) {
    const { x, y, startAngle, pixelMargin, fullCircles } = element;
    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
    const innerRadius = element.innerRadius + pixelMargin;
    let i2;
    if (inner) {
      clipArc(ctx, element, startAngle + TAU);
    }
    ctx.beginPath();
    ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
    for (i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
    for (i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
  }
  function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
    const { options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    if (element.fullCircles) {
      drawFullCircleBorders(ctx, element, inner);
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end < start && !outside ? count + end - start : end - start
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i2, point, prev2;
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[(start + (reverse ? ilen - i2 : i2)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev2, point, reverse, options.stepped);
      }
      prev2 = point;
    }
    if (loop) {
      point = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev2, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i2, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[pointIndex(i2)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start, count);
    } else {
      strokePathDirect(ctx, line, start, count);
    }
  }
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value2 } = el.getProps([axis], useFinalPosition);
    return Math.abs(pos - value2) < options.radius + options.hitRadius;
  }
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base);
      right = Math.max(x, base);
      top = y - half;
      bottom = y + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top = Math.min(y, base);
      bottom = Math.max(y, base);
    }
    return { left, top, right, bottom };
  }
  function skipOrLimit(skip2, value2, min, max) {
    return skip2 ? 0 : _limitValue(value2, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value2 = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value2);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
    const value2 = bar.options.borderRadius;
    const o = toTRBLCorners(value2);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value2);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value: value2 } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value2,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return { width, height };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context2) {
    const override = context2 && context2.dataset && context2.dataset.tooltip && context2.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [{ value: rmin }, { value: rmax }];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(
      _decimalPlaces(spacing),
      _decimalPlaces(niceMin)
    );
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({ value: min });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({ value: max });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({ value: niceMax });
    }
    return ticks;
  }
  function relativeLabelSize(value2, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length2 = 0.75 * minSpacing * ("" + value2).length;
    return Math.min(minSpacing / ratio, length2);
  }
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
    return remain === 1;
  }
  function generateTicks(generationOptions, dataRange) {
    const endExp = Math.floor(log10(dataRange.max));
    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    const ticks = [];
    let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
    let exp = Math.floor(log10(tickVal));
    let significand = Math.floor(tickVal / Math.pow(10, exp));
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
      ticks.push({ value: tickVal, major: isMajor(tickVal) });
      ++significand;
      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }
      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);
    const lastTick = finiteOrDefault(generationOptions.max, tickVal);
    ticks.push({ value: lastTick, major: isMajor(tickVal) });
    return ticks;
  }
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [label];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
      padding[i2] = opts.padding;
      const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
      labelSizes[i2] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(
      orig.l - limits.l,
      limits.r - orig.r,
      orig.t - limits.t,
      limits.b - orig.b
    );
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
      const pointLabelPosition = scale.getPointPosition(i2, outerDistance + extra + padding[i2], additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const size = labelSizes[i2];
      const y = yForAngle(pointLabelPosition.y, size.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
      items.push({
        x: pointLabelPosition.x,
        y,
        textAlign,
        left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
      });
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i2 = labelCount - 1; i2 >= 0; i2--) {
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i2];
      const { backdropColor } = optsAtIndex;
      if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: backdropLeft,
            y: backdropTop,
            w: backdropWidth,
            h: backdropHeight,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
      }
      renderText(
        ctx,
        scale._pointLabels[i2],
        x,
        y + plFont.lineHeight / 2,
        plFont,
        {
          color: optsAtIndex.color,
          textAlign,
          textBaseline: "middle"
        }
      );
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i2 = 1; i2 < labelCount; i2++) {
        pointPosition = scale.getPointPosition(i2, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(gridLineOpts.borderDash);
    ctx.lineDashOffset = gridLineOpts.borderDashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value2 = input;
    if (typeof parser === "function") {
      value2 = parser(value2);
    }
    if (!isNumberFinite(value2)) {
      value2 = typeof parser === "string" ? adapter.parse(value2, parser) : adapter.parse(value2);
    }
    if (value2 === null) {
      return null;
    }
    if (round2) {
      value2 = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value2, "isoWeek", isoWeekday) : adapter.startOf(value2, round2);
    }
    return +value2;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
      const interval2 = INTERVALS[UNITS[i2]];
      const factor = interval2.steps ? interval2.steps : Number.MAX_SAFE_INTEGER;
      if (interval2.common && Math.ceil((max - min) / (factor * interval2.size)) <= capacity) {
        return UNITS[i2];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
      const unit = UNITS[i2];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
      if (INTERVALS[UNITS[i2]].common) {
        return UNITS[i2];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i2, value2;
    for (i2 = 0; i2 < ilen; ++i2) {
      value2 = values[i2];
      map3[value2] = i2;
      ticks.push({
        value: value2,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var Animator, animator, transparent, interpolators, Animation, numbers, colors, animationOptions, Animations, isDirectUpdateMode, cloneIfNotShared, createStack, DatasetController, BarController, BubbleController, DoughnutController, LineController, PolarAreaController, PieController, RadarController, Element, formatters, Ticks, reverseAlign, offsetFromEdge, Scale, TypedRegistry, Registry, registry, ScatterController, DateAdapter, adapters, Interaction, STATIC_POSITIONS, layouts, BasePlatform, BasicPlatform, EXPANDO_KEY, EVENT_TYPES, isNullOrEmpty, eventListenerOptions, drpListeningCharts, oldDevicePixelRatio, DomPlatform, PluginService, keyCache, keysCached, addIfFound, Config, hasFunction, version, KNOWN_POSITIONS, instances, getChart, Chart, invalidatePlugins, enumerable, ArcElement, usePath2D, LineElement, PointElement, BarElement, getBoxSize, itemsEqual, Legend, plugin_legend, Title, plugin_title, positioners, Tooltip2, plugin_tooltip, addIfString, validIndex, CategoryScale, LinearScaleBase, LinearScale, LogarithmicScale, RadialLinearScale, INTERVALS, UNITS, TimeScale, TimeSeriesScale;
  var init_chart = __esm({
    "node_modules/chart.js/dist/chart.mjs"() {
      init_helpers_segment();
      init_helpers_segment();
      Animator = class {
        constructor() {
          this._request = null;
          this._charts = /* @__PURE__ */ new Map();
          this._running = false;
          this._lastDate = void 0;
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach((fn) => fn({
            chart,
            initial: anims.initial,
            numSteps,
            currentStep: Math.min(date - anims.start, numSteps)
          }));
        }
        _refresh() {
          if (this._request) {
            return;
          }
          this._running = true;
          this._request = requestAnimFrame.call(window, () => {
            this._update();
            this._request = null;
            if (this._running) {
              this._refresh();
            }
          });
        }
        _update(date = Date.now()) {
          let remaining = 0;
          this._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i2 = items.length - 1;
            let draw3 = false;
            let item;
            for (; i2 >= 0; --i2) {
              item = items[i2];
              if (item._active) {
                if (item._total > anims.duration) {
                  anims.duration = item._total;
                }
                item.tick(date);
                draw3 = true;
              } else {
                items[i2] = items[items.length - 1];
                items.pop();
              }
            }
            if (draw3) {
              chart.draw();
              this._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
              anims.running = false;
              this._notify(chart, anims, date, "complete");
              anims.initial = false;
            }
            remaining += items.length;
          });
          this._lastDate = date;
          if (remaining === 0) {
            this._running = false;
          }
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
            anims = {
              running: false,
              initial: true,
              items: [],
              listeners: {
                complete: [],
                progress: []
              }
            };
            charts.set(chart, anims);
          }
          return anims;
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          if (!items || !items.length) {
            return;
          }
          this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
            return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
          this._refresh();
        }
        running(chart) {
          if (!this._running) {
            return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
            return false;
          }
          return true;
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i2 = items.length - 1;
          for (; i2 >= 0; --i2) {
            items[i2].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), "complete");
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      };
      animator = new Animator();
      transparent = "transparent";
      interpolators = {
        boolean(from2, to2, factor) {
          return factor > 0.5 ? to2 : from2;
        },
        color(from2, to2, factor) {
          const c0 = color(from2 || transparent);
          const c1 = c0.valid && color(to2 || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
        },
        number(from2, to2, factor) {
          return from2 + (to2 - from2) * factor;
        }
      };
      Animation = class {
        constructor(cfg, target, prop, to2) {
          const currentValue = target[prop];
          to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
          const from2 = resolve([cfg.from, currentValue, to2]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
          this._easing = effects[cfg.easing] || effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from2;
          this._to = to2;
          this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(cfg, to2, date) {
          if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
            this._from = resolve([cfg.from, currentValue, to2]);
          }
        }
        cancel() {
          if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
          }
        }
        tick(date) {
          const elapsed = date - this._start;
          const duration = this._duration;
          const prop = this._prop;
          const from2 = this._from;
          const loop = this._loop;
          const to2 = this._to;
          let factor;
          this._active = from2 !== to2 && (loop || elapsed < duration);
          if (!this._active) {
            this._target[prop] = to2;
            this._notify(true);
            return;
          }
          if (elapsed < 0) {
            this._target[prop] = from2;
            return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = this._easing(Math.min(1, Math.max(0, factor)));
          this._target[prop] = this._fn(from2, to2, factor);
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({ res, rej });
          });
        }
        _notify(resolved) {
          const method = resolved ? "res" : "rej";
          const promises = this._promises || [];
          for (let i2 = 0; i2 < promises.length; i2++) {
            promises[i2][method]();
          }
        }
      };
      numbers = ["x", "y", "borderWidth", "radius", "tension"];
      colors = ["color", "borderColor", "backgroundColor"];
      defaults.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
      });
      animationOptions = Object.keys(defaults.animation);
      defaults.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
      });
      defaults.set("animations", {
        colors: {
          type: "color",
          properties: colors
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults.describe("animations", {
        _fallback: "animation"
      });
      defaults.set("transitions", {
        active: {
          animation: {
            duration: 400
          }
        },
        resize: {
          animation: {
            duration: 0
          }
        },
        show: {
          animations: {
            colors: {
              from: "transparent"
            },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: {
              to: "transparent"
            },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: (v) => v | 0
            }
          }
        }
      });
      Animations = class {
        constructor(chart, config) {
          this._chart = chart;
          this._properties = /* @__PURE__ */ new Map();
          this.configure(config);
        }
        configure(config) {
          if (!isObject(config)) {
            return;
          }
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config).forEach((key) => {
            const cfg = config[key];
            if (!isObject(cfg)) {
              return;
            }
            const resolved = {};
            for (const option of animationOptions) {
              resolved[option] = cfg[option];
            }
            (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
              if (prop === key || !animatedProps.has(prop)) {
                animatedProps.set(prop, resolved);
              }
            });
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options;
          const options = resolveTargetOptions(target, newOptions);
          if (!options) {
            return [];
          }
          const animations = this._createAnimations(options, newOptions);
          if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(() => {
              target.options = newOptions;
            }, () => {
            });
          }
          return animations;
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i2;
          for (i2 = props.length - 1; i2 >= 0; --i2) {
            const prop = props[i2];
            if (prop.charAt(0) === "$") {
              continue;
            }
            if (prop === "options") {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value2 = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value2, date);
                continue;
              } else {
                animation.cancel();
              }
            }
            if (!cfg || !cfg.duration) {
              target[prop] = value2;
              continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value2);
            animations.push(animation);
          }
          return animations;
        }
        update(target, values) {
          if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
            animator.add(this._chart, animations);
            return true;
          }
        }
      };
      isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
      cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
      createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
      DatasetController = class {
        constructor(chart, datasetIndex) {
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = void 0;
          this._parsing = false;
          this._data = void 0;
          this._objectData = void 0;
          this._sharedOptions = void 0;
          this._drawStart = void 0;
          this._drawCount = void 0;
          this.enableOptionSharing = false;
          this.supportsDecimation = false;
          this.$context = void 0;
          this._syncList = [];
          this.initialize();
        }
        initialize() {
          const meta = this._cachedMeta;
          this.configure();
          this.linkScales();
          meta._stacked = isStacked(meta.vScale, meta);
          this.addElements();
        }
        updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
        }
        linkScales() {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
          const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
          const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
          const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
          const indexAxis = meta.indexAxis;
          const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta.xScale = this.getScaleForId(xid);
          meta.yScale = this.getScaleForId(yid);
          meta.rScale = this.getScaleForId(rid);
          meta.iScale = this.getScaleForId(iid);
          meta.vScale = this.getScaleForId(vid);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const meta = this._cachedMeta;
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
          if (meta._stacked) {
            clearStacks(meta);
          }
        }
        _dataCheck() {
          const dataset = this.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = this._data;
          if (isObject(data)) {
            this._data = convertObjectDataToArray(data);
          } else if (_data !== data) {
            if (_data) {
              unlistenArrayEvents(_data, this);
              const meta = this._cachedMeta;
              clearStacks(meta);
              meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
              listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
          }
        }
        addElements() {
          const meta = this._cachedMeta;
          this._dataCheck();
          if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
          }
        }
        buildOrUpdateElements(resetNewElements) {
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          let stackChanged = false;
          this._dataCheck();
          const oldStacked = meta._stacked;
          meta._stacked = isStacked(meta.vScale, meta);
          if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
          }
          this._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
          }
        }
        configure() {
          const config = this.chart.config;
          const scopeKeys = config.datasetScopeKeys(this._type);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
          this.options = config.createResolver(scopes, this.getContext());
          this._parsing = this.options.parsing;
          this._cachedDataOpts = {};
        }
        parse(start, count) {
          const { _cachedMeta: meta, _data: data } = this;
          const { iScale, _stacked } = meta;
          const iAxis = iScale.axis;
          let sorted = start === 0 && count === data.length ? true : meta._sorted;
          let prev2 = start > 0 && meta._parsed[start - 1];
          let i2, cur, parsed;
          if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
          } else {
            if (isArray(data[start])) {
              parsed = this.parseArrayData(meta, data, start, count);
            } else if (isObject(data[start])) {
              parsed = this.parseObjectData(meta, data, start, count);
            } else {
              parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev2 && cur[iAxis] < prev2[iAxis];
            for (i2 = 0; i2 < count; ++i2) {
              meta._parsed[i2 + start] = cur = parsed[i2];
              if (sorted) {
                if (isNotInOrderComparedToPrev()) {
                  sorted = false;
                }
                prev2 = cur;
              }
            }
            meta._sorted = sorted;
          }
          if (_stacked) {
            updateStacks(this, parsed);
          }
        }
        parsePrimitiveData(meta, data, start, count) {
          const { iScale, vScale } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i2, ilen, index2;
          for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index2 = i2 + start;
            parsed[i2] = {
              [iAxis]: singleScale || iScale.parse(labels[index2], index2),
              [vAxis]: vScale.parse(data[index2], index2)
            };
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const { xScale, yScale } = meta;
          const parsed = new Array(count);
          let i2, ilen, index2, item;
          for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index2 = i2 + start;
            item = data[index2];
            parsed[i2] = {
              x: xScale.parse(item[0], index2),
              y: yScale.parse(item[1], index2)
            };
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const { xScale, yScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const parsed = new Array(count);
          let i2, ilen, index2, item;
          for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index2 = i2 + start;
            item = data[index2];
            parsed[i2] = {
              x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
            };
          }
          return parsed;
        }
        getParsed(index2) {
          return this._cachedMeta._parsed[index2];
        }
        getDataElement(index2) {
          return this._cachedMeta.data[index2];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const value2 = parsed[scale.axis];
          const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]
          };
          return applyStack(stack, value2, meta.index, { mode });
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value2 = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
            stack.values = values;
            value2 = applyStack(stack, parsedValue, this._cachedMeta.index);
          }
          range.min = Math.min(range.min, value2);
          range.max = Math.max(range.max, value2);
        }
        getMinMax(scale, canStack) {
          const meta = this._cachedMeta;
          const _parsed = meta._parsed;
          const sorted = meta._sorted && scale === meta.iScale;
          const ilen = _parsed.length;
          const otherScale = this._getOtherScale(scale);
          const stack = createStack(canStack, meta, this.chart);
          const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
          const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
          let i2, parsed;
          function _skip() {
            parsed = _parsed[i2];
            const otherValue = parsed[otherScale.axis];
            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
          }
          for (i2 = 0; i2 < ilen; ++i2) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
              break;
            }
          }
          if (sorted) {
            for (i2 = ilen - 1; i2 >= 0; --i2) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              break;
            }
          }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i2, ilen, value2;
          for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
            value2 = parsed[i2][scale.axis];
            if (isNumberFinite(value2)) {
              values.push(value2);
            }
          }
          return values;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const parsed = this.getParsed(index2);
          return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
          };
        }
        _update(mode) {
          const meta = this._cachedMeta;
          this.update(mode || "default");
          meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
        }
        update(mode) {
        }
        draw() {
          const ctx = this._ctx;
          const chart = this.chart;
          const meta = this._cachedMeta;
          const elements = meta.data || [];
          const area = chart.chartArea;
          const active = [];
          const start = this._drawStart || 0;
          const count = this._drawCount || elements.length - start;
          const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
          let i2;
          if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
          }
          for (i2 = start; i2 < start + count; ++i2) {
            const element = elements[i2];
            if (element.hidden) {
              continue;
            }
            if (element.active && drawActiveElementsOnTop) {
              active.push(element);
            } else {
              element.draw(ctx, area);
            }
          }
          for (i2 = 0; i2 < active.length; ++i2) {
            active[i2].draw(ctx, area);
          }
        }
        getStyle(index2, active) {
          const mode = active ? "active" : "default";
          return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
        }
        getContext(index2, active, mode) {
          const dataset = this.getDataset();
          let context2;
          if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index2];
            context2 = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
            context2.parsed = this.getParsed(index2);
            context2.raw = dataset.data[index2];
            context2.index = context2.dataIndex = index2;
          } else {
            context2 = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context2.dataset = dataset;
            context2.index = context2.datasetIndex = this.index;
          }
          context2.active = !!active;
          context2.mode = mode;
          return context2;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index2, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index2);
        }
        _resolveElementOptions(elementType, mode = "default", index2) {
          const active = mode === "active";
          const cache3 = this._cachedDataOpts;
          const cacheKey = elementType + "-" + mode;
          const cached = cache3[cacheKey];
          const sharing = this.enableOptionSharing && defined(index2);
          if (cached) {
            return cloneIfNotShared(cached, sharing);
          }
          const config = this.chart.config;
          const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
          const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          const names2 = Object.keys(defaults.elements[elementType]);
          const context2 = () => this.getContext(index2, active);
          const values = config.resolveNamedOptions(scopes, names2, context2, prefixes);
          if (values.$shared) {
            values.$shared = sharing;
            cache3[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
        }
        _resolveAnimations(index2, transition, active) {
          const chart = this.chart;
          const cache3 = this._cachedDataOpts;
          const cacheKey = `animation-${transition}`;
          const cached = cache3[cacheKey];
          if (cached) {
            return cached;
          }
          let options;
          if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index2, active, transition));
          }
          const animations = new Animations(chart, options && options.animations);
          if (options && options._cacheable) {
            cache3[cacheKey] = Object.freeze(animations);
          }
          return animations;
        }
        getSharedOptions(options) {
          if (!options.$shared) {
            return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
        }
        includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
        _getSharedOptions(start, mode) {
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const previouslySharedOptions = this._sharedOptions;
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
          return { sharedOptions, includeOptions };
        }
        updateElement(element, index2, properties, mode) {
          if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
          } else {
            this._resolveAnimations(index2, mode).update(element, properties);
          }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
          }
        }
        _setStyle(element, index2, mode, active) {
          element.active = active;
          const options = this.getStyle(index2, active);
          this._resolveAnimations(index2, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
          });
        }
        removeHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", false);
        }
        setHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", true);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", false);
          }
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", true);
          }
        }
        _resyncElements(resetNewElements) {
          const data = this._data;
          const elements = this._cachedMeta.data;
          for (const [method, arg1, arg2] of this._syncList) {
            this[method](arg1, arg2);
          }
          this._syncList = [];
          const numMeta = elements.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (count) {
            this.parse(0, count);
          }
          if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
          }
        }
        _insertElements(start, count, resetNewElements = true) {
          const meta = this._cachedMeta;
          const data = meta.data;
          const end = start + count;
          let i2;
          const move = (arr) => {
            arr.length += count;
            for (i2 = arr.length - 1; i2 >= end; i2--) {
              arr[i2] = arr[i2 - count];
            }
          };
          move(data);
          for (i2 = start; i2 < end; ++i2) {
            data[i2] = new this.dataElementType();
          }
          if (this._parsing) {
            move(meta._parsed);
          }
          this.parse(start, count);
          if (resetNewElements) {
            this.updateElements(data, start, count, "reset");
          }
        }
        updateElements(element, start, count, mode) {
        }
        _removeElements(start, count) {
          const meta = this._cachedMeta;
          if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
              clearStacks(meta, removed);
            }
          }
          meta.data.splice(start, count);
        }
        _sync(args) {
          if (this._parsing) {
            this._syncList.push(args);
          } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
          }
          this.chart._dataChanges.push([this.index, ...args]);
        }
        _onDataPush() {
          const count = arguments.length;
          this._sync(["_insertElements", this.getDataset().data.length - count, count]);
        }
        _onDataPop() {
          this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
        }
        _onDataShift() {
          this._sync(["_removeElements", 0, 1]);
        }
        _onDataSplice(start, count) {
          if (count) {
            this._sync(["_removeElements", start, count]);
          }
          const newCount = arguments.length - 2;
          if (newCount) {
            this._sync(["_insertElements", start, newCount]);
          }
        }
        _onDataUnshift() {
          this._sync(["_insertElements", 0, arguments.length]);
        }
      };
      DatasetController.defaults = {};
      DatasetController.prototype.datasetElementType = null;
      DatasetController.prototype.dataElementType = null;
      BarController = class extends DatasetController {
        parsePrimitiveData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseArrayData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseObjectData(meta, data, start, count) {
          const { iScale, vScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
          const parsed = [];
          let i2, ilen, item, obj;
          for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
            obj = data[i2];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
          }
          return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
          }
        }
        getMaxOverflow() {
          return 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const { iScale, vScale } = meta;
          const parsed = this.getParsed(index2);
          const custom = parsed._custom;
          const value2 = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value: value2
          };
        }
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
          const meta = this._cachedMeta;
          meta.stack = this.getDataset().stack;
        }
        update(mode) {
          const meta = this._cachedMeta;
          this.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start, count, mode) {
          const reset = mode === "reset";
          const { index: index2, _cachedMeta: { vScale } } = this;
          const base = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = this._getRuler();
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          for (let i2 = start; i2 < start + count; i2++) {
            const parsed = this.getParsed(i2);
            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i2);
            const ipixels = this._calculateBarIndexPixels(i2, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
              horizontal,
              base: vpixels.base,
              enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
              x: horizontal ? vpixels.head : ipixels.center,
              y: horizontal ? ipixels.center : vpixels.head,
              height: horizontal ? ipixels.size : Math.abs(vpixels.size),
              width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
            }
            const options = properties.options || bars[i2].options;
            setBorderSkipped(properties, options, stack, index2);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i2], i2, properties, mode);
          }
        }
        _getStacks(last, dataIndex) {
          const { iScale } = this._cachedMeta;
          const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
          const stacked = iScale.options.stacked;
          const stacks = [];
          const skipNull = (meta) => {
            const parsed = meta.controller.getParsed(dataIndex);
            const val = parsed && parsed[meta.vScale.axis];
            if (isNullOrUndef(val) || isNaN(val)) {
              return true;
            }
          };
          for (const meta of metasets) {
            if (dataIndex !== void 0 && skipNull(meta)) {
              continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
              stacks.push(meta.stack);
            }
            if (meta.index === last) {
              break;
            }
          }
          if (!stacks.length) {
            stacks.push(void 0);
          }
          return stacks;
        }
        _getStackCount(index2) {
          return this._getStacks(void 0, index2).length;
        }
        _getStackIndex(datasetIndex, name, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
          return index2 === -1 ? stacks.length - 1 : index2;
        }
        _getRuler() {
          const opts = this.options;
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const pixels = [];
          let i2, ilen;
          for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
            pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(meta);
          return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
        }
        _calculateBarValuePixels(index2) {
          const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
          const actualBase = baseValue || 0;
          const parsed = this.getParsed(index2);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value2 = parsed[vScale.axis];
          let start = 0;
          let length2 = _stacked ? this.applyStack(vScale, parsed, _stacked) : value2;
          let head, size;
          if (length2 !== value2) {
            start = length2 - value2;
            length2 = value2;
          }
          if (floating) {
            value2 = custom.barStart;
            length2 = custom.barEnd - custom.barStart;
            if (value2 !== 0 && sign(value2) !== sign(custom.barEnd)) {
              start = 0;
            }
            start += value2;
          }
          const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
          let base = vScale.getPixelForValue(startValue);
          if (this.chart.getDataVisibility(index2)) {
            head = vScale.getPixelForValue(start + length2);
          } else {
            head = base;
          }
          size = head - base;
          if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value2 === actualBase) {
              base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
          }
          if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
          }
          return {
            size,
            base,
            head,
            center: head + size / 2
          };
        }
        _calculateBarIndexPixels(index2, ruler) {
          const scale = ruler.scale;
          const options = this.options;
          const skipNull = options.skipNull;
          const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
            const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
            center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
          };
        }
        draw() {
          const meta = this._cachedMeta;
          const vScale = meta.vScale;
          const rects = meta.data;
          const ilen = rects.length;
          let i2 = 0;
          for (; i2 < ilen; ++i2) {
            if (this.getParsed(i2)[vScale.axis] !== null) {
              rects[i2].draw(this._ctx);
            }
          }
        }
      };
      BarController.id = "bar";
      BarController.defaults = {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "base", "width", "height"]
          }
        }
      };
      BarController.overrides = {
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: {
              offset: true
            }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      };
      BubbleController = class extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        parsePrimitiveData(meta, data, start, count) {
          const parsed = super.parsePrimitiveData(meta, data, start, count);
          for (let i2 = 0; i2 < parsed.length; i2++) {
            parsed[i2]._custom = this.resolveDataElementOptions(i2 + start).radius;
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const parsed = super.parseArrayData(meta, data, start, count);
          for (let i2 = 0; i2 < parsed.length; i2++) {
            const item = data[start + i2];
            parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start).radius);
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const parsed = super.parseObjectData(meta, data, start, count);
          for (let i2 = 0; i2 < parsed.length; i2++) {
            const item = data[start + i2];
            parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start).radius);
          }
          return parsed;
        }
        getMaxOverflow() {
          const data = this._cachedMeta.data;
          let max = 0;
          for (let i2 = data.length - 1; i2 >= 0; --i2) {
            max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
          }
          return max > 0 && max;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const { xScale, yScale } = meta;
          const parsed = this.getParsed(index2);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
            label: meta.label,
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
          };
        }
        update(mode) {
          const points = this._cachedMeta.data;
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale } = this._cachedMeta;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for (let i2 = start; i2 < start + count; i2++) {
            const point = points[i2];
            const parsed = !reset && this.getParsed(i2);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
              if (reset) {
                properties.options.radius = 0;
              }
            }
            this.updateElement(point, i2, properties, mode);
          }
        }
        resolveDataElementOptions(index2, mode) {
          const parsed = this.getParsed(index2);
          let values = super.resolveDataElementOptions(index2, mode);
          if (values.$shared) {
            values = Object.assign({}, values, { $shared: false });
          }
          const radius = values.radius;
          if (mode !== "active") {
            values.radius = 0;
          }
          values.radius += valueOrDefault(parsed && parsed._custom, radius);
          return values;
        }
      };
      BubbleController.id = "bubble";
      BubbleController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "borderWidth", "radius"]
          }
        }
      };
      BubbleController.overrides = {
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              }
            }
          }
        }
      };
      DoughnutController = class extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.offsetX = void 0;
          this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(start, count) {
          const data = this.getDataset().data;
          const meta = this._cachedMeta;
          if (this._parsing === false) {
            meta._parsed = data;
          } else {
            let getter = (i3) => +data[i3];
            if (isObject(data[start])) {
              const { key = "value" } = this._parsing;
              getter = (i3) => +resolveObjectKey(data[i3], key);
            }
            let i2, ilen;
            for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
              meta._parsed[i2] = getter(i2);
            }
          }
        }
        _getRotation() {
          return toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
          return toRadians(this.options.circumference);
        }
        _getRotationExtents() {
          let min = TAU;
          let max = -TAU;
          for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
            if (this.chart.isDatasetVisible(i2)) {
              const controller = this.chart.getDatasetMeta(i2).controller;
              const rotation = controller._getRotation();
              const circumference = controller._getCircumference();
              min = Math.min(min, rotation);
              max = Math.max(max, rotation + circumference);
            }
          }
          return {
            rotation: min,
            circumference: max - min
          };
        }
        update(mode) {
          const chart = this.chart;
          const { chartArea } = chart;
          const meta = this._cachedMeta;
          const arcs = meta.data;
          const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
          const chartWeight = this._getRingWeight(this.index);
          const { circumference, rotation } = this._getRotationExtents();
          const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = toDimension(this.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
          this.offsetX = offsetX * outerRadius;
          this.offsetY = offsetY * outerRadius;
          meta.total = this.calculateTotal();
          this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
          this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i2, reset) {
          const opts = this.options;
          const meta = this._cachedMeta;
          const circumference = this._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
            return 0;
          }
          return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : this.innerRadius;
          const outerRadius = animateScale ? 0 : this.outerRadius;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          let startAngle = this._getRotation();
          let i2;
          for (i2 = 0; i2 < start; ++i2) {
            startAngle += this._circumference(i2, reset);
          }
          for (i2 = start; i2 < start + count; ++i2) {
            const circumference = this._circumference(i2, reset);
            const arc = arcs[i2];
            const properties = {
              x: centerX + this.offsetX,
              y: centerY + this.offsetY,
              startAngle,
              endAngle: startAngle + circumference,
              circumference,
              outerRadius,
              innerRadius
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i2, properties, mode);
          }
        }
        calculateTotal() {
          const meta = this._cachedMeta;
          const metaData = meta.data;
          let total = 0;
          let i2;
          for (i2 = 0; i2 < metaData.length; i2++) {
            const value2 = meta._parsed[i2];
            if (value2 !== null && !isNaN(value2) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
              total += Math.abs(value2);
            }
          }
          return total;
        }
        calculateCircumference(value2) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value2)) {
            return TAU * (Math.abs(value2) / total);
          }
          return 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value2 = formatNumber(meta._parsed[index2], chart.options.locale);
          return {
            label: labels[index2] || "",
            value: value2
          };
        }
        getMaxBorderWidth(arcs) {
          let max = 0;
          const chart = this.chart;
          let i2, ilen, meta, controller, options;
          if (!arcs) {
            for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
              if (chart.isDatasetVisible(i2)) {
                meta = chart.getDatasetMeta(i2);
                arcs = meta.data;
                controller = meta.controller;
                break;
              }
            }
          }
          if (!arcs) {
            return 0;
          }
          for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
            options = controller.resolveDataElementOptions(i2);
            if (options.borderAlign !== "inner") {
              max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
          }
          return max;
        }
        getMaxOffset(arcs) {
          let max = 0;
          for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
            const options = this.resolveDataElementOptions(i2);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
          }
          return max;
        }
        _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for (let i2 = 0; i2 < datasetIndex; ++i2) {
            if (this.chart.isDatasetVisible(i2)) {
              ringWeightOffset += this._getRingWeight(i2);
            }
          }
          return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
          return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      };
      DoughnutController.id = "doughnut";
      DoughnutController.defaults = {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
      };
      DoughnutController.descriptors = {
        _scriptable: (name) => name !== "spacing",
        _indexable: (name) => name !== "spacing"
      };
      DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle } } = chart.legend.options;
                  return data.labels.map((label, i2) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i2);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i2),
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(tooltipItem) {
                let dataLabel = tooltipItem.label;
                const value2 = ": " + tooltipItem.formattedValue;
                if (isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value2;
                } else {
                  dataLabel += value2;
                }
                return dataLabel;
              }
            }
          }
        }
      };
      LineController = class extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          this.supportsDecimation = true;
          super.initialize();
        }
        update(mode) {
          const meta = this._cachedMeta;
          const { dataset: line, data: points = [], _dataset } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          line._chart = this.chart;
          line._datasetIndex = this.index;
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
            options.borderWidth = 0;
          }
          options.segment = this.options.segment;
          this.updateElement(line, void 0, {
            animated: !animationsDisabled,
            options
          }, mode);
          this.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps, segment } = this.options;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i2 = start; i2 < start + count; ++i2) {
            const point = points[i2];
            const parsed = this.getParsed(i2);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i2];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i2, properties, mode);
            }
            prevParsed = parsed;
          }
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta.data || [];
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
          super.draw();
        }
      };
      LineController.id = "line";
      LineController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      };
      LineController.overrides = {
        scales: {
          _index_: {
            type: "category"
          },
          _value_: {
            type: "linear"
          }
        }
      };
      PolarAreaController = class extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.innerRadius = void 0;
          this.outerRadius = void 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value2 = formatNumber(meta._parsed[index2].r, chart.options.locale);
          return {
            label: labels[index2] || "",
            value: value2
          };
        }
        parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        getMinMax() {
          const meta = this._cachedMeta;
          const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
          meta.data.forEach((element, index2) => {
            const parsed = this.getParsed(index2).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
              if (parsed < range.min) {
                range.min = parsed;
              }
              if (parsed > range.max) {
                range.max = parsed;
              }
            }
          });
          return range;
        }
        _updateRadius() {
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          this.outerRadius = outerRadius - radiusLength * this.index;
          this.innerRadius = this.outerRadius - radiusLength;
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = this._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
          let angle = datasetStartAngle;
          let i2;
          const defaultAngle = 360 / this.countVisibleElements();
          for (i2 = 0; i2 < start; ++i2) {
            angle += this._computeAngle(i2, mode, defaultAngle);
          }
          for (i2 = start; i2 < start + count; i2++) {
            const arc = arcs[i2];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i2) ? scale.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
            angle = endAngle;
            if (reset) {
              if (animationOpts.animateScale) {
                outerRadius = 0;
              }
              if (animationOpts.animateRotate) {
                startAngle = endAngle = datasetStartAngle;
              }
            }
            const properties = {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius,
              startAngle,
              endAngle,
              options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
            };
            this.updateElement(arc, i2, properties, mode);
          }
        }
        countVisibleElements() {
          const meta = this._cachedMeta;
          let count = 0;
          meta.data.forEach((element, index2) => {
            if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
              count++;
            }
          });
          return count;
        }
        _computeAngle(index2, mode, defaultAngle) {
          return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
        }
      };
      PolarAreaController.id = "polarArea";
      PolarAreaController.defaults = {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
          }
        },
        indexAxis: "r",
        startAngle: 0
      };
      PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle } } = chart.legend.options;
                  return data.labels.map((label, i2) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i2);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i2),
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(context2) {
                return context2.chart.data.labels[context2.dataIndex] + ": " + context2.formattedValue;
              }
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            beginAtZero: true,
            grid: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            startAngle: 0
          }
        }
      };
      PieController = class extends DoughnutController {
      };
      PieController.id = "pie";
      PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      };
      RadarController = class extends DatasetController {
        getLabelAndValue(index2) {
          const vScale = this._cachedMeta.vScale;
          const parsed = this.getParsed(index2);
          return {
            label: vScale.getLabels()[index2],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
          };
        }
        parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const meta = this._cachedMeta;
          const line = meta.dataset;
          const points = meta.data || [];
          const labels = meta.iScale.getLabels();
          line.points = points;
          if (mode !== "resize") {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            const properties = {
              _loop: true,
              _fullLoop: labels.length === points.length,
              options
            };
            this.updateElement(line, void 0, properties, mode);
          }
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const scale = this._cachedMeta.rScale;
          const reset = mode === "reset";
          for (let i2 = start; i2 < start + count; i2++) {
            const point = points[i2];
            const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
            const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
              x,
              y,
              angle: pointPosition.angle,
              skip: isNaN(x) || isNaN(y),
              options
            };
            this.updateElement(point, i2, properties, mode);
          }
        }
      };
      RadarController.id = "radar";
      RadarController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
          line: {
            fill: "start"
          }
        }
      };
      RadarController.overrides = {
        aspectRatio: 1,
        scales: {
          r: {
            type: "radialLinear"
          }
        }
      };
      Element = class {
        constructor() {
          this.x = void 0;
          this.y = void 0;
          this.active = false;
          this.options = void 0;
          this.$animations = void 0;
        }
        tooltipPosition(useFinalPosition) {
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return { x, y };
        }
        hasValue() {
          return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
          const anims = this.$animations;
          if (!final || !anims) {
            return this;
          }
          const ret = {};
          props.forEach((prop) => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
          });
          return ret;
        }
      };
      Element.defaults = {};
      Element.defaultRoutes = void 0;
      formatters = {
        values(value2) {
          return isArray(value2) ? value2 : "" + value2;
        },
        numeric(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e15) {
              notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
          Object.assign(options, this.options.ticks.format);
          return formatNumber(tickValue, locale, options);
        },
        logarithmic(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if (remain === 1 || remain === 2 || remain === 5) {
            return formatters.numeric.call(this, tickValue, index2, ticks);
          }
          return "";
        }
      };
      Ticks = { formatters };
      defaults.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options) => options.lineWidth,
          tickColor: (_ctx, options) => options.color,
          offset: false,
          borderDash: [],
          borderDashOffset: 0,
          borderWidth: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults.route("scale.ticks", "color", "", "color");
      defaults.route("scale.grid", "color", "", "borderColor");
      defaults.route("scale.grid", "borderColor", "", "borderColor");
      defaults.route("scale.title", "color", "", "color");
      defaults.describe("scale", {
        _fallback: false,
        _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
        _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
      });
      defaults.describe("scales", {
        _fallback: "scale"
      });
      defaults.describe("scale.ticks", {
        _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
        _indexable: (name) => name !== "backdropPadding"
      });
      reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
      offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
      Scale = class extends Element {
        constructor(cfg) {
          super();
          this.id = cfg.id;
          this.type = cfg.type;
          this.options = void 0;
          this.ctx = cfg.ctx;
          this.chart = cfg.chart;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };
          this.maxWidth = void 0;
          this.maxHeight = void 0;
          this.paddingTop = void 0;
          this.paddingBottom = void 0;
          this.paddingLeft = void 0;
          this.paddingRight = void 0;
          this.axis = void 0;
          this.labelRotation = void 0;
          this.min = void 0;
          this.max = void 0;
          this._range = void 0;
          this.ticks = [];
          this._gridLineItems = null;
          this._labelItems = null;
          this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
          this._startPixel = void 0;
          this._endPixel = void 0;
          this._reversePixels = false;
          this._userMax = void 0;
          this._userMin = void 0;
          this._suggestedMax = void 0;
          this._suggestedMin = void 0;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = void 0;
        }
        init(options) {
          this.options = options.setContext(this.getContext());
          this.axis = options.axis;
          this._userMin = this.parse(options.min);
          this._userMax = this.parse(options.max);
          this._suggestedMin = this.parse(options.suggestedMin);
          this._suggestedMax = this.parse(options.suggestedMax);
        }
        parse(raw, index2) {
          return raw;
        }
        getUserBounds() {
          let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
          _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax)
          };
        }
        getMinMax(canStack) {
          let { min, max, minDefined, maxDefined } = this.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
            return { min, max };
          }
          const metas = this.getMatchingVisibleMetas();
          for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            range = metas[i2].controller.getMinMax(this, canStack);
            if (!minDefined) {
              min = Math.min(min, range.min);
            }
            if (!maxDefined) {
              max = Math.max(max, range.max);
            }
          }
          min = maxDefined && min > max ? max : min;
          max = minDefined && min > max ? min : max;
          return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max))
          };
        }
        getPadding() {
          return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
        beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
        }
        beforeUpdate() {
          callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
          const { beginAtZero, grace, ticks: tickOpts } = this.options;
          const sampleSize = tickOpts.sampleSize;
          this.beforeUpdate();
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          this.ticks = null;
          this._labelSizes = null;
          this._gridLineItems = null;
          this._labelItems = null;
          this.beforeSetDimensions();
          this.setDimensions();
          this.afterSetDimensions();
          this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
          if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = _addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
          }
          this.beforeBuildTicks();
          this.ticks = this.buildTicks() || [];
          this.afterBuildTicks();
          const samplingEnabled = sampleSize < this.ticks.length;
          this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
          this.configure();
          this.beforeCalculateLabelRotation();
          this.calculateLabelRotation();
          this.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
          }
          if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
          }
          this.beforeFit();
          this.fit();
          this.afterFit();
          this.afterUpdate();
        }
        configure() {
          let reversePixels = this.options.reverse;
          let startPixel, endPixel;
          if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
          } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
          }
          this._startPixel = startPixel;
          this._endPixel = endPixel;
          this._reversePixels = reversePixels;
          this._length = endPixel - startPixel;
          this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
          callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
          }
          this.paddingLeft = 0;
          this.paddingTop = 0;
          this.paddingRight = 0;
          this.paddingBottom = 0;
        }
        afterSetDimensions() {
          callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name) {
          this.chart.notifyPlugins(name, this.getContext());
          callback(this.options[name], [this]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
          const tickOpts = this.options.ticks;
          let i2, ilen, tick;
          for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
            tick = ticks[i2];
            tick.label = callback(tickOpts.callback, [tick.value, i2, ticks], this);
          }
        }
        afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const options = this.options;
          const tickOpts = options.ticks;
          const numTicks = this.ticks.length;
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
          }
          const labelSizes = this._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
          tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = toDegrees(Math.min(
              Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
              Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
            ));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          this.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [this]);
        }
        afterAutoSkip() {
        }
        beforeFit() {
          callback(this.options.beforeFit, [this]);
        }
        fit() {
          const minSize = {
            width: 0,
            height: 0
          };
          const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
          const display = this._isVisible();
          const isHorizontal = this.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
              minSize.width = this.maxWidth;
              minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
              minSize.height = this.maxHeight;
              minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
              const { first, last, widest, highest } = this._getLabelSizes();
              const tickPadding = tickOpts.padding * 2;
              const angleRadians = toRadians(this.labelRotation);
              const cos = Math.cos(angleRadians);
              const sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
              } else {
                const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
              }
              this._calculatePadding(first, last, sin, cos);
            }
          }
          this._handleMargins();
          if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
          } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
          }
        }
        _calculatePadding(first, last, sin, cos) {
          const { ticks: { align, padding }, position } = this.options;
          const isRotated = this.labelRotation !== 0;
          const labelsBelowTicks = position !== "top" && this.axis === "x";
          if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
              if (labelsBelowTicks) {
                paddingLeft = cos * first.width;
                paddingRight = sin * last.height;
              } else {
                paddingLeft = sin * first.height;
                paddingRight = cos * last.width;
              }
            } else if (align === "start") {
              paddingRight = last.width;
            } else if (align === "end") {
              paddingLeft = first.width;
            } else if (align !== "inner") {
              paddingLeft = first.width / 2;
              paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
          } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
              paddingTop = 0;
              paddingBottom = first.height;
            } else if (align === "end") {
              paddingTop = last.height;
              paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
          }
        }
        _handleMargins() {
          if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
          }
        }
        afterFit() {
          callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const { axis, position } = this.options;
          return position === "top" || position === "bottom" || axis === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          this.beforeTickToLabelConversion();
          this.generateTickLabels(ticks);
          let i2, ilen;
          for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
            if (isNullOrUndef(ticks[i2].label)) {
              ticks.splice(i2, 1);
              ilen--;
              i2--;
            }
          }
          this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          let labelSizes = this._labelSizes;
          if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
              ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length2) {
          const { ctx, _longestTextCache: caches } = this;
          const widths = [];
          const heights = [];
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i2, j, jlen, label, tickFont, fontString2, cache3, lineHeight, width, height, nestedLabel;
          for (i2 = 0; i2 < length2; ++i2) {
            label = ticks[i2].label;
            tickFont = this._resolveTickFontOptions(i2);
            ctx.font = fontString2 = tickFont.string;
            cache3 = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
              width = _measureText(ctx, cache3.data, cache3.gc, width, label);
              height = lineHeight;
            } else if (isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                  width = _measureText(ctx, cache3.data, cache3.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length2);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
          return {
            first: valueAt(0),
            last: valueAt(length2 - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
          };
        }
        getLabelForValue(value2) {
          return value2;
        }
        getPixelForValue(value2, index2) {
          return NaN;
        }
        getValueForPixel(pixel) {
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getPixelForDecimal(decimal) {
          if (this._reversePixels) {
            decimal = 1 - decimal;
          }
          const pixel = this._startPixel + decimal * this._length;
          return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min, max } = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index2) {
          const ticks = this.ticks || [];
          if (index2 >= 0 && index2 < ticks.length) {
            const tick = ticks[index2];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
          }
          return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
        }
        _tickSize() {
          const optionTicks = this.options.ticks;
          const rot = toRadians(this.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = this._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          if (display !== "auto") {
            return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const axis = this.axis;
          const chart = this.chart;
          const options = this.options;
          const { grid, position } = options;
          const offset = grid.offset;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = grid.setContext(this.getContext());
          const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function(pixel) {
            return _alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i2, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === "top") {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
          } else if (position === "bottom") {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
          } else if (position === "left") {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
          } else if (position === "right") {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
          } else if (axis === "x") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value2 = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
          } else if (axis === "y") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value2 = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
          }
          const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
          const step = Math.max(1, Math.ceil(ticksLength / limit));
          for (i2 = 0; i2 < ticksLength; i2 += step) {
            const optsAtIndex = grid.setContext(this.getContext(i2));
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndex.borderDash || [];
            const borderDashOffset = optsAtIndex.borderDashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i2, offset);
            if (lineValue === void 0) {
              continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
              tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
              ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
              tx1,
              ty1,
              tx2,
              ty2,
              x1,
              y1,
              x2,
              y2,
              width: lineWidth,
              color: lineColor,
              borderDash,
              borderDashOffset,
              tickWidth,
              tickColor,
              tickBorderDash,
              tickBorderDashOffset
            });
          }
          this._ticksLength = ticksLength;
          this._borderValue = borderValue;
          return items;
        }
        _computeLabelItems(chartArea) {
          const axis = this.axis;
          const options = this.options;
          const { position, ticks: optionTicks } = options;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const { align, crossAlign, padding, mirror } = optionTicks;
          const tl = getTickMarkLength(options.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -toRadians(this.labelRotation);
          const items = [];
          let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = "middle";
          if (position === "top") {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "bottom") {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "left") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (position === "right") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (axis === "x") {
            if (position === "center") {
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value2 = position[positionAxisID];
              y = this.chart.scales[positionAxisID].getPixelForValue(value2) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
          } else if (axis === "y") {
            if (position === "center") {
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value2 = position[positionAxisID];
              x = this.chart.scales[positionAxisID].getPixelForValue(value2);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === "y") {
            if (align === "start") {
              textBaseline = "top";
            } else if (align === "end") {
              textBaseline = "bottom";
            }
          }
          const labelSizes = this._getLabelSizes();
          for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
            tick = ticks[i2];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i2));
            pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i2);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color2 = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
              x = pixel;
              if (textAlign === "inner") {
                if (i2 === ilen - 1) {
                  tickTextAlign = !this.options.reverse ? "right" : "left";
                } else if (i2 === 0) {
                  tickTextAlign = !this.options.reverse ? "left" : "right";
                } else {
                  tickTextAlign = "center";
                }
              }
              if (position === "top") {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = -lineCount * lineHeight + lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                } else {
                  textOffset = -labelSizes.highest.height + lineHeight / 2;
                }
              } else {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                } else {
                  textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
              }
              if (mirror) {
                textOffset *= -1;
              }
            } else {
              y = pixel;
              textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
              const labelPadding = toPadding(optsAtIndex.backdropPadding);
              const height = labelSizes.heights[i2];
              const width = labelSizes.widths[i2];
              let top = y + textOffset - labelPadding.top;
              let left = x - labelPadding.left;
              switch (textBaseline) {
                case "middle":
                  top -= height / 2;
                  break;
                case "bottom":
                  top -= height;
                  break;
              }
              switch (textAlign) {
                case "center":
                  left -= width / 2;
                  break;
                case "right":
                  left -= width;
                  break;
              }
              backdrop = {
                left,
                top,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor
              };
            }
            items.push({
              rotation,
              label,
              font,
              color: color2,
              strokeColor,
              strokeWidth,
              textOffset,
              textAlign: tickTextAlign,
              textBaseline,
              translation: [x, y],
              backdrop
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const { position, ticks } = this.options;
          const rotation = -toRadians(this.labelRotation);
          if (rotation) {
            return position === "top" ? "left" : "right";
          }
          let align = "center";
          if (ticks.align === "start") {
            align = "left";
          } else if (ticks.align === "end") {
            align = "right";
          } else if (ticks.align === "inner") {
            align = "inner";
          }
          return align;
        }
        _getYAxisLabelAlignment(tl) {
          const { position, ticks: { crossAlign, mirror, padding } } = this.options;
          const labelSizes = this._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === "left") {
            if (mirror) {
              x = this.right + padding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x += widest;
              }
            } else {
              x = this.right - tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x = this.left;
              }
            }
          } else if (position === "right") {
            if (mirror) {
              x = this.left + padding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x -= widest;
              }
            } else {
              x = this.left + tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x = this.right;
              }
            }
          } else {
            textAlign = "right";
          }
          return { textAlign, x };
        }
        _computeLabelArea() {
          if (this.options.ticks.mirror) {
            return;
          }
          const chart = this.chart;
          const position = this.options.position;
          if (position === "left" || position === "right") {
            return { top: 0, left: this.left, bottom: chart.height, right: this.right };
          }
          if (position === "top" || position === "bottom") {
            return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
          }
        }
        drawBackground() {
          const { ctx, options: { backgroundColor }, left, top, width, height } = this;
          if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
          }
        }
        getLineWidthForValue(value2) {
          const grid = this.options.grid;
          if (!this._isVisible() || !grid.display) {
            return 0;
          }
          const ticks = this.ticks;
          const index2 = ticks.findIndex((t) => t.value === value2);
          if (index2 >= 0) {
            const opts = grid.setContext(this.getContext(index2));
            return opts.lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const grid = this.options.grid;
          const ctx = this.ctx;
          const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
          let i2, ilen;
          const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
              return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
          };
          if (grid.display) {
            for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
              const item = items[i2];
              if (grid.drawOnChartArea) {
                drawLine(
                  { x: item.x1, y: item.y1 },
                  { x: item.x2, y: item.y2 },
                  item
                );
              }
              if (grid.drawTicks) {
                drawLine(
                  { x: item.tx1, y: item.ty1 },
                  { x: item.tx2, y: item.ty2 },
                  {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  }
                );
              }
            }
          }
        }
        drawBorder() {
          const { chart, ctx, options: { grid } } = this;
          const borderOpts = grid.setContext(this.getContext());
          const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
          if (!axisWidth) {
            return;
          }
          const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
          const borderValue = this._borderValue;
          let x1, x2, y1, y2;
          if (this.isHorizontal()) {
            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.borderWidth;
          ctx.strokeStyle = borderOpts.borderColor;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
        }
        drawLabels(chartArea) {
          const optionTicks = this.options.ticks;
          if (!optionTicks.display) {
            return;
          }
          const ctx = this.ctx;
          const area = this._computeLabelArea();
          if (area) {
            clipArea(ctx, area);
          }
          const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
          let i2, ilen;
          for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            const item = items[i2];
            const tickFont = item.font;
            const label = item.label;
            if (item.backdrop) {
              ctx.fillStyle = item.backdrop.color;
              ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
            }
            let y = item.textOffset;
            renderText(ctx, label, 0, y, tickFont, item);
          }
          if (area) {
            unclipArea(ctx);
          }
        }
        drawTitle() {
          const { ctx, options: { position, title, reverse } } = this;
          if (!title.display) {
            return;
          }
          const font = toFont(title.font);
          const padding = toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === "bottom" || position === "center" || isObject(position)) {
            offset += padding.bottom;
            if (isArray(title.text)) {
              offset += font.lineHeight * (title.text.length - 1);
            }
          } else {
            offset += padding.top;
          }
          const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
        draw(chartArea) {
          if (!this._isVisible()) {
            return;
          }
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawBorder();
          this.drawTitle();
          this.drawLabels(chartArea);
        }
        _layers() {
          const opts = this.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
          if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [{
              z: tz,
              draw: (chartArea) => {
                this.draw(chartArea);
              }
            }];
          }
          return [{
            z: gz,
            draw: (chartArea) => {
              this.drawBackground();
              this.drawGrid(chartArea);
              this.drawTitle();
            }
          }, {
            z: gz + 1,
            draw: () => {
              this.drawBorder();
            }
          }, {
            z: tz,
            draw: (chartArea) => {
              this.drawLabels(chartArea);
            }
          }];
        }
        getMatchingVisibleMetas(type) {
          const metas = this.chart.getSortedVisibleDatasetMetas();
          const axisID = this.axis + "AxisID";
          const result = [];
          let i2, ilen;
          for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            const meta = metas[i2];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
              result.push(meta);
            }
          }
          return result;
        }
        _resolveTickFontOptions(index2) {
          const opts = this.options.ticks.setContext(this.getContext(index2));
          return toFont(opts.font);
        }
        _maxDigits() {
          const fontSize = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
      };
      TypedRegistry = class {
        constructor(type, scope2, override) {
          this.type = type;
          this.scope = scope2;
          this.override = override;
          this.items = /* @__PURE__ */ Object.create(null);
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
        register(item) {
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
          }
          const items = this.items;
          const id = item.id;
          const scope2 = this.scope + "." + id;
          if (!id) {
            throw new Error("class does not have id: " + item);
          }
          if (id in items) {
            return scope2;
          }
          items[id] = item;
          registerDefaults(item, scope2, parentScope);
          if (this.override) {
            defaults.override(item.id, item.overrides);
          }
          return scope2;
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope2 = this.scope;
          if (id in items) {
            delete items[id];
          }
          if (scope2 && id in defaults[scope2]) {
            delete defaults[scope2][id];
            if (this.override) {
              delete overrides[id];
            }
          }
        }
      };
      Registry = class {
        constructor() {
          this.controllers = new TypedRegistry(DatasetController, "datasets", true);
          this.elements = new TypedRegistry(Element, "elements");
          this.plugins = new TypedRegistry(Object, "plugins");
          this.scales = new TypedRegistry(Scale, "scales");
          this._typedRegistries = [this.controllers, this.scales, this.elements];
        }
        add(...args) {
          this._each("register", args);
        }
        remove(...args) {
          this._each("unregister", args);
        }
        addControllers(...args) {
          this._each("register", args, this.controllers);
        }
        addElements(...args) {
          this._each("register", args, this.elements);
        }
        addPlugins(...args) {
          this._each("register", args, this.plugins);
        }
        addScales(...args) {
          this._each("register", args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, "controller");
        }
        getElement(id) {
          return this._get(id, this.elements, "element");
        }
        getPlugin(id) {
          return this._get(id, this.plugins, "plugin");
        }
        getScale(id) {
          return this._get(id, this.scales, "scale");
        }
        removeControllers(...args) {
          this._each("unregister", args, this.controllers);
        }
        removeElements(...args) {
          this._each("unregister", args, this.elements);
        }
        removePlugins(...args) {
          this._each("unregister", args, this.plugins);
        }
        removeScales(...args) {
          this._each("unregister", args, this.scales);
        }
        _each(method, args, typedRegistry) {
          [...args].forEach((arg) => {
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
              this._exec(method, reg, arg);
            } else {
              each(arg, (item) => {
                const itemReg = typedRegistry || this._getRegistryForType(item);
                this._exec(method, itemReg, item);
              });
            }
          });
        }
        _exec(method, registry2, component) {
          const camelMethod = _capitalize(method);
          callback(component["before" + camelMethod], [], component);
          registry2[method](component);
          callback(component["after" + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
            const reg = this._typedRegistries[i2];
            if (reg.isForType(type)) {
              return reg;
            }
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === void 0) {
            throw new Error('"' + id + '" is not a registered ' + type + ".");
          }
          return item;
        }
      };
      registry = new Registry();
      ScatterController = class extends DatasetController {
        update(mode) {
          const meta = this._cachedMeta;
          const { data: points = [] } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          if (this.options.showLine) {
            const { dataset: line, _dataset } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
          }
          this.updateElements(points, start, count, mode);
        }
        addElements() {
          const { showLine } = this.options;
          if (!this.datasetElementType && showLine) {
            this.datasetElementType = registry.getElement("line");
          }
          super.addElements();
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps, segment } = this.options;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i2 = start; i2 < start + count; ++i2) {
            const point = points[i2];
            const parsed = this.getParsed(i2);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i2];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i2, properties, mode);
            }
            prevParsed = parsed;
          }
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const data = meta.data || [];
          if (!this.options.showLine) {
            let max = 0;
            for (let i2 = data.length - 1; i2 >= 0; --i2) {
              max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
            }
            return max > 0 && max;
          }
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
      };
      ScatterController.id = "scatter";
      ScatterController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        showLine: false,
        fill: false
      };
      ScatterController.overrides = {
        interaction: {
          mode: "point"
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(item) {
                return "(" + item.label + ", " + item.formattedValue + ")";
              }
            }
          }
        },
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      };
      DateAdapter = class {
        constructor(options) {
          this.options = options || {};
        }
        init(chartOptions) {
        }
        formats() {
          return abstract();
        }
        parse(value2, format) {
          return abstract();
        }
        format(timestamp, format) {
          return abstract();
        }
        add(timestamp, amount, unit) {
          return abstract();
        }
        diff(a, b, unit) {
          return abstract();
        }
        startOf(timestamp, unit, weekday) {
          return abstract();
        }
        endOf(timestamp, unit) {
          return abstract();
        }
      };
      DateAdapter.override = function(members) {
        Object.assign(DateAdapter.prototype, members);
      };
      adapters = {
        _date: DateAdapter
      };
      Interaction = {
        evaluateInteractionItems,
        modes: {
          index(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "x";
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
              return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta) => {
              const index2 = items[0].index;
              const element = meta.data[index2];
              if (element && !element.skip) {
                elements.push({ element, datasetIndex: meta.index, index: index2 });
              }
            });
            return elements;
          },
          dataset(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex;
              const data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i2 = 0; i2 < data.length; ++i2) {
                items.push({ element: data[i2], datasetIndex, index: i2 });
              }
            }
            return items;
          },
          point(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
          },
          nearest(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
          },
          x(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
          },
          y(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
          }
        }
      };
      STATIC_POSITIONS = ["left", "top", "right", "bottom"];
      defaults.set("layout", {
        autoPadding: true,
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
      layouts = {
        addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || "top";
          item.weight = item.weight || 0;
          item._layers = item._layers || function() {
            return [{
              z: 0,
              draw(chartArea) {
                item.draw(chartArea);
              }
            }];
          };
          chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index2 !== -1) {
            chart.boxes.splice(index2, 1);
          }
        },
        configure(chart, item, options) {
          item.fullSize = options.fullSize;
          item.position = options.position;
          item.weight = options.weight;
        },
        update(chart, width, height, minPadding) {
          if (!chart) {
            return;
          }
          const padding = toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          each(chart.boxes, (box) => {
            if (typeof box.beforeLayout === "function") {
              box.beforeLayout();
            }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
          }, padding);
          const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params, stacks);
          fitBoxes(verticalBoxes, chartArea, params, stacks);
          if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
          chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
          };
          each(boxes.chartArea, (layout2) => {
            const box = layout2.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
          });
        }
      };
      BasePlatform = class {
        acquireContext(canvas, aspectRatio) {
        }
        releaseContext(context2) {
          return false;
        }
        addEventListener(chart, type, listener) {
        }
        removeEventListener(chart, type, listener) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
        }
        isAttached(canvas) {
          return true;
        }
        updateConfig(config) {
        }
      };
      BasicPlatform = class extends BasePlatform {
        acquireContext(item) {
          return item && item.getContext && item.getContext("2d") || null;
        }
        updateConfig(config) {
          config.options.animation = false;
        }
      };
      EXPANDO_KEY = "$chartjs";
      EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      };
      isNullOrEmpty = (value2) => value2 === null || value2 === "";
      eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
      drpListeningCharts = /* @__PURE__ */ new Map();
      oldDevicePixelRatio = 0;
      DomPlatform = class extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context2 = canvas && canvas.getContext && canvas.getContext("2d");
          if (context2 && context2.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context2;
          }
          return null;
        }
        releaseContext(context2) {
          const canvas = context2.canvas;
          if (!canvas[EXPANDO_KEY]) {
            return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          ["height", "width"].forEach((prop) => {
            const value2 = initial[prop];
            if (isNullOrUndef(value2)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value2);
            }
          });
          const style = initial.style || {};
          Object.keys(style).forEach((key) => {
            canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
          };
          const handler = handlers[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
            return;
          }
          const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
          };
          const handler = handlers[type] || removeListener;
          handler(chart, type, proxy);
          proxies[type] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = _getParentNode(canvas);
          return !!(container && container.isConnected);
        }
      };
      PluginService = class {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter) {
          if (hook === "beforeInit") {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, "install");
          }
          const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
          const result = this._notify(descriptors2, chart, hook, args);
          if (hook === "afterDestroy") {
            this._notify(descriptors2, chart, "stop");
            this._notify(this._init, chart, "uninstall");
          }
          return result;
        }
        _notify(descriptors2, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors2) {
            const plugin2 = descriptor.plugin;
            const method = plugin2[hook];
            const params = [chart, args, descriptor.options];
            if (callback(method, params, plugin2) === false && args.cancelable) {
              return false;
            }
          }
          return true;
        }
        invalidate() {
          if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = void 0;
          }
        }
        _descriptors(chart) {
          if (this._cache) {
            return this._cache;
          }
          const descriptors2 = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors2;
        }
        _createDescriptors(chart, all) {
          const config = chart && chart.config;
          const options = valueOrDefault(config.options && config.options.plugins, {});
          const plugins = allPlugins(config);
          return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors2 = this._cache;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
          this._notify(diff(descriptors2, previousDescriptors), chart, "start");
        }
      };
      keyCache = /* @__PURE__ */ new Map();
      keysCached = /* @__PURE__ */ new Set();
      addIfFound = (set2, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        if (opts !== void 0) {
          set2.add(opts);
        }
      };
      Config = class {
        constructor(config) {
          this._config = initConfig(config);
          this._scopeCache = /* @__PURE__ */ new Map();
          this._resolverCache = /* @__PURE__ */ new Map();
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options) {
          this._config.options = options;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config = this._config;
          this.clearCache();
          initOptions(config);
        }
        clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(
            datasetType,
            () => [[
              `datasets.${datasetType}`,
              ""
            ]]
          );
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(
            `${datasetType}.transition.${transition}`,
            () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]
          );
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(
            `${datasetType}-${elementType}`,
            () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]
          );
        }
        pluginScopeKeys(plugin2) {
          const id = plugin2.id;
          const type = this.type;
          return cachedKeys(
            `${type}-plugin-${id}`,
            () => [[
              `plugins.${id}`,
              ...plugin2.additionalOptionScopes || []
            ]]
          );
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache3 = _scopeCache.get(mainScope);
          if (!cache3 || resetCache) {
            cache3 = /* @__PURE__ */ new Map();
            _scopeCache.set(mainScope, cache3);
          }
          return cache3;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const { options, type } = this;
          const cache3 = this._cachedScopes(mainScope, resetCache);
          const cached = cache3.get(keyLists);
          if (cached) {
            return cached;
          }
          const scopes = /* @__PURE__ */ new Set();
          keyLists.forEach((keys) => {
            if (mainScope) {
              scopes.add(mainScope);
              keys.forEach((key) => addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key) => addIfFound(scopes, options, key));
            keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach((key) => addIfFound(scopes, defaults, key));
            keys.forEach((key) => addIfFound(scopes, descriptors, key));
          });
          const array = Array.from(scopes);
          if (array.length === 0) {
            array.push(/* @__PURE__ */ Object.create(null));
          }
          if (keysCached.has(keyLists)) {
            cache3.set(keyLists, array);
          }
          return array;
        }
        chartOptionScopes() {
          const { options, type } = this;
          return [
            options,
            overrides[type] || {},
            defaults.datasets[type] || {},
            { type },
            defaults,
            descriptors
          ];
        }
        resolveNamedOptions(scopes, names2, context2, prefixes = [""]) {
          const result = { $shared: true };
          const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
          let options = resolver;
          if (needContext(resolver, names2)) {
            result.$shared = false;
            context2 = isFunction(context2) ? context2() : context2;
            const subResolver = this.createResolver(scopes, context2, subPrefixes);
            options = _attachContext(resolver, context2, subResolver);
          }
          for (const prop of names2) {
            result[prop] = options[prop];
          }
          return result;
        }
        createResolver(scopes, context2, prefixes = [""], descriptorDefaults) {
          const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
          return isObject(context2) ? _attachContext(resolver, context2, void 0, descriptorDefaults) : resolver;
        }
      };
      hasFunction = (value2) => isObject(value2) && Object.getOwnPropertyNames(value2).reduce((acc, key) => acc || isFunction(value2[key]), false);
      version = "3.9.1";
      KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
      instances = {};
      getChart = (key) => {
        const canvas = getCanvas(key);
        return Object.values(instances).filter((c) => c.canvas === canvas).pop();
      };
      Chart = class {
        constructor(item, userConfig) {
          const config = this.config = new Config(userConfig);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
            throw new Error(
              "Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused."
            );
          }
          const options = config.createResolver(config.chartOptionScopes(), this.getContext());
          this.platform = new (config.platform || _detectPlatform(initialCanvas))();
          this.platform.updateConfig(config);
          const context2 = this.platform.acquireContext(initialCanvas, options.aspectRatio);
          const canvas = context2 && context2.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = uid();
          this.ctx = context2;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = void 0;
          this.boxes = [];
          this.currentDevicePixelRatio = void 0;
          this.chartArea = void 0;
          this._active = [];
          this._lastEvent = void 0;
          this._listeners = {};
          this._responsiveListeners = void 0;
          this._sortedMetasets = [];
          this.scales = {};
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = void 0;
          this.$context = void 0;
          this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
          this._dataChanges = [];
          instances[this.id] = this;
          if (!context2 || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          animator.listen(this, "complete", onAnimationsComplete);
          animator.listen(this, "progress", onAnimationProgress);
          this._initialize();
          if (this.attached) {
            this.update();
          }
        }
        get aspectRatio() {
          const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
          if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
          }
          return height ? width / height : null;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options) {
          this.config.options = options;
        }
        _initialize() {
          this.notifyPlugins("beforeInit");
          if (this.options.responsive) {
            this.resize();
          } else {
            retinaScale(this, this.options.devicePixelRatio);
          }
          this.bindEvents();
          this.notifyPlugins("afterInit");
          return this;
        }
        clear() {
          clearCanvas(this.canvas, this.ctx);
          return this;
        }
        stop() {
          animator.stop(this);
          return this;
        }
        resize(width, height) {
          if (!animator.running(this)) {
            this._resize(width, height);
          } else {
            this._resizeBeforeDraw = { width, height };
          }
        }
        _resize(width, height) {
          const options = this.options;
          const canvas = this.canvas;
          const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
          const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
          const mode = this.width ? "resize" : "attach";
          this.width = newSize.width;
          this.height = newSize.height;
          this._aspectRatio = this.aspectRatio;
          if (!retinaScale(this, newRatio, true)) {
            return;
          }
          this.notifyPlugins("resize", { size: newSize });
          callback(options.onResize, [this, newSize], this);
          if (this.attached) {
            if (this._doResize(mode)) {
              this.render();
            }
          }
        }
        ensureScalesHaveIDs() {
          const options = this.options;
          const scalesOptions = options.scales || {};
          each(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const options = this.options;
          const scaleOpts = options.scales;
          const scales = this.scales;
          const updated = Object.keys(scales).reduce((obj, id) => {
            obj[id] = false;
            return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
            items = items.concat(
              Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              })
            );
          }
          each(items, (item) => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
              scale = scales[id];
            } else {
              const scaleClass = registry.getScale(scaleType);
              scale = new scaleClass({
                id,
                type: scaleType,
                ctx: this.ctx,
                chart: this
              });
              scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
          });
          each(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
              delete scales[id];
            }
          });
          each(scales, (scale) => {
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
          });
        }
        _updateMetasets() {
          const metasets = this._metasets;
          const numData = this.data.datasets.length;
          const numMeta = metasets.length;
          metasets.sort((a, b) => a.index - b.index);
          if (numMeta > numData) {
            for (let i2 = numData; i2 < numMeta; ++i2) {
              this._destroyDatasetMeta(i2);
            }
            metasets.splice(numData, numMeta - numData);
          }
          this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const { _metasets: metasets, data: { datasets } } = this;
          if (metasets.length > datasets.length) {
            delete this._stacks;
          }
          metasets.forEach((meta, index2) => {
            if (datasets.filter((x) => x === meta._dataset).length === 0) {
              this._destroyDatasetMeta(index2);
            }
          });
        }
        buildOrUpdateControllers() {
          const newControllers = [];
          const datasets = this.data.datasets;
          let i2, ilen;
          this._removeUnreferencedMetasets();
          for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
            const dataset = datasets[i2];
            let meta = this.getDatasetMeta(i2);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
              this._destroyDatasetMeta(i2);
              meta = this.getDatasetMeta(i2);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i2;
            meta.label = "" + dataset.label;
            meta.visible = this.isDatasetVisible(i2);
            if (meta.controller) {
              meta.controller.updateIndex(i2);
              meta.controller.linkScales();
            } else {
              const ControllerClass = registry.getController(type);
              const { datasetElementType, dataElementType } = defaults.datasets[type];
              Object.assign(ControllerClass.prototype, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType: datasetElementType && registry.getElement(datasetElementType)
              });
              meta.controller = new ControllerClass(this, i2);
              newControllers.push(meta.controller);
            }
          }
          this._updateMetasets();
          return newControllers;
        }
        _resetElements() {
          each(this.data.datasets, (dataset, datasetIndex) => {
            this.getDatasetMeta(datasetIndex).controller.reset();
          }, this);
        }
        reset() {
          this._resetElements();
          this.notifyPlugins("reset");
        }
        update(mode) {
          const config = this.config;
          config.update();
          const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
          const animsDisabled = this._animationsDisabled = !options.animation;
          this._updateScales();
          this._checkEventBindings();
          this._updateHiddenIndices();
          this._plugins.invalidate();
          if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
            return;
          }
          const newControllers = this.buildOrUpdateControllers();
          this.notifyPlugins("beforeElementsUpdate");
          let minPadding = 0;
          for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
            const { controller } = this.getDatasetMeta(i2);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
          this._updateLayout(minPadding);
          if (!animsDisabled) {
            each(newControllers, (controller) => {
              controller.reset();
            });
          }
          this._updateDatasets(mode);
          this.notifyPlugins("afterUpdate", { mode });
          this._layers.sort(compare2Level("z", "_idx"));
          const { _active, _lastEvent } = this;
          if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
          } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
          }
          this.render();
        }
        _updateScales() {
          each(this.scales, (scale) => {
            layouts.removeBox(this, scale);
          });
          this.ensureScalesHaveIDs();
          this.buildOrUpdateScales();
        }
        _checkEventBindings() {
          const options = this.options;
          const existingEvents = new Set(Object.keys(this._listeners));
          const newEvents = new Set(options.events);
          if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
          }
        }
        _updateHiddenIndices() {
          const { _hiddenIndices } = this;
          const changes = this._getUniformDataChanges() || [];
          for (const { method, start, count } of changes) {
            const move = method === "_removeElements" ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
          }
        }
        _getUniformDataChanges() {
          const _dataChanges = this._dataChanges;
          if (!_dataChanges || !_dataChanges.length) {
            return;
          }
          this._dataChanges = [];
          const datasetCount = this.data.datasets.length;
          const makeSet = (idx) => new Set(
            _dataChanges.filter((c) => c[0] === idx).map((c, i2) => i2 + "," + c.splice(1).join(","))
          );
          const changeSet = makeSet(0);
          for (let i2 = 1; i2 < datasetCount; i2++) {
            if (!setsEqual(changeSet, makeSet(i2))) {
              return;
            }
          }
          return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
        }
        _updateLayout(minPadding) {
          if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
            return;
          }
          layouts.update(this, this.width, this.height, minPadding);
          const area = this.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          this._layers = [];
          each(this.boxes, (box) => {
            if (noArea && box.position === "chartArea") {
              return;
            }
            if (box.configure) {
              box.configure();
            }
            this._layers.push(...box._layers());
          }, this);
          this._layers.forEach((item, index2) => {
            item._idx = index2;
          });
          this.notifyPlugins("afterLayout");
        }
        _updateDatasets(mode) {
          if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
            return;
          }
          for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this.getDatasetMeta(i2).controller.configure();
          }
          for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this._updateDataset(i2, isFunction(mode) ? mode({ datasetIndex: i2 }) : mode);
          }
          this.notifyPlugins("afterDatasetsUpdate", { mode });
        }
        _updateDataset(index2, mode) {
          const meta = this.getDatasetMeta(index2);
          const args = { meta, index: index2, mode, cancelable: true };
          if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
          }
          meta.controller._update(mode);
          args.cancelable = false;
          this.notifyPlugins("afterDatasetUpdate", args);
        }
        render() {
          if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
            return;
          }
          if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
              animator.start(this);
            }
          } else {
            this.draw();
            onAnimationsComplete({ chart: this });
          }
        }
        draw() {
          let i2;
          if (this._resizeBeforeDraw) {
            const { width, height } = this._resizeBeforeDraw;
            this._resize(width, height);
            this._resizeBeforeDraw = null;
          }
          this.clear();
          if (this.width <= 0 || this.height <= 0) {
            return;
          }
          if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
            return;
          }
          const layers = this._layers;
          for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
            layers[i2].draw(this.chartArea);
          }
          this._drawDatasets();
          for (; i2 < layers.length; ++i2) {
            layers[i2].draw(this.chartArea);
          }
          this.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(filterVisible) {
          const metasets = this._sortedMetasets;
          const result = [];
          let i2, ilen;
          for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
            const meta = metasets[i2];
            if (!filterVisible || meta.visible) {
              result.push(meta);
            }
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
            return;
          }
          const metasets = this.getSortedVisibleDatasetMetas();
          for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
            this._drawDataset(metasets[i2]);
          }
          this.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(meta) {
          const ctx = this.ctx;
          const clip = meta._clip;
          const useClip = !clip.disabled;
          const area = this.chartArea;
          const args = {
            meta,
            index: meta.index,
            cancelable: true
          };
          if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
          }
          if (useClip) {
            clipArea(ctx, {
              left: clip.left === false ? 0 : area.left - clip.left,
              right: clip.right === false ? this.width : area.right + clip.right,
              top: clip.top === false ? 0 : area.top - clip.top,
              bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
            });
          }
          meta.controller.draw();
          if (useClip) {
            unclipArea(ctx);
          }
          args.cancelable = false;
          this.notifyPlugins("afterDatasetDraw", args);
        }
        isPointInArea(point) {
          return _isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === "function") {
            return method(this, e, options, useFinalPosition);
          }
          return [];
        }
        getDatasetMeta(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          const metasets = this._metasets;
          let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
          if (!meta) {
            meta = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: dataset && dataset.order || 0,
              index: datasetIndex,
              _dataset: dataset,
              _parsed: [],
              _sorted: false
            };
            metasets.push(meta);
          }
          return meta;
        }
        getContext() {
          return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
            return false;
          }
          const meta = this.getDatasetMeta(datasetIndex);
          return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          const meta = this.getDatasetMeta(datasetIndex);
          meta.hidden = !visible;
        }
        toggleDataVisibility(index2) {
          this._hiddenIndices[index2] = !this._hiddenIndices[index2];
        }
        getDataVisibility(index2) {
          return !this._hiddenIndices[index2];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
          const mode = visible ? "show" : "hide";
          const meta = this.getDatasetMeta(datasetIndex);
          const anims = meta.controller._resolveAnimations(void 0, mode);
          if (defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
          } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, { visible });
            this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
          }
        }
        hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
          const meta = this._metasets[datasetIndex];
          if (meta && meta.controller) {
            meta.controller._destroy();
          }
          delete this._metasets[datasetIndex];
        }
        _stop() {
          let i2, ilen;
          this.stop();
          animator.remove(this);
          for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
            this._destroyDatasetMeta(i2);
          }
        }
        destroy() {
          this.notifyPlugins("beforeDestroy");
          const { canvas, ctx } = this;
          this._stop();
          this.config.clearCache();
          if (canvas) {
            this.unbindEvents();
            clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
          }
          this.notifyPlugins("destroy");
          delete instances[this.id];
          this.notifyPlugins("afterDestroy");
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
            this.bindResponsiveEvents();
          } else {
            this.attached = true;
          }
        }
        bindUserEvents() {
          const listeners = this._listeners;
          const platform = this.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
          };
          const listener = (e, x, y) => {
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
          };
          each(this.options.events, (type) => _add(type, listener));
        }
        bindResponsiveEvents() {
          if (!this._responsiveListeners) {
            this._responsiveListeners = {};
          }
          const listeners = this._responsiveListeners;
          const platform = this.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
          };
          const _remove = (type, listener2) => {
            if (listeners[type]) {
              platform.removeEventListener(this, type, listener2);
              delete listeners[type];
            }
          };
          const listener = (width, height) => {
            if (this.canvas) {
              this.resize(width, height);
            }
          };
          let detached;
          const attached = () => {
            _remove("attach", attached);
            this.attached = true;
            this.resize();
            _add("resize", listener);
            _add("detach", detached);
          };
          detached = () => {
            this.attached = false;
            _remove("resize", listener);
            this._stop();
            this._resize(0, 0);
            _add("attach", attached);
          };
          if (platform.isAttached(this.canvas)) {
            attached();
          } else {
            detached();
          }
        }
        unbindEvents() {
          each(this._listeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._listeners = {};
          each(this._responsiveListeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._responsiveListeners = void 0;
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix2 = enabled ? "set" : "remove";
          let meta, item, i2, ilen;
          if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix2 + "DatasetHoverStyle"]();
          }
          for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            item = items[i2];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
              controller[prefix2 + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const lastActive = this._active || [];
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(active, lastActive);
          if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
          }
        }
        notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
        }
        _updateHoverStyles(active, lastActive, replay) {
          const hoverOptions = this.options.hover;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
          }
        }
        _eventHandler(e, replay) {
          const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
          };
          const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e.native.type);
          if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
          }
          const changed = this._handleEvent(e, replay, args.inChartArea);
          args.cancelable = false;
          this.notifyPlugins("afterEvent", args, eventFilter);
          if (changed || args.changed) {
            this.render();
          }
          return this;
        }
        _handleEvent(e, replay, inChartArea) {
          const { _active: lastActive = [], options } = this;
          const useFinalPosition = replay;
          const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
          const isClick = _isClickEvent(e);
          const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
          if (inChartArea) {
            this._lastEvent = null;
            callback(options.onHover, [e, active, this], this);
            if (isClick) {
              callback(options.onClick, [e, active, this], this);
            }
          }
          const changed = !_elementsEqual(active, lastActive);
          if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
          }
          this._lastEvent = lastEvent;
          return changed;
        }
        _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const hoverOptions = this.options.hover;
          return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
        }
      };
      invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
      enumerable = true;
      Object.defineProperties(Chart, {
        defaults: {
          enumerable,
          value: defaults
        },
        instances: {
          enumerable,
          value: instances
        },
        overrides: {
          enumerable,
          value: overrides
        },
        registry: {
          enumerable,
          value: registry
        },
        version: {
          enumerable,
          value: version
        },
        getChart: {
          enumerable,
          value: getChart
        },
        register: {
          enumerable,
          value: (...items) => {
            registry.add(...items);
            invalidatePlugins();
          }
        },
        unregister: {
          enumerable,
          value: (...items) => {
            registry.remove(...items);
            invalidatePlugins();
          }
        }
      });
      ArcElement = class extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.circumference = void 0;
          this.startAngle = void 0;
          this.endAngle = void 0;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps(["x", "y"], useFinalPosition);
          const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
          const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const rAdjust = this.options.spacing / 2;
          const _circumference = valueOrDefault(circumference, endAngle - startAngle);
          const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
          const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
          return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const { offset, spacing } = this.options;
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
          return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
          };
        }
        tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
          const { options, circumference } = this;
          const offset = (options.offset || 0) / 2;
          const spacing = (options.spacing || 0) / 2;
          const circular = options.circular;
          this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
          this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
          if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
          }
          ctx.save();
          let radiusOffset = 0;
          if (offset) {
            radiusOffset = offset / 2;
            const halfAngle = (this.startAngle + this.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
            if (this.circumference >= PI) {
              radiusOffset = offset;
            }
          }
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
          drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
          ctx.restore();
        }
      };
      ArcElement.id = "arc";
      ArcElement.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: true
      };
      ArcElement.defaultRoutes = {
        backgroundColor: "backgroundColor"
      };
      usePath2D = typeof Path2D === "function";
      LineElement = class extends Element {
        constructor(cfg) {
          super();
          this.animated = true;
          this.options = void 0;
          this._chart = void 0;
          this._loop = void 0;
          this._fullLoop = void 0;
          this._path = void 0;
          this._points = void 0;
          this._segments = void 0;
          this._decimated = false;
          this._pointsUpdated = false;
          this._datasetIndex = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        updateControlPoints(chartArea, indexAxis) {
          const options = this.options;
          if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
          }
        }
        set points(points) {
          this._points = points;
          delete this._segments;
          delete this._path;
          this._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = _computeSegments(this, this.options.segment));
        }
        first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const options = this.options;
          const value2 = point[property];
          const points = this.points;
          const segments = _boundSegments(this, { property, start: value2, end: value2 });
          if (!segments.length) {
            return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options);
          let i2, ilen;
          for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
            const { start, end } = segments[i2];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const t = Math.abs((value2 - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start, count) {
          const segments = this.segments;
          const segmentMethod = _getSegmentMethod(this);
          let loop = this._loop;
          start = start || 0;
          count = count || this.points.length - start;
          for (const segment of segments) {
            loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
          }
          return !!loop;
        }
        draw(ctx, chartArea, start, count) {
          const options = this.options || {};
          const points = this.points || [];
          if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
          }
          if (this.animated) {
            this._pointsUpdated = false;
            this._path = void 0;
          }
        }
      };
      LineElement.id = "line";
      LineElement.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      };
      LineElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      LineElement.descriptors = {
        _scriptable: true,
        _indexable: (name) => name !== "borderDash" && name !== "fill"
      };
      PointElement = class extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.parsed = void 0;
          this.skip = void 0;
          this.stop = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options = this.options;
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, "x", useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, "y", useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return { x, y };
        }
        size(options) {
          options = options || this.options || {};
          let radius = options.radius || 0;
          radius = Math.max(radius, radius && options.hoverRadius || 0);
          const borderWidth = radius && options.borderWidth || 0;
          return (radius + borderWidth) * 2;
        }
        draw(ctx, area) {
          const options = this.options;
          if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
            return;
          }
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.fillStyle = options.backgroundColor;
          drawPoint(ctx, options, this.x, this.y);
        }
        getRange() {
          const options = this.options || {};
          return options.radius + options.hitRadius;
        }
      };
      PointElement.id = "point";
      PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      };
      PointElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      BarElement = class extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.horizontal = void 0;
          this.base = void 0;
          this.width = void 0;
          this.height = void 0;
          this.inflateAmount = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        draw(ctx) {
          const { inflateAmount, options: { borderColor, backgroundColor } } = this;
          const { inner, outer } = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill("evenodd");
          }
          ctx.beginPath();
          addRectPath(ctx, inflateRect(inner, inflateAmount));
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
          return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
          };
        }
        getRange(axis) {
          return axis === "x" ? this.width / 2 : this.height / 2;
        }
      };
      BarElement.id = "bar";
      BarElement.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
      };
      BarElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      getBoxSize = (labelOpts, fontSize) => {
        let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
        if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
        }
        return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
        };
      };
      itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
      Legend = class extends Element {
        constructor(config) {
          super();
          this._added = false;
          this.legendHitBoxes = [];
          this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this.legendItems = void 0;
          this.columnSizes = void 0;
          this.lineWidths = void 0;
          this.maxHeight = void 0;
          this.maxWidth = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.height = void 0;
          this.width = void 0;
          this._margins = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight, margins) {
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins;
          this.setDimensions();
          this.buildLabels();
          this.fit();
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
          }
        }
        buildLabels() {
          const labelOpts = this.options.labels || {};
          let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
          if (labelOpts.filter) {
            legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
          }
          if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
          }
          if (this.options.reverse) {
            legendItems.reverse();
          }
          this.legendItems = legendItems;
        }
        fit() {
          const { options, ctx } = this;
          if (!options.display) {
            this.width = this.height = 0;
            return;
          }
          const labelOpts = options.labels;
          const labelFont = toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = this._computeTitleHeight();
          const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          }
          this.width = Math.min(width, options.maxWidth || this.maxWidth);
          this.height = Math.min(height, options.maxHeight || this.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const { ctx, maxWidth, options: { labels: { padding } } } = this;
          const hitboxes = this.legendHitBoxes = [];
          const lineWidths = this.lineWidths = [0];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let row = -1;
          let top = -lineHeight;
          this.legendItems.forEach((legendItem, i2) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
              totalHeight += lineHeight;
              lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
              top += lineHeight;
              row++;
            }
            hitboxes[i2] = { left: 0, top, row, width: itemWidth, height: itemHeight };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
        }
        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
          const { ctx, maxHeight, options: { labels: { padding } } } = this;
          const hitboxes = this.legendHitBoxes = [];
          const columnSizes = this.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let col = 0;
          this.legendItems.forEach((legendItem, i2) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
              totalWidth += currentColWidth + padding;
              columnSizes.push({ width: currentColWidth, height: currentColHeight });
              left += currentColWidth + padding;
              col++;
              currentColWidth = currentColHeight = 0;
            }
            hitboxes[i2] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({ width: currentColWidth, height: currentColHeight });
          return totalWidth;
        }
        adjustHitBoxes() {
          if (!this.options.display) {
            return;
          }
          const titleHeight = this._computeTitleHeight();
          const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
          const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
          if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes) {
              if (row !== hitbox.row) {
                row = hitbox.row;
                left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              }
              hitbox.top += this.top + titleHeight + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
              left += hitbox.width + padding;
            }
          } else {
            let col = 0;
            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes) {
              if (hitbox.col !== col) {
                col = hitbox.col;
                top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              }
              hitbox.top = top;
              hitbox.left += this.left + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
              top += hitbox.height + padding;
            }
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          if (this.options.display) {
            const ctx = this.ctx;
            clipArea(ctx, this);
            this._draw();
            unclipArea(ctx);
          }
        }
        _draw() {
          const { options: opts, columnSizes, lineWidths, ctx } = this;
          const { align, labels: labelOpts } = opts;
          const defaultColor = defaults.color;
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const labelFont = toFont(labelOpts.font);
          const { color: fontColor, padding } = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          this.drawTitle();
          ctx.textAlign = rtlHelper.textAlign("left");
          ctx.textBaseline = "middle";
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
              return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
              const drawOptions = {
                radius: boxHeight * Math.SQRT2 / 2,
                pointStyle: legendItem.pointStyle,
                rotation: legendItem.rotation,
                borderWidth: lineWidth
              };
              const centerX = rtlHelper.xPlus(x, boxWidth / 2);
              const centerY = y + halfFontSize;
              drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
              const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
              const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
              const borderRadius = toTRBLCorners(legendItem.borderRadius);
              ctx.beginPath();
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                addRoundedRectPath(ctx, {
                  x: xBoxLeft,
                  y: yBoxTop,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
              } else {
                ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
              }
              ctx.fill();
              if (lineWidth !== 0) {
                ctx.stroke();
              }
            }
            ctx.restore();
          };
          const fillText = function(x, y, legendItem) {
            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
              strikethrough: legendItem.hidden,
              textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
          };
          const isHorizontal = this.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
            cursor = {
              x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
              y: this.top + padding + titleHeight,
              line: 0
            };
          } else {
            cursor = {
              x: this.left + padding,
              y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
              line: 0
            };
          }
          overrideTextDirection(this.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          this.legendItems.forEach((legendItem, i2) => {
            ctx.strokeStyle = legendItem.fontColor || fontColor;
            ctx.fillStyle = legendItem.fontColor || fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
              if (i2 > 0 && x + width + padding > this.right) {
                y = cursor.y += lineHeight;
                cursor.line++;
                x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
              }
            } else if (i2 > 0 && y + lineHeight > this.bottom) {
              x = cursor.x = x + columnSizes[cursor.line].width + padding;
              cursor.line++;
              y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
              cursor.x += width + padding;
            } else {
              cursor.y += lineHeight;
            }
          });
          restoreTextDirection(this.ctx, opts.textDirection);
        }
        drawTitle() {
          const opts = this.options;
          const titleOpts = opts.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) {
            return;
          }
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const ctx = this.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = this.left;
          let maxWidth = this.width;
          if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, this.right - maxWidth);
          } else {
            const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
          ctx.textBaseline = "middle";
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
        _getLegendItemAt(x, y) {
          let i2, hitBox, lh;
          if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for (i2 = 0; i2 < lh.length; ++i2) {
              hitBox = lh[i2];
              if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                return this.legendItems[i2];
              }
            }
          }
          return null;
        }
        handleEvent(e) {
          const opts = this.options;
          if (!isListened(e.type, opts)) {
            return;
          }
          const hoveredItem = this._getLegendItemAt(e.x, e.y);
          if (e.type === "mousemove" || e.type === "mouseout") {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
              callback(opts.onLeave, [e, previous, this], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
              callback(opts.onHover, [e, hoveredItem, this], this);
            }
          } else if (hoveredItem) {
            callback(opts.onClick, [e, hoveredItem, this], this);
          }
        }
      };
      plugin_legend = {
        id: "legend",
        _element: Legend,
        start(chart, _args, options) {
          const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
          layouts.configure(chart, legend, options);
          layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
        },
        beforeUpdate(chart, _args, options) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options);
          legend.options = options;
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          if (!args.replay) {
            chart.legend.handleEvent(args.event);
          }
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1e3,
          onClick(e, legendItem, legend) {
            const index2 = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index2)) {
              ci.hide(index2);
              legendItem.hidden = true;
            } else {
              ci.show(index2);
              legendItem.hidden = false;
            }
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets;
              const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
              return chart._getSortedDatasetMetas().map((meta) => {
                const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                const borderWidth = toPadding(style.borderWidth);
                return {
                  text: datasets[meta.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color2,
                  hidden: !meta.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius: 0,
                  datasetIndex: meta.index
                };
              }, this);
            }
          },
          title: {
            color: (ctx) => ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: (name) => !name.startsWith("on"),
          labels: {
            _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
          }
        }
      };
      Title = class extends Element {
        constructor(config) {
          super();
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this._padding = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight) {
          const opts = this.options;
          this.left = 0;
          this.top = 0;
          if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
          }
          this.width = this.right = maxWidth;
          this.height = this.bottom = maxHeight;
          const lineCount = isArray(opts.text) ? opts.text.length : 1;
          this._padding = toPadding(opts.padding);
          const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
          if (this.isHorizontal()) {
            this.height = textSize;
          } else {
            this.width = textSize;
          }
        }
        isHorizontal() {
          const pos = this.options.position;
          return pos === "top" || pos === "bottom";
        }
        _drawArgs(offset) {
          const { top, left, bottom, right, options } = this;
          const align = options.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
          } else {
            if (options.position === "left") {
              titleX = left + offset;
              titleY = _alignStartEnd(align, bottom, top);
              rotation = PI * -0.5;
            } else {
              titleX = right - offset;
              titleY = _alignStartEnd(align, top, bottom);
              rotation = PI * 0.5;
            }
            maxWidth = bottom - top;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        draw() {
          const ctx = this.ctx;
          const opts = this.options;
          if (!opts.display) {
            return;
          }
          const fontOpts = toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + this._padding.top;
          const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
          renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
      };
      plugin_title = {
        id: "title",
        _element: Title,
        start(chart, _args, options) {
          createTitle(chart, options);
        },
        stop(chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options);
          title.options = options;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "bold"
          },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      positioners = {
        average(items) {
          if (!items.length) {
            return false;
          }
          let i2, len;
          let x = 0;
          let y = 0;
          let count = 0;
          for (i2 = 0, len = items.length; i2 < len; ++i2) {
            const el = items[i2].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }
          return {
            x: x / count,
            y: y / count
          };
        },
        nearest(items, eventPosition) {
          if (!items.length) {
            return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i2, len, nearestElement;
          for (i2 = 0, len = items.length; i2 < len; ++i2) {
            const el = items[i2].element;
            if (el && el.hasValue()) {
              const center = el.getCenterPoint();
              const d = distanceBetweenPoints(eventPosition, center);
              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }
          return {
            x,
            y
          };
        }
      };
      Tooltip2 = class extends Element {
        constructor(config) {
          super();
          this.opacity = 0;
          this._active = [];
          this._eventPosition = void 0;
          this._size = void 0;
          this._cachedAnimations = void 0;
          this._tooltipItems = [];
          this.$animations = void 0;
          this.$context = void 0;
          this.chart = config.chart || config._chart;
          this._chart = this.chart;
          this.options = config.options;
          this.dataPoints = void 0;
          this.title = void 0;
          this.beforeBody = void 0;
          this.body = void 0;
          this.afterBody = void 0;
          this.footer = void 0;
          this.xAlign = void 0;
          this.yAlign = void 0;
          this.x = void 0;
          this.y = void 0;
          this.height = void 0;
          this.width = void 0;
          this.caretX = void 0;
          this.caretY = void 0;
          this.labelColors = void 0;
          this.labelPointStyles = void 0;
          this.labelTextColors = void 0;
        }
        initialize(options) {
          this.options = options;
          this._cachedAnimations = void 0;
          this.$context = void 0;
        }
        _resolveAnimations() {
          const cached = this._cachedAnimations;
          if (cached) {
            return cached;
          }
          const chart = this.chart;
          const options = this.options.setContext(this.getContext());
          const opts = options.enabled && chart.options.animation && options.animations;
          const animations = new Animations(this.chart, opts);
          if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
          }
          return animations;
        }
        getContext() {
          return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
        }
        getTitle(context2, options) {
          const { callbacks } = options;
          const beforeTitle = callbacks.beforeTitle.apply(this, [context2]);
          const title = callbacks.title.apply(this, [context2]);
          const afterTitle = callbacks.afterTitle.apply(this, [context2]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        }
        getBeforeBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
        }
        getBody(tooltipItems, options) {
          const { callbacks } = options;
          const bodyItems = [];
          each(tooltipItems, (context2) => {
            const bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            const scoped = overrideCallbacks(callbacks, context2);
            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context2)));
            pushOrConcat(bodyItem.lines, scoped.label.call(this, context2));
            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context2)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        }
        getAfterBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
        }
        getFooter(tooltipItems, options) {
          const { callbacks } = options;
          const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
          const footer = callbacks.footer.apply(this, [tooltipItems]);
          const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        }
        _createItems(options) {
          const active = this._active;
          const data = this.chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i2, len;
          for (i2 = 0, len = active.length; i2 < len; ++i2) {
            tooltipItems.push(createTooltipItem(this.chart, active[i2]));
          }
          if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
          }
          if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
          }
          each(tooltipItems, (context2) => {
            const scoped = overrideCallbacks(options.callbacks, context2);
            labelColors.push(scoped.labelColor.call(this, context2));
            labelPointStyles.push(scoped.labelPointStyle.call(this, context2));
            labelTextColors.push(scoped.labelTextColor.call(this, context2));
          });
          this.labelColors = labelColors;
          this.labelPointStyles = labelPointStyles;
          this.labelTextColors = labelTextColors;
          this.dataPoints = tooltipItems;
          return tooltipItems;
        }
        update(changed, replay) {
          const options = this.options.setContext(this.getContext());
          const active = this._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
            if (this.opacity !== 0) {
              properties = {
                opacity: 0
              };
            }
          } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
              opacity: 1,
              x: backgroundPoint.x,
              y: backgroundPoint.y,
              width: size.width,
              height: size.height,
              caretX: position.x,
              caretY: position.y
            };
          }
          this._tooltipItems = tooltipItems;
          this.$context = void 0;
          if (properties) {
            this._resolveAnimations().update(this, properties);
          }
          if (changed && options.external) {
            options.external.call(this, { chart: this.chart, tooltip: this, replay });
          }
        }
        drawCaret(tooltipPoint, ctx, size, options) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
          const { xAlign, yAlign } = this;
          const { caretSize, cornerRadius } = options;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          const { x: ptX, y: ptY } = tooltipPoint;
          const { width, height } = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
              x1 = ptX;
              x2 = x1 - caretSize;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
            x3 = x1;
          } else {
            if (xAlign === "left") {
              x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === "right") {
              x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
              x2 = this.caretX;
            }
            if (yAlign === "top") {
              y1 = ptY;
              y2 = y1 - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              x1 = x2 + caretSize;
              x3 = x2 - caretSize;
            }
            y3 = y1;
          }
          return { x1, x2, x3, y1, y2, y3 };
        }
        drawTitle(pt, ctx, options) {
          const title = this.title;
          const length2 = title.length;
          let titleFont, titleSpacing, i2;
          if (length2) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for (i2 = 0; i2 < length2; ++i2) {
              ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
              pt.y += titleFont.lineHeight + titleSpacing;
              if (i2 + 1 === length2) {
                pt.y += options.titleMarginBottom - titleSpacing;
              }
            }
          }
        }
        _drawColorBox(ctx, pt, i2, rtlHelper, options) {
          const labelColors = this.labelColors[i2];
          const labelPointStyle = this.labelPointStyles[i2];
          const { boxHeight, boxWidth, boxPadding } = options;
          const bodyFont = toFont(options.bodyFont);
          const colorX = getAlignedX(this, "left", options);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options.usePointStyle) {
            const drawOptions = {
              radius: Math.min(boxWidth, boxHeight) / 2,
              pointStyle: labelPointStyle.pointStyle,
              rotation: labelPointStyle.rotation,
              borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColors.borderColor;
            ctx.fillStyle = labelColors.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.setLineDash(labelColors.borderDash || []);
            ctx.lineDashOffset = labelColors.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
            const borderRadius = toTRBLCorners(labelColors.borderRadius);
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              ctx.beginPath();
              ctx.fillStyle = options.multiKeyBackground;
              addRoundedRectPath(ctx, {
                x: outerX,
                y: colorY,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
              ctx.fill();
              ctx.stroke();
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                x: innerX,
                y: colorY + 1,
                w: boxWidth - 2,
                h: boxHeight - 2,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillStyle = options.multiKeyBackground;
              ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
              ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
          }
          ctx.fillStyle = this.labelTextColors[i2];
        }
        drawBody(pt, ctx, options) {
          const { body } = this;
          const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
          const bodyFont = toFont(options.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i2, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = "middle";
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(this, bodyAlignForCalculation, options);
          ctx.fillStyle = options.bodyColor;
          each(this.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
          for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
            bodyItem = body[i2];
            textColor = this.labelTextColors[i2];
            ctx.fillStyle = textColor;
            each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
              this._drawColorBox(ctx, pt, i2, rtlHelper, options);
              bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j = 0, jlen = lines.length; j < jlen; ++j) {
              fillLineOfText(lines[j]);
              bodyLineHeight = bodyFont.lineHeight;
            }
            each(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          each(this.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options) {
          const footer = this.footer;
          const length2 = footer.length;
          let footerFont, i2;
          if (length2) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for (i2 = 0; i2 < length2; ++i2) {
              ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
              pt.y += footerFont.lineHeight + options.footerSpacing;
            }
          }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
          const { xAlign, yAlign } = this;
          const { x, y } = pt;
          const { width, height } = tooltipSize;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + topLeft, y);
          if (yAlign === "top") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width - topRight, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
          if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width, y + height - bottomRight);
          ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
          if (yAlign === "bottom") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + bottomLeft, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
          if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x, y + topLeft);
          ctx.quadraticCurveTo(x, y, x + topLeft, y);
          ctx.closePath();
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        _updateAnimationTarget(options) {
          const chart = this.chart;
          const anims = this.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
              return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              this.width = size.width;
              this.height = size.height;
              this.caretX = position.x;
              this.caretY = position.y;
              this._resolveAnimations().update(this, point);
            }
          }
        }
        _willRender() {
          return !!this.opacity;
        }
        draw(ctx) {
          const options = this.options.setContext(this.getContext());
          let opacity = this.opacity;
          if (!opacity) {
            return;
          }
          this._updateAnimationTarget(options);
          const tooltipSize = {
            width: this.width,
            height: this.height
          };
          const pt = {
            x: this.x,
            y: this.y
          };
          opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
          const padding = toPadding(options.padding);
          const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
          if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            overrideTextDirection(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const lastActive = this._active;
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(lastActive, active);
          const positionChanged = this._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
          }
        }
        handleEvent(e, replay, inChartArea = true) {
          if (replay && this._ignoreReplayEvents) {
            return false;
          }
          this._ignoreReplayEvents = false;
          const options = this.options;
          const lastActive = this._active || [];
          const active = this._getActiveElements(e, lastActive, replay, inChartArea);
          const positionChanged = this._positionChanged(active, e);
          const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
              this._eventPosition = {
                x: e.x,
                y: e.y
              };
              this.update(true, replay);
            }
          }
          return changed;
        }
        _getActiveElements(e, lastActive, replay, inChartArea) {
          const options = this.options;
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
          if (options.reverse) {
            active.reverse();
          }
          return active;
        }
        _positionChanged(active, e) {
          const { caretX, caretY, options } = this;
          const position = positioners[options.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
        }
      };
      Tooltip2.positioners = positioners;
      plugin_tooltip = {
        id: "tooltip",
        _element: Tooltip2,
        positioners,
        afterInit(chart, _args, options) {
          if (options) {
            chart.tooltip = new Tooltip2({ chart, options });
          }
        },
        beforeUpdate(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        reset(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip._willRender()) {
            const args = {
              tooltip
            };
            if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
              return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
          }
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
              args.changed = true;
            }
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: {
            weight: "bold"
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
            weight: "bold"
          },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          boxPadding: 0,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "width", "height", "caretX", "caretY"]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: {
            beforeTitle: noop,
            title(tooltipItems) {
              if (tooltipItems.length > 0) {
                const item = tooltipItems[0];
                const labels = item.chart.data.labels;
                const labelCount = labels ? labels.length : 0;
                if (this && this.options && this.options.mode === "dataset") {
                  return item.dataset.label || "";
                } else if (item.label) {
                  return item.label;
                } else if (labelCount > 0 && item.dataIndex < labelCount) {
                  return labels[item.dataIndex];
                }
              }
              return "";
            },
            afterTitle: noop,
            beforeBody: noop,
            beforeLabel: noop,
            label(tooltipItem) {
              if (this && this.options && this.options.mode === "dataset") {
                return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
              }
              let label = tooltipItem.dataset.label || "";
              if (label) {
                label += ": ";
              }
              const value2 = tooltipItem.formattedValue;
              if (!isNullOrUndef(value2)) {
                label += value2;
              }
              return label;
            },
            labelColor(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                borderColor: options.borderColor,
                backgroundColor: options.backgroundColor,
                borderWidth: options.borderWidth,
                borderDash: options.borderDash,
                borderDashOffset: options.borderDashOffset,
                borderRadius: 0
              };
            },
            labelTextColor() {
              return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                pointStyle: options.pointStyle,
                rotation: options.rotation
              };
            },
            afterLabel: noop,
            afterBody: noop,
            beforeFooter: noop,
            footer: noop,
            afterFooter: noop
          }
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: {
            _fallback: false
          },
          animations: {
            _fallback: "animation"
          }
        },
        additionalOptionScopes: ["interaction"]
      };
      addIfString = (labels, raw, index2, addedLabels) => {
        if (typeof raw === "string") {
          index2 = labels.push(raw) - 1;
          addedLabels.unshift({ index: index2, label: raw });
        } else if (isNaN(raw)) {
          index2 = null;
        }
        return index2;
      };
      validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
      CategoryScale = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this._startValue = void 0;
          this._valueRange = 0;
          this._addedLabels = [];
        }
        init(scaleOptions) {
          const added = this._addedLabels;
          if (added.length) {
            const labels = this.getLabels();
            for (const { index: index2, label } of added) {
              if (labels[index2] === label) {
                labels.splice(index2, 1);
              }
            }
            this._addedLabels = [];
          }
          super.init(scaleOptions);
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          const labels = this.getLabels();
          index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
          return validIndex(index2, labels.length - 1);
        }
        determineDataLimits() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this.getMinMax(true);
          if (this.options.bounds === "ticks") {
            if (!minDefined) {
              min = 0;
            }
            if (!maxDefined) {
              max = this.getLabels().length - 1;
            }
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const min = this.min;
          const max = this.max;
          const offset = this.options.offset;
          const ticks = [];
          let labels = this.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          this._startValue = this.min - (offset ? 0.5 : 0);
          for (let value2 = min; value2 <= max; value2++) {
            ticks.push({ value: value2 });
          }
          return ticks;
        }
        getLabelForValue(value2) {
          const labels = this.getLabels();
          if (value2 >= 0 && value2 < labels.length) {
            return labels[value2];
          }
          return value2;
        }
        configure() {
          super.configure();
          if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
          }
        }
        getPixelForValue(value2) {
          if (typeof value2 !== "number") {
            value2 = this.parse(value2);
          }
          return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getValueForPixel(pixel) {
          return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      };
      CategoryScale.id = "category";
      CategoryScale.defaults = {
        ticks: {
          callback: CategoryScale.prototype.getLabelForValue
        }
      };
      LinearScaleBase = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._endValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
          }
          return +raw;
        }
        handleTickRangeOptions() {
          const { beginAtZero } = this.options;
          const { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
              setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
              setMin(0);
            }
          }
          if (min === max) {
            let offset = 1;
            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
              offset = Math.abs(max * 0.05);
            }
            setMax(max + offset);
            if (!beginAtZero) {
              setMin(min - offset);
            }
          }
          this.min = min;
          this.max = max;
        }
        getTickLimit() {
          const tickOpts = this.options.ticks;
          let { maxTicksLimit, stepSize } = tickOpts;
          let maxTicks;
          if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1e3) {
              console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
              maxTicks = 1e3;
            }
          } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const opts = this.options;
          const tickOpts = opts.ticks;
          let maxTicks = this.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = this._range || this;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        configure() {
          const ticks = this.ticks;
          let start = this.min;
          let end = this.max;
          super.configure();
          if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
          }
          this._startValue = start;
          this._endValue = end;
          this._valueRange = end - start;
        }
        getLabelForValue(value2) {
          return formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
        }
      };
      LinearScale = class extends LinearScaleBase {
        determineDataLimits() {
          const { min, max } = this.getMinMax(true);
          this.min = isNumberFinite(min) ? min : 0;
          this.max = isNumberFinite(max) ? max : 1;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          const horizontal = this.isHorizontal();
          const length2 = horizontal ? this.width : this.height;
          const minRotation = toRadians(this.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
          const tickFont = this._resolveTickFontOptions(0);
          return Math.ceil(length2 / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value2) {
          return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
      };
      LinearScale.id = "linear";
      LinearScale.defaults = {
        ticks: {
          callback: Ticks.formatters.numeric
        }
      };
      LogarithmicScale = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          const value2 = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
          if (value2 === 0) {
            this._zero = true;
            return void 0;
          }
          return isNumberFinite(value2) && value2 > 0 ? value2 : null;
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(true);
          this.min = isNumberFinite(min) ? Math.max(0, min) : null;
          this.max = isNumberFinite(max) ? Math.max(0, max) : null;
          if (this.options.beginAtZero) {
            this._zero = true;
          }
          this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let min = this.min;
          let max = this.max;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
          if (min === max) {
            if (min <= 0) {
              setMin(1);
              setMax(10);
            } else {
              setMin(exp(min, -1));
              setMax(exp(max, 1));
            }
          }
          if (min <= 0) {
            setMin(exp(max, -1));
          }
          if (max <= 0) {
            setMax(exp(min, 1));
          }
          if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
            setMin(exp(min, -1));
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const opts = this.options;
          const generationOptions = {
            min: this._userMin,
            max: this._userMax
          };
          const ticks = generateTicks(generationOptions, this);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        getLabelForValue(value2) {
          return value2 === void 0 ? "0" : formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
        }
        configure() {
          const start = this.min;
          super.configure();
          this._startValue = log10(start);
          this._valueRange = log10(this.max) - log10(start);
        }
        getPixelForValue(value2) {
          if (value2 === void 0 || value2 === 0) {
            value2 = this.min;
          }
          if (value2 === null || isNaN(value2)) {
            return NaN;
          }
          return this.getPixelForDecimal(value2 === this.min ? 0 : (log10(value2) - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          const decimal = this.getDecimalForPixel(pixel);
          return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
      };
      LogarithmicScale.id = "logarithmic";
      LogarithmicScale.defaults = {
        ticks: {
          callback: Ticks.formatters.logarithmic,
          major: {
            enabled: true
          }
        }
      };
      RadialLinearScale = class extends LinearScaleBase {
        constructor(cfg) {
          super(cfg);
          this.xCenter = void 0;
          this.yCenter = void 0;
          this.drawingArea = void 0;
          this._pointLabels = [];
          this._pointLabelItems = [];
        }
        setDimensions() {
          const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
          const w = this.width = this.maxWidth - padding.width;
          const h = this.height = this.maxHeight - padding.height;
          this.xCenter = Math.floor(this.left + w / 2 + padding.left);
          this.yCenter = Math.floor(this.top + h / 2 + padding.top);
          this.drawingArea = Math.floor(Math.min(w, h) / 2);
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(false);
          this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
          this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
          LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
          this._pointLabels = this.getLabels().map((value2, index2) => {
            const label = callback(this.options.pointLabels.callback, [value2, index2], this);
            return label || label === 0 ? label : "";
          }).filter((v, i2) => this.chart.getDataVisibility(i2));
        }
        fit() {
          const opts = this.options;
          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
          } else {
            this.setCenterPoint(0, 0, 0, 0);
          }
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
          this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
          this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
        }
        getIndexAngle(index2) {
          const angleMultiplier = TAU / (this._pointLabels.length || 1);
          const startAngle = this.options.startAngle || 0;
          return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value2) {
          if (isNullOrUndef(value2)) {
            return NaN;
          }
          const scalingFactor = this.drawingArea / (this.max - this.min);
          if (this.options.reverse) {
            return (this.max - value2) * scalingFactor;
          }
          return (value2 - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) {
            return NaN;
          }
          const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
          return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
        }
        getPointLabelContext(index2) {
          const pointLabels = this._pointLabels || [];
          if (index2 >= 0 && index2 < pointLabels.length) {
            const pointLabel = pointLabels[index2];
            return createPointLabelContext(this.getContext(), index2, pointLabel);
          }
        }
        getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
          const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
          return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
          };
        }
        getPointPositionForValue(index2, value2) {
          return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value2));
        }
        getBasePosition(index2) {
          return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
        }
        getPointLabelPosition(index2) {
          const { left, top, right, bottom } = this._pointLabelItems[index2];
          return {
            left,
            top,
            right,
            bottom
          };
        }
        drawBackground() {
          const { backgroundColor, grid: { circular } } = this.options;
          if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
        }
        drawGrid() {
          const ctx = this.ctx;
          const opts = this.options;
          const { angleLines, grid } = opts;
          const labelCount = this._pointLabels.length;
          let i2, offset, position;
          if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
          }
          if (grid.display) {
            this.ticks.forEach((tick, index2) => {
              if (index2 !== 0) {
                offset = this.getDistanceFromCenterForValue(tick.value);
                const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
                drawRadiusLine(this, optsAtIndex, offset, labelCount);
              }
            });
          }
          if (angleLines.display) {
            ctx.save();
            for (i2 = labelCount - 1; i2 >= 0; i2--) {
              const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
              const { color: color2, lineWidth } = optsAtIndex;
              if (!lineWidth || !color2) {
                continue;
              }
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = color2;
              ctx.setLineDash(optsAtIndex.borderDash);
              ctx.lineDashOffset = optsAtIndex.borderDashOffset;
              offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
              position = this.getPointPosition(i2, offset);
              ctx.beginPath();
              ctx.moveTo(this.xCenter, this.yCenter);
              ctx.lineTo(position.x, position.y);
              ctx.stroke();
            }
            ctx.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const ctx = this.ctx;
          const opts = this.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
            return;
          }
          const startAngle = this.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(this.xCenter, this.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          this.ticks.forEach((tick, index2) => {
            if (index2 === 0 && !opts.reverse) {
              return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index2));
            const tickFont = toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
            if (optsAtIndex.showLabelBackdrop) {
              ctx.font = tickFont.string;
              width = ctx.measureText(tick.label).width;
              ctx.fillStyle = optsAtIndex.backdropColor;
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillRect(
                -width / 2 - padding.left,
                -offset - tickFont.size / 2 - padding.top,
                width + padding.width,
                tickFont.size + padding.height
              );
            }
            renderText(ctx, tick.label, 0, -offset, tickFont, {
              color: optsAtIndex.color
            });
          });
          ctx.restore();
        }
        drawTitle() {
        }
      };
      RadialLinearScale.id = "radialLinear";
      RadialLinearScale.defaults = {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: {
          circular: false
        },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: Ticks.formatters.numeric
        },
        pointLabels: {
          backdropColor: void 0,
          backdropPadding: 2,
          display: true,
          font: {
            size: 10
          },
          callback(label) {
            return label;
          },
          padding: 5,
          centerPointLabels: false
        }
      };
      RadialLinearScale.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      };
      RadialLinearScale.descriptors = {
        angleLines: {
          _fallback: "grid"
        }
      };
      INTERVALS = {
        millisecond: { common: true, size: 1, steps: 1e3 },
        second: { common: true, size: 1e3, steps: 60 },
        minute: { common: true, size: 6e4, steps: 60 },
        hour: { common: true, size: 36e5, steps: 24 },
        day: { common: true, size: 864e5, steps: 30 },
        week: { common: false, size: 6048e5, steps: 4 },
        month: { common: true, size: 2628e6, steps: 12 },
        quarter: { common: false, size: 7884e6, steps: 4 },
        year: { common: true, size: 3154e7 }
      };
      UNITS = Object.keys(INTERVALS);
      TimeScale = class extends Scale {
        constructor(props) {
          super(props);
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
          this._unit = "day";
          this._majorUnit = void 0;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = void 0;
        }
        init(scaleOpts, opts) {
          const time = scaleOpts.time || (scaleOpts.time = {});
          const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
          adapter.init(opts);
          mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
        }
        parse(raw, index2) {
          if (raw === void 0) {
            return null;
          }
          return parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout();
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const options = this.options;
          const adapter = this._adapter;
          const unit = options.time.unit || "day";
          let { min, max, minDefined, maxDefined } = this.getUserBounds();
          function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
              min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
              max = Math.max(max, bounds.max);
            }
          }
          if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
              _applyBounds(this.getMinMax(false));
            }
          }
          min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          this.min = Math.min(min, max - 1);
          this.max = Math.max(min + 1, max);
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
          }
          return { min, max };
        }
        buildTicks() {
          const options = this.options;
          const timeOpts = options.time;
          const tickOpts = options.ticks;
          const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
          if (options.bounds === "ticks" && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
          }
          const min = this.min;
          const max = this.max;
          const ticks = _filterBetween(timestamps, min, max);
          this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
          this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
          this.initOffsets(timestamps);
          if (options.reverse) {
            ticks.reverse();
          }
          return ticksFromTimestamps(this, ticks, this._majorUnit);
        }
        afterAutoSkip() {
          if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick) => +tick.value));
          }
        }
        initOffsets(timestamps) {
          let start = 0;
          let end = 0;
          let first, last;
          if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
              start = 1 - first;
            } else {
              start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
              end = last;
            } else {
              end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start = _limitValue(start, 0, limit);
          end = _limitValue(end, 0, limit);
          this._offsets = { start, end, factor: 1 / (start + 1 + end) };
        }
        _generate() {
          const adapter = this._adapter;
          const min = this.min;
          const max = this.max;
          const options = this.options;
          const timeOpts = options.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
          const stepSize = valueOrDefault(timeOpts.stepSize, 1);
          const weekday = minor === "week" ? timeOpts.isoWeekday : false;
          const hasWeekday = isNumber(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
          }
          const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
          for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
            addTick(ticks, time, timestamps);
          }
          if (time === max || options.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
        }
        getLabelForValue(value2) {
          const adapter = this._adapter;
          const timeOpts = this.options.time;
          if (timeOpts.tooltipFormat) {
            return adapter.format(value2, timeOpts.tooltipFormat);
          }
          return adapter.format(value2, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index2, ticks, format) {
          const options = this.options;
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const majorUnit = this._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick = ticks[index2];
          const major = majorUnit && majorFormat && tick && tick.major;
          const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
          const formatter2 = options.ticks.callback;
          return formatter2 ? callback(formatter2, [label, index2, ticks], this) : label;
        }
        generateTickLabels(ticks) {
          let i2, ilen, tick;
          for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
            tick = ticks[i2];
            tick.label = this._tickFormatFunction(tick.value, i2, ticks);
          }
        }
        getDecimalForValue(value2) {
          return value2 === null ? NaN : (value2 - this.min) / (this.max - this.min);
        }
        getPixelForValue(value2) {
          const offsets = this._offsets;
          const pos = this.getDecimalForValue(value2);
          return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return this.min + pos * (this.max - this.min);
        }
        _getLabelSize(label) {
          const ticksOpts = this.options.ticks;
          const tickLabelWidth = this.ctx.measureText(label).width;
          const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = this._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
        }
        _getLabelCapacity(exampleTime) {
          const timeOpts = this.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
          const size = this._getLabelSize(exampleLabel);
          const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          let timestamps = this._cache.data || [];
          let i2, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const metas = this.getMatchingVisibleMetas();
          if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
          }
          for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
            timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
          }
          return this._cache.data = this.normalize(timestamps);
        }
        getLabelTimestamps() {
          const timestamps = this._cache.labels || [];
          let i2, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const labels = this.getLabels();
          for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
            timestamps.push(parse(this, labels[i2]));
          }
          return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
        }
        normalize(values) {
          return _arrayUnique(values.sort(sorter));
        }
      };
      TimeScale.id = "time";
      TimeScale.defaults = {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          major: {
            enabled: false
          }
        }
      };
      TimeSeriesScale = class extends TimeScale {
        constructor(props) {
          super(props);
          this._table = [];
          this._minPos = void 0;
          this._tableRange = void 0;
        }
        initOffsets() {
          const timestamps = this._getTimestampsForTable();
          const table = this._table = this.buildLookupTable(timestamps);
          this._minPos = interpolate2(table, this.min);
          this._tableRange = interpolate2(table, this.max) - this._minPos;
          super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
          const { min, max } = this;
          const items = [];
          const table = [];
          let i2, ilen, prev2, curr, next;
          for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
            curr = timestamps[i2];
            if (curr >= min && curr <= max) {
              items.push(curr);
            }
          }
          if (items.length < 2) {
            return [
              { time: min, pos: 0 },
              { time: max, pos: 1 }
            ];
          }
          for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            next = items[i2 + 1];
            prev2 = items[i2 - 1];
            curr = items[i2];
            if (Math.round((next + prev2) / 2) !== curr) {
              table.push({ time: curr, pos: i2 / (ilen - 1) });
            }
          }
          return table;
        }
        _getTimestampsForTable() {
          let timestamps = this._cache.all || [];
          if (timestamps.length) {
            return timestamps;
          }
          const data = this.getDataTimestamps();
          const label = this.getLabelTimestamps();
          if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
          } else {
            timestamps = data.length ? data : label;
          }
          timestamps = this._cache.all = timestamps;
          return timestamps;
        }
        getDecimalForValue(value2) {
          return (interpolate2(this._table, value2) - this._minPos) / this._tableRange;
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
        }
      };
      TimeSeriesScale.id = "timeseries";
      TimeSeriesScale.defaults = TimeScale.defaults;
    }
  });

  // node_modules/chart.js/dist/helpers.mjs
  var init_helpers = __esm({
    "node_modules/chart.js/dist/helpers.mjs"() {
      init_helpers_segment();
    }
  });

  // node_modules/chart.js/helpers/helpers.mjs
  var init_helpers2 = __esm({
    "node_modules/chart.js/helpers/helpers.mjs"() {
      init_helpers();
    }
  });

  // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js
  function orient(point, origin) {
    var x0 = origin.x;
    var y0 = origin.y;
    if (x0 === null) {
      return { x: 0, y: -1 };
    }
    if (y0 === null) {
      return { x: 1, y: 0 };
    }
    var dx = point.x - x0;
    var dy = point.y - y0;
    var ln = Math.sqrt(dx * dx + dy * dy);
    return {
      x: ln ? dx / ln : 0,
      y: ln ? dy / ln : -1
    };
  }
  function aligned(x, y, vx, vy, align) {
    switch (align) {
      case "center":
        vx = vy = 0;
        break;
      case "bottom":
        vx = 0;
        vy = 1;
        break;
      case "right":
        vx = 1;
        vy = 0;
        break;
      case "left":
        vx = -1;
        vy = 0;
        break;
      case "top":
        vx = 0;
        vy = -1;
        break;
      case "start":
        vx = -vx;
        vy = -vy;
        break;
      case "end":
        break;
      default:
        align *= Math.PI / 180;
        vx = Math.cos(align);
        vy = Math.sin(align);
        break;
    }
    return {
      x,
      y,
      vx,
      vy
    };
  }
  function region(x, y, rect) {
    var res = R_INSIDE;
    if (x < rect.left) {
      res |= R_LEFT;
    } else if (x > rect.right) {
      res |= R_RIGHT;
    }
    if (y < rect.top) {
      res |= R_TOP;
    } else if (y > rect.bottom) {
      res |= R_BOTTOM;
    }
    return res;
  }
  function clipped(segment, area) {
    var x0 = segment.x0;
    var y0 = segment.y0;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var r0 = region(x0, y0, area);
    var r1 = region(x1, y1, area);
    var r, x, y;
    while (true) {
      if (!(r0 | r1) || r0 & r1) {
        break;
      }
      r = r0 || r1;
      if (r & R_TOP) {
        x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
        y = area.top;
      } else if (r & R_BOTTOM) {
        x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
        y = area.bottom;
      } else if (r & R_RIGHT) {
        y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
        x = area.right;
      } else if (r & R_LEFT) {
        y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
        x = area.left;
      }
      if (r === r0) {
        x0 = x;
        y0 = y;
        r0 = region(x0, y0, area);
      } else {
        x1 = x;
        y1 = y;
        r1 = region(x1, y1, area);
      }
    }
    return {
      x0,
      x1,
      y0,
      y1
    };
  }
  function compute$1(range, config) {
    var anchor = config.anchor;
    var segment = range;
    var x, y;
    if (config.clamp) {
      segment = clipped(segment, config.area);
    }
    if (anchor === "start") {
      x = segment.x0;
      y = segment.y0;
    } else if (anchor === "end") {
      x = segment.x1;
      y = segment.y1;
    } else {
      x = (segment.x0 + segment.x1) / 2;
      y = (segment.y0 + segment.y1) / 2;
    }
    return aligned(x, y, range.vx, range.vy, config.align);
  }
  function boundingRects2(model) {
    var borderWidth = model.borderWidth || 0;
    var padding = model.padding;
    var th = model.size.height;
    var tw = model.size.width;
    var tx = -tw / 2;
    var ty = -th / 2;
    return {
      frame: {
        x: tx - padding.left - borderWidth,
        y: ty - padding.top - borderWidth,
        w: tw + padding.width + borderWidth * 2,
        h: th + padding.height + borderWidth * 2
      },
      text: {
        x: tx,
        y: ty,
        w: tw,
        h: th
      }
    };
  }
  function getScaleOrigin(el, context2) {
    var scale = context2.chart.getDatasetMeta(context2.datasetIndex).vScale;
    if (!scale) {
      return null;
    }
    if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
      return { x: scale.xCenter, y: scale.yCenter };
    }
    var pixel = scale.getBasePixel();
    return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
  }
  function getPositioner(el) {
    if (el instanceof ArcElement) {
      return positioners2.arc;
    }
    if (el instanceof PointElement) {
      return positioners2.point;
    }
    if (el instanceof BarElement) {
      return positioners2.bar;
    }
    return positioners2.fallback;
  }
  function drawRoundedRect(ctx, x, y, w, h, radius) {
    var HALF_PI2 = Math.PI / 2;
    if (radius) {
      var r = Math.min(radius, h / 2, w / 2);
      var left = x + r;
      var top = y + r;
      var right = x + w - r;
      var bottom = y + h - r;
      ctx.moveTo(x, top);
      if (left < right && top < bottom) {
        ctx.arc(left, top, r, -Math.PI, -HALF_PI2);
        ctx.arc(right, top, r, -HALF_PI2, 0);
        ctx.arc(right, bottom, r, 0, HALF_PI2);
        ctx.arc(left, bottom, r, HALF_PI2, Math.PI);
      } else if (left < right) {
        ctx.moveTo(left, y);
        ctx.arc(right, top, r, -HALF_PI2, HALF_PI2);
        ctx.arc(left, top, r, HALF_PI2, Math.PI + HALF_PI2);
      } else if (top < bottom) {
        ctx.arc(left, top, r, -Math.PI, 0);
        ctx.arc(left, bottom, r, 0, Math.PI);
      } else {
        ctx.arc(left, top, r, -Math.PI, Math.PI);
      }
      ctx.closePath();
      ctx.moveTo(x, y);
    } else {
      ctx.rect(x, y, w, h);
    }
  }
  function drawFrame(ctx, rect, model) {
    var bgColor = model.backgroundColor;
    var borderColor = model.borderColor;
    var borderWidth = model.borderWidth;
    if (!bgColor && (!borderColor || !borderWidth)) {
      return;
    }
    ctx.beginPath();
    drawRoundedRect(
      ctx,
      rasterize(rect.x) + borderWidth / 2,
      rasterize(rect.y) + borderWidth / 2,
      rasterize(rect.w) - borderWidth,
      rasterize(rect.h) - borderWidth,
      model.borderRadius
    );
    ctx.closePath();
    if (bgColor) {
      ctx.fillStyle = bgColor;
      ctx.fill();
    }
    if (borderColor && borderWidth) {
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = "miter";
      ctx.stroke();
    }
  }
  function textGeometry(rect, align, font) {
    var h = font.lineHeight;
    var w = rect.w;
    var x = rect.x;
    var y = rect.y + h / 2;
    if (align === "center") {
      x += w / 2;
    } else if (align === "end" || align === "right") {
      x += w;
    }
    return {
      h,
      w,
      x,
      y
    };
  }
  function drawTextLine(ctx, text, cfg) {
    var shadow = ctx.shadowBlur;
    var stroked = cfg.stroked;
    var x = rasterize(cfg.x);
    var y = rasterize(cfg.y);
    var w = rasterize(cfg.w);
    if (stroked) {
      ctx.strokeText(text, x, y, w);
    }
    if (cfg.filled) {
      if (shadow && stroked) {
        ctx.shadowBlur = 0;
      }
      ctx.fillText(text, x, y, w);
      if (shadow && stroked) {
        ctx.shadowBlur = shadow;
      }
    }
  }
  function drawText(ctx, lines, rect, model) {
    var align = model.textAlign;
    var color2 = model.color;
    var filled = !!color2;
    var font = model.font;
    var ilen = lines.length;
    var strokeColor = model.textStrokeColor;
    var strokeWidth = model.textStrokeWidth;
    var stroked = strokeColor && strokeWidth;
    var i2;
    if (!ilen || !filled && !stroked) {
      return;
    }
    rect = textGeometry(rect, align, font);
    ctx.font = font.string;
    ctx.textAlign = align;
    ctx.textBaseline = "middle";
    ctx.shadowBlur = model.textShadowBlur;
    ctx.shadowColor = model.textShadowColor;
    if (filled) {
      ctx.fillStyle = color2;
    }
    if (stroked) {
      ctx.lineJoin = "round";
      ctx.lineWidth = strokeWidth;
      ctx.strokeStyle = strokeColor;
    }
    for (i2 = 0, ilen = lines.length; i2 < ilen; ++i2) {
      drawTextLine(ctx, lines[i2], {
        stroked,
        filled,
        w: rect.w,
        x: rect.x,
        y: rect.y + rect.h * i2
      });
    }
  }
  function rotated(point, center, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var cx = center.x;
    var cy = center.y;
    return {
      x: cx + cos * (point.x - cx) - sin * (point.y - cy),
      y: cy + sin * (point.x - cx) + cos * (point.y - cy)
    };
  }
  function projected(points, axis) {
    var min = MAX_INTEGER;
    var max = MIN_INTEGER;
    var origin = axis.origin;
    var i2, pt, vx, vy, dp;
    for (i2 = 0; i2 < points.length; ++i2) {
      pt = points[i2];
      vx = pt.x - origin.x;
      vy = pt.y - origin.y;
      dp = axis.vx * vx + axis.vy * vy;
      min = Math.min(min, dp);
      max = Math.max(max, dp);
    }
    return {
      min,
      max
    };
  }
  function toAxis(p0, p1) {
    var vx = p1.x - p0.x;
    var vy = p1.y - p0.y;
    var ln = Math.sqrt(vx * vx + vy * vy);
    return {
      vx: (p1.x - p0.x) / ln,
      vy: (p1.y - p0.y) / ln,
      origin: p0,
      ln
    };
  }
  function coordinates(el, model, geometry) {
    var point = model.positioner(el, model);
    var vx = point.vx;
    var vy = point.vy;
    if (!vx && !vy) {
      return { x: point.x, y: point.y };
    }
    var w = geometry.w;
    var h = geometry.h;
    var rotation = model.rotation;
    var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
    var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
    var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
    dx *= vx * vs;
    dy *= vy * vs;
    dx += model.offset * vx;
    dy += model.offset * vy;
    return {
      x: point.x + dx,
      y: point.y + dy
    };
  }
  function collide(labels, collider) {
    var i2, j, s0, s1;
    for (i2 = labels.length - 1; i2 >= 0; --i2) {
      s0 = labels[i2].$layout;
      for (j = i2 - 1; j >= 0 && s0._visible; --j) {
        s1 = labels[j].$layout;
        if (s1._visible && s0._box.intersects(s1._box)) {
          collider(s0, s1);
        }
      }
    }
    return labels;
  }
  function compute(labels) {
    var i2, ilen, label, state, geometry, center, proxy;
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      label = labels[i2];
      state = label.$layout;
      if (state._visible) {
        proxy = new Proxy(label._el, { get: (el, p) => el.getProps([p], true)[p] });
        geometry = label.geometry();
        center = coordinates(proxy, label.model(), geometry);
        state._box.update(center, geometry, label.rotation());
      }
    }
    return collide(labels, function(s0, s1) {
      var h0 = s0._hidable;
      var h12 = s1._hidable;
      if (h0 && h12 || h12) {
        s1._visible = false;
      } else if (h0) {
        s0._visible = false;
      }
    });
  }
  function configure(dataset, options) {
    var override = dataset.datalabels;
    var listeners = {};
    var configs = [];
    var labels, keys;
    if (override === false) {
      return null;
    }
    if (override === true) {
      override = {};
    }
    options = merge({}, [options, override]);
    labels = options.labels || {};
    keys = Object.keys(labels);
    delete options.labels;
    if (keys.length) {
      keys.forEach(function(key) {
        if (labels[key]) {
          configs.push(merge({}, [
            options,
            labels[key],
            { _key: key }
          ]));
        }
      });
    } else {
      configs.push(options);
    }
    listeners = configs.reduce(function(target, config) {
      each(config.listeners || {}, function(fn, event) {
        target[event] = target[event] || {};
        target[event][config._key || DEFAULT_KEY] = fn;
      });
      delete config.listeners;
      return target;
    }, {});
    return {
      labels: configs,
      listeners
    };
  }
  function dispatchEvent(chart, listeners, label, event) {
    if (!listeners) {
      return;
    }
    var context2 = label.$context;
    var groups = label.$groups;
    var callback$1;
    if (!listeners[groups._set]) {
      return;
    }
    callback$1 = listeners[groups._set][groups._key];
    if (!callback$1) {
      return;
    }
    if (callback(callback$1, [context2, event]) === true) {
      chart[EXPANDO_KEY2]._dirty = true;
      label.update(context2);
    }
  }
  function dispatchMoveEvents(chart, listeners, previous, label, event) {
    var enter, leave;
    if (!previous && !label) {
      return;
    }
    if (!previous) {
      enter = true;
    } else if (!label) {
      leave = true;
    } else if (previous !== label) {
      leave = enter = true;
    }
    if (leave) {
      dispatchEvent(chart, listeners.leave, previous, event);
    }
    if (enter) {
      dispatchEvent(chart, listeners.enter, label, event);
    }
  }
  function handleMoveEvents(chart, event) {
    var expando = chart[EXPANDO_KEY2];
    var listeners = expando._listeners;
    var previous, label;
    if (!listeners.enter && !listeners.leave) {
      return;
    }
    if (event.type === "mousemove") {
      label = layout.lookup(expando._labels, event);
    } else if (event.type !== "mouseout") {
      return;
    }
    previous = expando._hovered;
    expando._hovered = label;
    dispatchMoveEvents(chart, listeners, previous, label, event);
  }
  function handleClickEvents(chart, event) {
    var expando = chart[EXPANDO_KEY2];
    var handlers = expando._listeners.click;
    var label = handlers && layout.lookup(expando._labels, event);
    if (label) {
      dispatchEvent(chart, handlers, label, event);
    }
  }
  var devicePixelRatio, utils, R_INSIDE, R_LEFT, R_RIGHT, R_BOTTOM, R_TOP, positioners2, rasterize, Label, MIN_INTEGER, MAX_INTEGER, HitBox, layout, formatter, defaults2, EXPANDO_KEY2, DEFAULT_KEY, plugin;
  var init_chartjs_plugin_datalabels_esm = __esm({
    "node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js"() {
      init_helpers2();
      init_chart();
      devicePixelRatio = function() {
        if (typeof window !== "undefined") {
          if (window.devicePixelRatio) {
            return window.devicePixelRatio;
          }
          var screen = window.screen;
          if (screen) {
            return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
          }
        }
        return 1;
      }();
      utils = {
        toTextLines: function(inputs) {
          var lines = [];
          var input;
          inputs = [].concat(inputs);
          while (inputs.length) {
            input = inputs.pop();
            if (typeof input === "string") {
              lines.unshift.apply(lines, input.split("\n"));
            } else if (Array.isArray(input)) {
              inputs.push.apply(inputs, input);
            } else if (!isNullOrUndef(inputs)) {
              lines.unshift("" + input);
            }
          }
          return lines;
        },
        textSize: function(ctx, lines, font) {
          var items = [].concat(lines);
          var ilen = items.length;
          var prev2 = ctx.font;
          var width = 0;
          var i2;
          ctx.font = font.string;
          for (i2 = 0; i2 < ilen; ++i2) {
            width = Math.max(ctx.measureText(items[i2]).width, width);
          }
          ctx.font = prev2;
          return {
            height: ilen * font.lineHeight,
            width
          };
        },
        bound: function(min, value2, max) {
          return Math.max(min, Math.min(value2, max));
        },
        arrayDiff: function(a0, a1) {
          var prev2 = a0.slice();
          var updates = [];
          var i2, j, ilen, v;
          for (i2 = 0, ilen = a1.length; i2 < ilen; ++i2) {
            v = a1[i2];
            j = prev2.indexOf(v);
            if (j === -1) {
              updates.push([v, 1]);
            } else {
              prev2.splice(j, 1);
            }
          }
          for (i2 = 0, ilen = prev2.length; i2 < ilen; ++i2) {
            updates.push([prev2[i2], -1]);
          }
          return updates;
        },
        rasterize: function(v) {
          return Math.round(v * devicePixelRatio) / devicePixelRatio;
        }
      };
      R_INSIDE = 0;
      R_LEFT = 1;
      R_RIGHT = 2;
      R_BOTTOM = 4;
      R_TOP = 8;
      positioners2 = {
        arc: function(el, config) {
          var angle = (el.startAngle + el.endAngle) / 2;
          var vx = Math.cos(angle);
          var vy = Math.sin(angle);
          var r0 = el.innerRadius;
          var r1 = el.outerRadius;
          return compute$1({
            x0: el.x + vx * r0,
            y0: el.y + vy * r0,
            x1: el.x + vx * r1,
            y1: el.y + vy * r1,
            vx,
            vy
          }, config);
        },
        point: function(el, config) {
          var v = orient(el, config.origin);
          var rx = v.x * el.options.radius;
          var ry = v.y * el.options.radius;
          return compute$1({
            x0: el.x - rx,
            y0: el.y - ry,
            x1: el.x + rx,
            y1: el.y + ry,
            vx: v.x,
            vy: v.y
          }, config);
        },
        bar: function(el, config) {
          var v = orient(el, config.origin);
          var x = el.x;
          var y = el.y;
          var sx = 0;
          var sy = 0;
          if (el.horizontal) {
            x = Math.min(el.x, el.base);
            sx = Math.abs(el.base - el.x);
          } else {
            y = Math.min(el.y, el.base);
            sy = Math.abs(el.base - el.y);
          }
          return compute$1({
            x0: x,
            y0: y + sy,
            x1: x + sx,
            y1: y,
            vx: v.x,
            vy: v.y
          }, config);
        },
        fallback: function(el, config) {
          var v = orient(el, config.origin);
          return compute$1({
            x0: el.x,
            y0: el.y,
            x1: el.x + (el.width || 0),
            y1: el.y + (el.height || 0),
            vx: v.x,
            vy: v.y
          }, config);
        }
      };
      rasterize = utils.rasterize;
      Label = function(config, ctx, el, index2) {
        var me = this;
        me._config = config;
        me._index = index2;
        me._model = null;
        me._rects = null;
        me._ctx = ctx;
        me._el = el;
      };
      merge(Label.prototype, {
        _modelize: function(display, lines, config, context2) {
          var me = this;
          var index2 = me._index;
          var font = toFont(resolve([config.font, {}], context2, index2));
          var color2 = resolve([config.color, defaults.color], context2, index2);
          return {
            align: resolve([config.align, "center"], context2, index2),
            anchor: resolve([config.anchor, "center"], context2, index2),
            area: context2.chart.chartArea,
            backgroundColor: resolve([config.backgroundColor, null], context2, index2),
            borderColor: resolve([config.borderColor, null], context2, index2),
            borderRadius: resolve([config.borderRadius, 0], context2, index2),
            borderWidth: resolve([config.borderWidth, 0], context2, index2),
            clamp: resolve([config.clamp, false], context2, index2),
            clip: resolve([config.clip, false], context2, index2),
            color: color2,
            display,
            font,
            lines,
            offset: resolve([config.offset, 4], context2, index2),
            opacity: resolve([config.opacity, 1], context2, index2),
            origin: getScaleOrigin(me._el, context2),
            padding: toPadding(resolve([config.padding, 4], context2, index2)),
            positioner: getPositioner(me._el),
            rotation: resolve([config.rotation, 0], context2, index2) * (Math.PI / 180),
            size: utils.textSize(me._ctx, lines, font),
            textAlign: resolve([config.textAlign, "start"], context2, index2),
            textShadowBlur: resolve([config.textShadowBlur, 0], context2, index2),
            textShadowColor: resolve([config.textShadowColor, color2], context2, index2),
            textStrokeColor: resolve([config.textStrokeColor, color2], context2, index2),
            textStrokeWidth: resolve([config.textStrokeWidth, 0], context2, index2)
          };
        },
        update: function(context2) {
          var me = this;
          var model = null;
          var rects = null;
          var index2 = me._index;
          var config = me._config;
          var value2, label, lines;
          var display = resolve([config.display, true], context2, index2);
          if (display) {
            value2 = context2.dataset.data[index2];
            label = valueOrDefault(callback(config.formatter, [value2, context2]), value2);
            lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);
            if (lines.length) {
              model = me._modelize(display, lines, config, context2);
              rects = boundingRects2(model);
            }
          }
          me._model = model;
          me._rects = rects;
        },
        geometry: function() {
          return this._rects ? this._rects.frame : {};
        },
        rotation: function() {
          return this._model ? this._model.rotation : 0;
        },
        visible: function() {
          return this._model && this._model.opacity;
        },
        model: function() {
          return this._model;
        },
        draw: function(chart, center) {
          var me = this;
          var ctx = chart.ctx;
          var model = me._model;
          var rects = me._rects;
          var area;
          if (!this.visible()) {
            return;
          }
          ctx.save();
          if (model.clip) {
            area = model.area;
            ctx.beginPath();
            ctx.rect(
              area.left,
              area.top,
              area.right - area.left,
              area.bottom - area.top
            );
            ctx.clip();
          }
          ctx.globalAlpha = utils.bound(0, model.opacity, 1);
          ctx.translate(rasterize(center.x), rasterize(center.y));
          ctx.rotate(model.rotation);
          drawFrame(ctx, rects.frame, model);
          drawText(ctx, model.lines, rects.text, model);
          ctx.restore();
        }
      });
      MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
      MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      HitBox = function() {
        this._rotation = 0;
        this._rect = {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        };
      };
      merge(HitBox.prototype, {
        center: function() {
          var r = this._rect;
          return {
            x: r.x + r.w / 2,
            y: r.y + r.h / 2
          };
        },
        update: function(center, rect, rotation) {
          this._rotation = rotation;
          this._rect = {
            x: rect.x + center.x,
            y: rect.y + center.y,
            w: rect.w,
            h: rect.h
          };
        },
        contains: function(point) {
          var me = this;
          var margin = 1;
          var rect = me._rect;
          point = rotated(point, me.center(), -me._rotation);
          return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
        },
        intersects: function(other) {
          var r0 = this._points();
          var r1 = other._points();
          var axes = [
            toAxis(r0[0], r0[1]),
            toAxis(r0[0], r0[3])
          ];
          var i2, pr0, pr1;
          if (this._rotation !== other._rotation) {
            axes.push(
              toAxis(r1[0], r1[1]),
              toAxis(r1[0], r1[3])
            );
          }
          for (i2 = 0; i2 < axes.length; ++i2) {
            pr0 = projected(r0, axes[i2]);
            pr1 = projected(r1, axes[i2]);
            if (pr0.max < pr1.min || pr1.max < pr0.min) {
              return false;
            }
          }
          return true;
        },
        _points: function() {
          var me = this;
          var rect = me._rect;
          var angle = me._rotation;
          var center = me.center();
          return [
            rotated({ x: rect.x, y: rect.y }, center, angle),
            rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
            rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
            rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
          ];
        }
      });
      layout = {
        prepare: function(datasets) {
          var labels = [];
          var i2, j, ilen, jlen, label;
          for (i2 = 0, ilen = datasets.length; i2 < ilen; ++i2) {
            for (j = 0, jlen = datasets[i2].length; j < jlen; ++j) {
              label = datasets[i2][j];
              labels.push(label);
              label.$layout = {
                _box: new HitBox(),
                _hidable: false,
                _visible: true,
                _set: i2,
                _idx: label._index
              };
            }
          }
          labels.sort(function(a, b) {
            var sa = a.$layout;
            var sb = b.$layout;
            return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
          });
          this.update(labels);
          return labels;
        },
        update: function(labels) {
          var dirty = false;
          var i2, ilen, label, model, state;
          for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
            label = labels[i2];
            model = label.model();
            state = label.$layout;
            state._hidable = model && model.display === "auto";
            state._visible = label.visible();
            dirty |= state._hidable;
          }
          if (dirty) {
            compute(labels);
          }
        },
        lookup: function(labels, point) {
          var i2, state;
          for (i2 = labels.length - 1; i2 >= 0; --i2) {
            state = labels[i2].$layout;
            if (state && state._visible && state._box.contains(point)) {
              return labels[i2];
            }
          }
          return null;
        },
        draw: function(chart, labels) {
          var i2, ilen, label, state, geometry, center;
          for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
            label = labels[i2];
            state = label.$layout;
            if (state._visible) {
              geometry = label.geometry();
              center = coordinates(label._el, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
              label.draw(chart, center);
            }
          }
        }
      };
      formatter = function(value2) {
        if (isNullOrUndef(value2)) {
          return null;
        }
        var label = value2;
        var keys, klen, k;
        if (isObject(value2)) {
          if (!isNullOrUndef(value2.label)) {
            label = value2.label;
          } else if (!isNullOrUndef(value2.r)) {
            label = value2.r;
          } else {
            label = "";
            keys = Object.keys(value2);
            for (k = 0, klen = keys.length; k < klen; ++k) {
              label += (k !== 0 ? ", " : "") + keys[k] + ": " + value2[keys[k]];
            }
          }
        }
        return "" + label;
      };
      defaults2 = {
        align: "center",
        anchor: "center",
        backgroundColor: null,
        borderColor: null,
        borderRadius: 0,
        borderWidth: 0,
        clamp: false,
        clip: false,
        color: void 0,
        display: true,
        font: {
          family: void 0,
          lineHeight: 1.2,
          size: void 0,
          style: void 0,
          weight: null
        },
        formatter,
        labels: void 0,
        listeners: {},
        offset: 4,
        opacity: 1,
        padding: {
          top: 4,
          right: 4,
          bottom: 4,
          left: 4
        },
        rotation: 0,
        textAlign: "start",
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        textShadowBlur: 0,
        textShadowColor: void 0
      };
      EXPANDO_KEY2 = "$datalabels";
      DEFAULT_KEY = "$default";
      plugin = {
        id: "datalabels",
        defaults: defaults2,
        beforeInit: function(chart) {
          chart[EXPANDO_KEY2] = {
            _actives: []
          };
        },
        beforeUpdate: function(chart) {
          var expando = chart[EXPANDO_KEY2];
          expando._listened = false;
          expando._listeners = {};
          expando._datasets = [];
          expando._labels = [];
        },
        afterDatasetUpdate: function(chart, args, options) {
          var datasetIndex = args.index;
          var expando = chart[EXPANDO_KEY2];
          var labels = expando._datasets[datasetIndex] = [];
          var visible = chart.isDatasetVisible(datasetIndex);
          var dataset = chart.data.datasets[datasetIndex];
          var config = configure(dataset, options);
          var elements = args.meta.data || [];
          var ctx = chart.ctx;
          var i2, j, ilen, jlen, cfg, key, el, label;
          ctx.save();
          for (i2 = 0, ilen = elements.length; i2 < ilen; ++i2) {
            el = elements[i2];
            el[EXPANDO_KEY2] = [];
            if (visible && el && chart.getDataVisibility(i2) && !el.skip) {
              for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                cfg = config.labels[j];
                key = cfg._key;
                label = new Label(cfg, ctx, el, i2);
                label.$groups = {
                  _set: datasetIndex,
                  _key: key || DEFAULT_KEY
                };
                label.$context = {
                  active: false,
                  chart,
                  dataIndex: i2,
                  dataset,
                  datasetIndex
                };
                label.update(label.$context);
                el[EXPANDO_KEY2].push(label);
                labels.push(label);
              }
            }
          }
          ctx.restore();
          merge(expando._listeners, config.listeners, {
            merger: function(event, target, source) {
              target[event] = target[event] || {};
              target[event][args.index] = source[event];
              expando._listened = true;
            }
          });
        },
        afterUpdate: function(chart) {
          chart[EXPANDO_KEY2]._labels = layout.prepare(chart[EXPANDO_KEY2]._datasets);
        },
        afterDatasetsDraw: function(chart) {
          layout.draw(chart, chart[EXPANDO_KEY2]._labels);
        },
        beforeEvent: function(chart, args) {
          if (chart[EXPANDO_KEY2]._listened) {
            var event = args.event;
            switch (event.type) {
              case "mousemove":
              case "mouseout":
                handleMoveEvents(chart, event);
                break;
              case "click":
                handleClickEvents(chart, event);
                break;
            }
          }
        },
        afterEvent: function(chart) {
          var expando = chart[EXPANDO_KEY2];
          var previous = expando._actives;
          var actives = expando._actives = chart.getActiveElements();
          var updates = utils.arrayDiff(previous, actives);
          var i2, ilen, j, jlen, update2, label, labels;
          for (i2 = 0, ilen = updates.length; i2 < ilen; ++i2) {
            update2 = updates[i2];
            if (update2[1]) {
              labels = update2[0].element[EXPANDO_KEY2] || [];
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                label = labels[j];
                label.$context.active = update2[1] === 1;
                label.update(label.$context);
              }
            }
          }
          if (expando._dirty || updates.length) {
            layout.update(expando._labels);
            chart.render();
          }
          delete expando._dirty;
        }
      };
    }
  });

  // external-global-plugin:react
  var require_react = __commonJS({
    "external-global-plugin:react"(exports, module) {
      module.exports = window.React;
    }
  });

  // node_modules/react-chartjs-2/dist/index.js
  function reforwardRef(ref, value2) {
    if (typeof ref === "function") {
      ref(value2);
    } else if (ref) {
      ref.current = value2;
    }
  }
  function setOptions(chart, nextOptions) {
    Object.assign(chart.options, nextOptions);
  }
  function setLabels(currentData, nextLabels) {
    currentData.labels = nextLabels;
  }
  function setDatasets(currentData, nextDatasets) {
    let datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;
    const addedDatasets = [];
    currentData.datasets = nextDatasets.map((nextDataset) => {
      const currentDataset = currentData.datasets.find(
        (dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]
      );
      if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
        return {
          ...nextDataset
        };
      }
      addedDatasets.push(currentDataset);
      Object.assign(currentDataset, nextDataset);
      return currentDataset;
    });
  }
  function cloneData(data) {
    let datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;
    const nextData = {
      labels: [],
      datasets: []
    };
    setLabels(nextData, data.labels);
    setDatasets(nextData, data.datasets, datasetIdKey);
    return nextData;
  }
  function ChartComponent(param, ref) {
    let { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode, ...props } = param;
    const canvasRef = (0, import_react.useRef)(null);
    const chartRef = (0, import_react.useRef)();
    const renderChart = () => {
      if (!canvasRef.current)
        return;
      chartRef.current = new Chart(canvasRef.current, {
        type,
        data: cloneData(data, datasetIdKey),
        options: options && {
          ...options
        },
        plugins
      });
      reforwardRef(ref, chartRef.current);
    };
    const destroyChart = () => {
      reforwardRef(ref, null);
      if (chartRef.current) {
        chartRef.current.destroy();
        chartRef.current = null;
      }
    };
    (0, import_react.useEffect)(() => {
      if (!redraw && chartRef.current && options) {
        setOptions(chartRef.current, options);
      }
    }, [
      redraw,
      options
    ]);
    (0, import_react.useEffect)(() => {
      if (!redraw && chartRef.current) {
        setLabels(chartRef.current.config.data, data.labels);
      }
    }, [
      redraw,
      data.labels
    ]);
    (0, import_react.useEffect)(() => {
      if (!redraw && chartRef.current && data.datasets) {
        setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);
      }
    }, [
      redraw,
      data.datasets
    ]);
    (0, import_react.useEffect)(() => {
      if (!chartRef.current)
        return;
      if (redraw) {
        destroyChart();
        setTimeout(renderChart);
      } else {
        chartRef.current.update(updateMode);
      }
    }, [
      redraw,
      options,
      data.labels,
      data.datasets,
      updateMode
    ]);
    (0, import_react.useEffect)(() => {
      if (!chartRef.current)
        return;
      destroyChart();
      setTimeout(renderChart);
    }, [
      type
    ]);
    (0, import_react.useEffect)(() => {
      renderChart();
      return () => destroyChart();
    }, []);
    return /* @__PURE__ */ import_react.default.createElement("canvas", Object.assign({
      ref: canvasRef,
      role: "img",
      height,
      width
    }, props), fallbackContent);
  }
  function createTypedChart(type, registerables) {
    Chart.register(registerables);
    return /* @__PURE__ */ (0, import_react.forwardRef)(
      (props, ref) => /* @__PURE__ */ import_react.default.createElement(Chart2, Object.assign({}, props, {
        ref,
        type
      }))
    );
  }
  var import_react, defaultDatasetIdKey, Chart2, Bar, Doughnut;
  var init_dist = __esm({
    "node_modules/react-chartjs-2/dist/index.js"() {
      import_react = __toESM(require_react());
      init_chart();
      defaultDatasetIdKey = "label";
      Chart2 = /* @__PURE__ */ (0, import_react.forwardRef)(ChartComponent);
      Bar = /* @__PURE__ */ createTypedChart("bar", BarController);
      Doughnut = /* @__PURE__ */ createTypedChart("doughnut", DoughnutController);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/SearchVolumeChart.js
  var Empty, memo2, sidebar, SearchVolumeChart;
  var init_SearchVolumeChart = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/SearchVolumeChart.js"() {
      init_chart();
      init_chartjs_plugin_datalabels_esm();
      init_dist();
      ({ Empty } = window.antd);
      ({ memo: memo2 } = window.React);
      sidebar = wp.data.select("getgenie").sidebar();
      Chart.register(
        CategoryScale,
        LinearScale,
        BarElement,
        plugin_title,
        plugin_tooltip,
        plugin_legend,
        plugin
      );
      SearchVolumeChart = memo2(({ data }) => {
        const options = {
          responsive: false,
          layout: {
            padding: {
              top: 25,
              right: 0,
              left: 0,
              bottom: 0
            }
          },
          plugins: {
            datalabels: {
              display: true,
              color: "#7999D0",
              align: "end",
              rotation: 270,
              anchor: "end",
              font: { size: "10" },
              formatter: function(value2) {
                if (value2 < 1e3)
                  return value2;
                if (value2 >= 1e3 && value2 < 1e6)
                  return +(value2 / 1e3).toFixed(1) + "K";
                if (value2 >= 1e6 && value2 < 1e9)
                  return +(value2 / 1e6).toFixed(1) + "M";
                if (value2 >= 1e9 && value2 < 1e12)
                  return +(value2 / 1e9).toFixed(1) + "B";
                if (value2 >= 1e12)
                  return +(value2 / 1e12).toFixed(1) + "T";
              }
            },
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              grid: {
                display: false
              },
              ticks: {
                autoSkip: true,
                maxRotation: 0,
                minRotation: 0
              }
            },
            y: {
              grid: {
                borderWidth: 0
              },
              ticks: {
                callback: function(value2) {
                  if (value2 < 1e3)
                    return value2;
                  if (value2 >= 1e3 && value2 < 1e6)
                    return +(value2 / 1e3).toFixed(1) + "K";
                  if (value2 >= 1e6 && value2 < 1e9)
                    return +(value2 / 1e6).toFixed(1) + "M";
                  if (value2 >= 1e9 && value2 < 1e12)
                    return +(value2 / 1e9).toFixed(1) + "B";
                  if (value2 >= 1e12)
                    return +(value2 / 1e12).toFixed(1) + "T";
                }
              }
            }
          }
        };
        const labels = data.map((item) => item?.date);
        const chartData = {
          labels,
          datasets: [
            {
              label: sidebar.__("Volume", "getgenie"),
              data: data.map((item) => item?.volume),
              backgroundColor: "#DBE7FD"
            }
          ]
        };
        return data.length === 0 ? /* @__PURE__ */ React.createElement(Empty, {
          description: sidebar.__(`No Search Volume Trend data found`, "getgenie"),
          className: "getgenie-chart empty"
        }) : /* @__PURE__ */ React.createElement(Bar, {
          className: "getgenie-chart",
          width: "298",
          height: "300",
          options,
          data: chartData
        });
      });
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/OverviewChart.js
  var Typography3, Libs3, useState3, useEffect3, ComposeComponents3, OverviewChart;
  var init_OverviewChart = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/OverviewChart.js"() {
      init_GoogleTrendChart();
      init_SearchVolumeChart();
      ({ Typography: Typography3 } = window.antd);
      ({ Libs: Libs3 } = window.getGenie.Components.Common);
      ({ useState: useState3, useEffect: useEffect3 } = window.React);
      ({ ComposeComponents: ComposeComponents3 } = window.getGenie.Components.Common.ReduxManager);
      OverviewChart = ComposeComponents3(({ setInput, getInputs, sidebar: sidebar4 }) => {
        const currentTab = getInputs["overviewChartTab"] || "searchVolTrend";
        const [data, setData] = useState3([]);
        const handleActiveKey = (key) => {
          setInput("overviewChartTab", key);
        };
        const tabPaneList = [
          {
            label: sidebar4.__("Search Vol. Trend", "getgenie"),
            key: "searchVolTrend",
            children: /* @__PURE__ */ React.createElement(SearchVolumeChart, {
              data
            })
          },
          {
            label: sidebar4.__("Google Trends", "getgenie"),
            key: "googleTrend",
            children: /* @__PURE__ */ React.createElement(GoogleTrendChart_default, {
              data: getInputs["searchVolume"]?.keyword || ""
            })
          }
        ];
        useEffect3(() => {
          if (sidebar4.currentTemplate !== "blogWizard" && sidebar4.currentScreen !== "keywordAnalysis") {
            return;
          }
          if (getInputs["searchVolume"]?.chart?.[currentTab]) {
            setData(getInputs["searchVolume"].chart[currentTab]);
          } else {
            setData([]);
            handleActiveKey("googleTrend");
          }
        }, [getInputs["searchVolume"]]);
        if (data.length === 0) {
          tabPaneList.shift();
        }
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-seo-result-chart-container"
        }, /* @__PURE__ */ React.createElement(Typography3.Title, {
          level: 5,
          className: "getgenie-title"
        }, sidebar4.__("Overview Chart", "getgenie")), /* @__PURE__ */ React.createElement(Libs3.Navbar, {
          tabPaneList,
          activeKey: currentTab,
          handleActiveKey,
          destroyInactiveTabPane: false,
          className: "keyword-analysis-chart"
        }));
      }, ["setInput", "getInputs", "sidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/KeywordDoctor.js
  var Libs4;
  var init_KeywordDoctor = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/KeywordDoctor.js"() {
      ({ Libs: Libs4 } = window.getGenie.Components.Common);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/RelatedKeyword.js
  var Libs5, Utilities2, HandleFetch, HandleResponse, ComposeComponents4, Typography4, Tooltip3, notification2, useEffect4, keywordFinder, RelatedKeyword;
  var init_RelatedKeyword = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/RelatedKeyword.js"() {
      init_KeywordFinder();
      init_KeywordDoctor();
      ({ Libs: Libs5, Utilities: Utilities2 } = window.getGenie.Components.Common);
      ({ HandleFetch, HandleResponse } = window.getGenie.Components.Common.RequestManager);
      ({ ComposeComponents: ComposeComponents4 } = window.getGenie.Components.Common.ReduxManager);
      ({ Typography: Typography4, Tooltip: Tooltip3, notification: notification2 } = window.antd);
      ({ useEffect: useEffect4 } = window.React);
      keywordFinder = new KeywordFinder();
      RelatedKeyword = ComposeComponents4(({ getInputs, setInput, sidebar: sidebar4, setSidebar, limitUsage: limitUsage2 }) => {
        let data = getInputs["relatedKeywords"] || [];
        let customKeywords = getInputs["customKeywords"] || [];
        let competitorKeywords = Object.keys(sidebar4.statisticsData?.keywords || {});
        useEffect4(() => {
          if (sidebar4.analyzingSearchVolume) {
            const keyword = (getInputs["keyword"] || "").replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/g, "").toLowerCase();
            getSearchVol(keyword, getInputs["inputContext"]);
          }
        }, [sidebar4.analyzingSearchVolume]);
        const getSearchVol = (keyword, context2) => {
          let body = {
            input: {
              keyword,
              context: context2
            },
            location: getInputs["seoCountry"],
            templateSlug: "keyword-analysis"
          };
          HandleFetch((res) => {
            HandleResponse(res, () => {
              const keywordList = res?.data || [];
              setInput("relatedKeywords", keywordList);
              let responseData = keywordList.find((item) => (item?.keyword || "").trim() === keyword.trim());
              if (responseData) {
                let searchVol = {
                  ...responseData,
                  keyword: getInputs["keyword"] || "",
                  country: getInputs["seoCountry"] || "usa"
                };
                setInput("searchVolume", searchVol);
                Utilities2.GenieHelpers.callStoreApi("keywordData", {
                  searchVolume: searchVol,
                  relatedKeywords: keywordList
                });
              }
            });
            setSidebar({
              analyzingSearchVolume: false
            });
          }, "keywordsData", body);
        };
        const manageKeyword = (keyword, isExist) => {
          let updatedKeywords = customKeywords;
          if (isExist) {
            updatedKeywords = customKeywords.filter((item) => item.keyword !== keyword);
          } else {
            let usage = keywordFinder.findSingleMatch(sidebar4.currentPostContent, keyword);
            updatedKeywords = [...customKeywords, { keyword, usage }];
          }
          setInput("customKeywords", updatedKeywords);
        };
        const isKeywordExist = (keyword) => {
          return !!customKeywords?.find((item) => item?.keyword === keyword);
        };
        const isManageable = (keyword) => {
          return !competitorKeywords.find((item) => item === keyword) && getInputs["competitorData"];
        };
        const showRelatedKeywords = (item) => {
          const searchVolume = item?.searchVolume || {};
          const { cpc, total = "-" } = searchVolume;
          const { currency = "$", value: value2 = 0 } = cpc || {};
          return /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-data-column"
          }, /* @__PURE__ */ React.createElement(Typography4.Title, {
            className: "getgenie-data-value"
          }, "CPC: ", currency, parseFloat(value2).toFixed(3)), /* @__PURE__ */ React.createElement(Typography4.Title, {
            className: "getgenie-data-value"
          }, "Search: ", total));
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-seo-result-related-keyword",
          style: { paddingBottom: getInputs["peopleAlsoSearched"] ? 0 : "150px" }
        }, /* @__PURE__ */ React.createElement(Typography4.Title, {
          level: 5,
          className: "getgenie-title"
        }, sidebar4.__("Related Keyword", "getgenie")), sidebar4.analyzingSearchVolume ? /* @__PURE__ */ React.createElement("div", {
          style: { padding: "8px" }
        }, /* @__PURE__ */ React.createElement(Libs5.SkeletonSingle, {
          count: 10
        })) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-related-keywords"
        }, data.length), data.length === 0 ? /* @__PURE__ */ React.createElement(Typography4.Title, {
          level: 5,
          className: "getgenie-not-found-title"
        }, sidebar4.__("No related keyword found", "getgenie")) : /* @__PURE__ */ React.createElement(Libs5.BlurElement, {
          show: limitUsage2.subscription_type !== "pro",
          top: 360,
          text: "Go Pro, Reveal Untapped Keywords!",
          btnText: "Upgrade for Success",
          href: "https://getgenie.ai/pricing/"
        }, /* @__PURE__ */ React.createElement(Libs5.Card, {
          list: data,
          column: 1
        }, (item, index2) => {
          let isExist = isKeywordExist(item?.keyword);
          let actionClass = isExist ? "getgenie-icon-minus remove" : "getgenie-icon-plus add";
          let showAction = isManageable(item?.keyword);
          return /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-data-container"
          }, showAction ? /* @__PURE__ */ React.createElement(Tooltip3, {
            title: sidebar4.__("Add/remove this keyword for SEO analysis", "getgenie"),
            placement: "topLeft"
          }, /* @__PURE__ */ React.createElement("span", {
            className: `getgenie-related-keyword-card-button ${actionClass}`,
            onClick: () => manageKeyword(item?.keyword, isExist)
          })) : "", /* @__PURE__ */ React.createElement("h5", {
            className: "getgenie-data-title"
          }, item?.keyword), showRelatedKeywords(item));
        }))));
      }, ["getInputs", "sidebar", "setInput", "setSidebar", "limitUsage"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/PeopleAlsoSearched.js
  var Libs6, ComposeComponents5, Typography5, Tooltip4, keywordFinder2, PeopleAlsoSearched;
  var init_PeopleAlsoSearched = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/PeopleAlsoSearched.js"() {
      init_KeywordFinder();
      ({ Libs: Libs6 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents5 } = window.getGenie.Components.Common.ReduxManager);
      ({ Typography: Typography5, Tooltip: Tooltip4 } = window.antd);
      keywordFinder2 = new KeywordFinder();
      PeopleAlsoSearched = ComposeComponents5(({ getInputs, sidebar: sidebar4, setInput }) => {
        let customKeywords = getInputs["customKeywords"] || [];
        let competitorKeywords = Object.keys(sidebar4.statisticsData?.keywords || {});
        let data = getInputs["peopleAlsoSearched"];
        if (!data) {
          return "";
        }
        data = data.map((item) => ({ ...item, keyword: item?.title }));
        const splitIndex = data.findIndex((item) => item?.title && item?.title.toLowerCase() === "see more");
        if (splitIndex !== -1) {
          data = data.slice(splitIndex + 1, data.length);
        }
        const manageKeyword = (keyword, isExist) => {
          if (!keyword) {
            return;
          }
          let updatedKeywords = customKeywords;
          if (isExist) {
            updatedKeywords = customKeywords.filter((item) => item.keyword !== keyword);
          } else {
            let usage = keywordFinder2.findSingleMatch(sidebar4.currentPostContent, keyword);
            updatedKeywords = [...customKeywords, { keyword, usage }];
          }
          setInput("customKeywords", updatedKeywords);
        };
        const isKeywordExist = (keyword) => {
          return !!customKeywords?.find((item) => item?.keyword === keyword);
        };
        const isManageable = (keyword) => {
          return !competitorKeywords.find((item) => item === keyword) && getInputs["competitorData"];
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-seo-result-related-keyword getgenie-seo-result-people-also-searched-keyword"
        }, /* @__PURE__ */ React.createElement(Typography5.Title, {
          level: 5,
          className: "getgenie-title"
        }, sidebar4.__("People also searched for", "getgenie")), /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-related-keywords"
        }, data.length), /* @__PURE__ */ React.createElement(Libs6.Card, {
          list: data,
          column: 1
        }, (item) => {
          let isExist = isKeywordExist(item?.keyword);
          let actionClass = isExist ? "getgenie-icon-minus remove" : "getgenie-icon-plus add";
          let showAction = isManageable(item?.keyword);
          return /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-data-container"
          }, showAction ? /* @__PURE__ */ React.createElement(Tooltip4, {
            title: sidebar4.__("Add/remove this keyword for SEO analysis", "getgenie"),
            placement: "topLeft"
          }, /* @__PURE__ */ React.createElement("span", {
            className: `getgenie-related-keyword-card-button ${actionClass}`,
            onClick: () => manageKeyword(item?.keyword, isExist)
          })) : "", /* @__PURE__ */ React.createElement("h5", {
            className: "getgenie-data-title"
          }, typeof item === "string" ? item : item?.title));
        }));
      }, ["getInputs", "sidebar", "setSidebar", "setInput"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/Keywords/index.js
  var ComposeComponents6, Libs7, useEffect5, keywordFinder3, Keywords;
  var init_Keywords = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/Keywords/index.js"() {
      init_KeywordAnalysis();
      init_OverviewChart();
      init_RelatedKeyword();
      init_KeywordDoctor();
      init_PeopleAlsoSearched();
      init_KeywordFinder();
      ({ ComposeComponents: ComposeComponents6 } = window.getGenie.Components.Common.ReduxManager);
      ({ Libs: Libs7 } = window.getGenie.Components.Common);
      ({ useEffect: useEffect5 } = window.React);
      keywordFinder3 = new KeywordFinder();
      Keywords = ComposeComponents6(({ sidebar: sidebar4, setInput, getInputs }) => {
        const customKeywords = getInputs["customKeywords"] || [];
        useEffect5(() => {
          const updatedKeywords = customKeywords.map((item) => {
            let usage = keywordFinder3.findSingleMatch(sidebar4.currentPostContent, item?.keyword);
            return { ...item, usage };
          });
          setInput("customKeywords", updatedKeywords);
        }, [sidebar4.currentPostContent]);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.analyzingSearchVolume ? /* @__PURE__ */ React.createElement(Libs7.SkeletonCard, {
          count: 2
        }) : /* @__PURE__ */ React.createElement("div", {
          style: { backgroundColor: "#fff", paddingBottom: "10px" }
        }, " ", /* @__PURE__ */ React.createElement(KeywordAnalysis, null), /* @__PURE__ */ React.createElement(OverviewChart, null)), /* @__PURE__ */ React.createElement(RelatedKeyword, null), /* @__PURE__ */ React.createElement(PeopleAlsoSearched, null));
      }, ["sidebar", "getInputs", "setInput"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/QuestionsAsked/index.js
  var Checkbox2, Typography6, Tooltip5, Button2, Utilities3, Libs8, GenieHelpers3, ComposeComponents7, useState4, QuestionsAsked;
  var init_QuestionsAsked = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/QuestionsAsked/index.js"() {
      ({ Checkbox: Checkbox2, Typography: Typography6, Tooltip: Tooltip5, Button: Button2 } = window.antd);
      ({ Utilities: Utilities3, Libs: Libs8 } = window.getGenie.Components.Common);
      ({ GenieHelpers: GenieHelpers3 } = Utilities3);
      ({ ComposeComponents: ComposeComponents7 } = window.getGenie.Components.Common.ReduxManager);
      ({ useState: useState4 } = window.React);
      QuestionsAsked = ComposeComponents7(({ loading, loadingText, setInput, fetchData, getInputs, sidebar: sidebar4 }) => {
        const questionsAsked = getInputs["questionsAsked"];
        const selectedOutlines = getInputs["selectedOutlines"] || [];
        const [showTooltip, setShowTooltip] = useState4("");
        const [isInsertContent, setIsInsertContent] = useState4("");
        const onChange = (e, text) => {
          if (sidebar4.currentScreen !== "outlineScreen") {
            return;
          }
          let items = [...selectedOutlines];
          if (items.indexOf(text) != -1) {
            items.splice(items.indexOf(text), 1);
          } else {
            items.push(text);
          }
          setInput("selectedOutlines", items);
        };
        const insertContent = (e, content) => {
          e.stopPropagation();
          if (isInsertContent === content)
            return;
          if (window.getGenie.config.isBlockEditor) {
            let editor = wp.data.select("core/block-editor"), blocks = editor.getBlocks(), clientId = editor.getSelectedBlockClientId();
            let index2 = blocks.findIndex((item) => item.clientId === clientId);
            wp.data.dispatch("core/block-editor").insertBlocks(
              wp.blocks.createBlock("core/heading", {
                content
              }),
              index2 + 1
            );
            setIsInsertContent(content);
          }
          if (document.getElementById("post-body-content")) {
            let iframe = document.getElementById("content_ifr");
            let iframeWindow = iframe.contentDocument || iframe.contentWindow.document;
            let iframeSelectionElement = iframeWindow.getSelection().focusNode?.parentElement;
            let iframeCaretNode = iframeWindow.createElement("h2");
            iframeCaretNode.textContent = content;
            iframeSelectionElement.parentNode.insertBefore(iframeCaretNode, iframeSelectionElement.nextSibling);
            setIsInsertContent(content);
          }
          if (document.querySelector("#web-view-editor .ql-editor")) {
            let editor = document.querySelector("#web-view-editor .ql-editor");
            let caretNode = document.createElement("h2");
            caretNode.textContent = content;
            editor.appendChild(caretNode);
            setIsInsertContent(content);
          }
        };
        const copyContent = (e, content) => {
          e.stopPropagation();
          let copyAbleText = content.replace(/<br\s*\/?>/gi, "\n");
          GenieHelpers3.copyToClipboard(copyAbleText).then(() => {
            setShowTooltip(content);
          }).catch(() => console.log("error"));
        };
        return /* @__PURE__ */ React.createElement(React.Fragment, null, loading ? /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-loading-state"
        }, /* @__PURE__ */ React.createElement("span", null, loadingText), /* @__PURE__ */ React.createElement(Libs8.Loading, {
          size: 25
        }), " ") : questionsAsked ? "" : /* @__PURE__ */ React.createElement(Button2, {
          className: "getgenie-fetch-competitor-btn",
          onClick: fetchData
        }, sidebar4.__("Fetch Data", "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-questions-tab"
        }, /* @__PURE__ */ React.createElement("div", {
          className: `getgenie-checkbox ${sidebar4.currentScreen === "outlineScreen" ? "" : "disable"}`
        }, questionsAsked ? questionsAsked?.length === 0 ? /* @__PURE__ */ React.createElement(Typography6.Title, {
          level: 5,
          className: "getgenie-not-found-title"
        }, sidebar4.__("No questions are found.", "getgenie")) : questionsAsked?.map(
          (item, index2) => {
            let title = (item?.title || "").replace(/[0-9]/g, "");
            return /* @__PURE__ */ React.createElement("div", {
              key: index2,
              className: `getgenie-checkbox-container${selectedOutlines.indexOf(title) != -1 ? " active" : ""}`
            }, /* @__PURE__ */ React.createElement("div", {
              className: "actions"
            }, /* @__PURE__ */ React.createElement("div", {
              className: "copy"
            }, /* @__PURE__ */ React.createElement(Tooltip5, {
              placement: "bottom",
              zIndex: 9999,
              title: showTooltip === title ? "Copied" : "Copy this content"
            }, /* @__PURE__ */ React.createElement("span", {
              className: "copy-icon getgenie-icon-copy",
              onClick: (e) => copyContent(e, title)
            }))), /* @__PURE__ */ React.createElement("div", {
              className: "insert"
            }, /* @__PURE__ */ React.createElement(Tooltip5, {
              title: isInsertContent !== title ? "Insert into the editor" : "Already inserted",
              placement: "bottom",
              zIndex: 9999
            }, /* @__PURE__ */ React.createElement("span", {
              className: `insert-icon ${isInsertContent === title ? "getgenie-icon-check" : "getgenie-icon-insert"}`,
              onClick: (e) => insertContent(e, title)
            }))), /* @__PURE__ */ React.createElement("div", {
              className: "link"
            }, /* @__PURE__ */ React.createElement(Tooltip5, {
              title: "Go to the link",
              placement: "bottom",
              zIndex: 9999
            }, /* @__PURE__ */ React.createElement("a", {
              target: "_blank",
              href: item?.url
            }, /* @__PURE__ */ React.createElement("span", {
              className: "link-icon getgenie-icon-link"
            }))))), /* @__PURE__ */ React.createElement(Checkbox2, {
              checked: selectedOutlines.indexOf(item.title) > -1,
              onChange: (e) => onChange(e, item.title)
            }, /* @__PURE__ */ React.createElement("h4", {
              className: "question-title"
            }, title)));
          }
        ) : "")));
      }, ["setInput", "getInputs", "sidebar"]);
    }
  });

  // node_modules/engine.io-parser/build/esm/commons.js
  var PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET;
  var init_commons = __esm({
    "node_modules/engine.io-parser/build/esm/commons.js"() {
      PACKET_TYPES = /* @__PURE__ */ Object.create(null);
      PACKET_TYPES["open"] = "0";
      PACKET_TYPES["close"] = "1";
      PACKET_TYPES["ping"] = "2";
      PACKET_TYPES["pong"] = "3";
      PACKET_TYPES["message"] = "4";
      PACKET_TYPES["upgrade"] = "5";
      PACKET_TYPES["noop"] = "6";
      PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
      Object.keys(PACKET_TYPES).forEach((key) => {
        PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
      });
      ERROR_PACKET = { type: "error", data: "parser error" };
    }
  });

  // node_modules/engine.io-parser/build/esm/encodePacket.browser.js
  var withNativeBlob, withNativeArrayBuffer, isView, encodePacket, encodeBlobAsBase64, encodePacket_browser_default;
  var init_encodePacket_browser = __esm({
    "node_modules/engine.io-parser/build/esm/encodePacket.browser.js"() {
      init_commons();
      withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
      withNativeArrayBuffer = typeof ArrayBuffer === "function";
      isView = (obj) => {
        return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
      };
      encodePacket = ({ type, data }, supportsBinary, callback2) => {
        if (withNativeBlob && data instanceof Blob) {
          if (supportsBinary) {
            return callback2(data);
          } else {
            return encodeBlobAsBase64(data, callback2);
          }
        } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
          if (supportsBinary) {
            return callback2(data);
          } else {
            return encodeBlobAsBase64(new Blob([data]), callback2);
          }
        }
        return callback2(PACKET_TYPES[type] + (data || ""));
      };
      encodeBlobAsBase64 = (data, callback2) => {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const content = fileReader.result.split(",")[1];
          callback2("b" + content);
        };
        return fileReader.readAsDataURL(data);
      };
      encodePacket_browser_default = encodePacket;
    }
  });

  // node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
  var chars, lookup, decode;
  var init_base64_arraybuffer = __esm({
    "node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js"() {
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (let i2 = 0; i2 < chars.length; i2++) {
        lookup[chars.charCodeAt(i2)] = i2;
      }
      decode = (base64) => {
        let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
        const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
        for (i2 = 0; i2 < len; i2 += 4) {
          encoded1 = lookup[base64.charCodeAt(i2)];
          encoded2 = lookup[base64.charCodeAt(i2 + 1)];
          encoded3 = lookup[base64.charCodeAt(i2 + 2)];
          encoded4 = lookup[base64.charCodeAt(i2 + 3)];
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return arraybuffer;
      };
    }
  });

  // node_modules/engine.io-parser/build/esm/decodePacket.browser.js
  var withNativeArrayBuffer2, decodePacket, decodeBase64Packet, mapBinary, decodePacket_browser_default;
  var init_decodePacket_browser = __esm({
    "node_modules/engine.io-parser/build/esm/decodePacket.browser.js"() {
      init_commons();
      init_base64_arraybuffer();
      withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
      decodePacket = (encodedPacket, binaryType) => {
        if (typeof encodedPacket !== "string") {
          return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
          };
        }
        const type = encodedPacket.charAt(0);
        if (type === "b") {
          return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
          };
        }
        const packetType = PACKET_TYPES_REVERSE[type];
        if (!packetType) {
          return ERROR_PACKET;
        }
        return encodedPacket.length > 1 ? {
          type: PACKET_TYPES_REVERSE[type],
          data: encodedPacket.substring(1)
        } : {
          type: PACKET_TYPES_REVERSE[type]
        };
      };
      decodeBase64Packet = (data, binaryType) => {
        if (withNativeArrayBuffer2) {
          const decoded = decode(data);
          return mapBinary(decoded, binaryType);
        } else {
          return { base64: true, data };
        }
      };
      mapBinary = (data, binaryType) => {
        switch (binaryType) {
          case "blob":
            return data instanceof ArrayBuffer ? new Blob([data]) : data;
          case "arraybuffer":
          default:
            return data;
        }
      };
      decodePacket_browser_default = decodePacket;
    }
  });

  // node_modules/engine.io-parser/build/esm/index.js
  var SEPARATOR, encodePayload, decodePayload, protocol;
  var init_esm = __esm({
    "node_modules/engine.io-parser/build/esm/index.js"() {
      init_encodePacket_browser();
      init_decodePacket_browser();
      SEPARATOR = String.fromCharCode(30);
      encodePayload = (packets, callback2) => {
        const length2 = packets.length;
        const encodedPackets = new Array(length2);
        let count = 0;
        packets.forEach((packet, i2) => {
          encodePacket_browser_default(packet, false, (encodedPacket) => {
            encodedPackets[i2] = encodedPacket;
            if (++count === length2) {
              callback2(encodedPackets.join(SEPARATOR));
            }
          });
        });
      };
      decodePayload = (encodedPayload, binaryType) => {
        const encodedPackets = encodedPayload.split(SEPARATOR);
        const packets = [];
        for (let i2 = 0; i2 < encodedPackets.length; i2++) {
          const decodedPacket = decodePacket_browser_default(encodedPackets[i2], binaryType);
          packets.push(decodedPacket);
          if (decodedPacket.type === "error") {
            break;
          }
        }
        return packets;
      };
      protocol = 4;
    }
  });

  // node_modules/@socket.io/component-emitter/index.mjs
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  var init_component_emitter = __esm({
    "node_modules/@socket.io/component-emitter/index.mjs"() {
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        function on2() {
          this.off(event, on2);
          fn.apply(this, arguments);
        }
        on2.fn = fn;
        this.on(event, on2);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks["$" + event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks["$" + event];
          return this;
        }
        var cb;
        for (var i2 = 0; i2 < callbacks.length; i2++) {
          cb = callbacks[i2];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i2, 1);
            break;
          }
        }
        if (callbacks.length === 0) {
          delete this._callbacks["$" + event];
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
        for (var i2 = 1; i2 < arguments.length; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
            callbacks[i2].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.emitReserved = Emitter.prototype.emit;
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }
  });

  // node_modules/engine.io-client/build/esm/globalThis.browser.js
  var globalThisShim;
  var init_globalThis_browser = __esm({
    "node_modules/engine.io-client/build/esm/globalThis.browser.js"() {
      globalThisShim = (() => {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      })();
    }
  });

  // node_modules/engine.io-client/build/esm/util.js
  function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
      if (obj.hasOwnProperty(k)) {
        acc[k] = obj[k];
      }
      return acc;
    }, {});
  }
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
    } else {
      obj.setTimeoutFn = setTimeout.bind(globalThisShim);
      obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);
    }
  }
  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    }
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }
  function utf8Length(str) {
    let c = 0, length2 = 0;
    for (let i2 = 0, l = str.length; i2 < l; i2++) {
      c = str.charCodeAt(i2);
      if (c < 128) {
        length2 += 1;
      } else if (c < 2048) {
        length2 += 2;
      } else if (c < 55296 || c >= 57344) {
        length2 += 3;
      } else {
        i2++;
        length2 += 4;
      }
    }
    return length2;
  }
  var NATIVE_SET_TIMEOUT, NATIVE_CLEAR_TIMEOUT, BASE64_OVERHEAD;
  var init_util = __esm({
    "node_modules/engine.io-client/build/esm/util.js"() {
      init_globalThis_browser();
      NATIVE_SET_TIMEOUT = setTimeout;
      NATIVE_CLEAR_TIMEOUT = clearTimeout;
      BASE64_OVERHEAD = 1.33;
    }
  });

  // node_modules/engine.io-client/build/esm/transport.js
  var TransportError, Transport;
  var init_transport = __esm({
    "node_modules/engine.io-client/build/esm/transport.js"() {
      init_esm();
      init_component_emitter();
      init_util();
      TransportError = class extends Error {
        constructor(reason, description, context2) {
          super(reason);
          this.description = description;
          this.context = context2;
          this.type = "TransportError";
        }
      };
      Transport = class extends Emitter {
        constructor(opts) {
          super();
          this.writable = false;
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.query = opts.query;
          this.readyState = "";
          this.socket = opts.socket;
        }
        onError(reason, description, context2) {
          super.emitReserved("error", new TransportError(reason, description, context2));
          return this;
        }
        open() {
          if ("closed" === this.readyState || "" === this.readyState) {
            this.readyState = "opening";
            this.doOpen();
          }
          return this;
        }
        close() {
          if ("opening" === this.readyState || "open" === this.readyState) {
            this.doClose();
            this.onClose();
          }
          return this;
        }
        send(packets) {
          if ("open" === this.readyState) {
            this.write(packets);
          } else {
          }
        }
        onOpen() {
          this.readyState = "open";
          this.writable = true;
          super.emitReserved("open");
        }
        onData(data) {
          const packet = decodePacket_browser_default(data, this.socket.binaryType);
          this.onPacket(packet);
        }
        onPacket(packet) {
          super.emitReserved("packet", packet);
        }
        onClose(details) {
          this.readyState = "closed";
          super.emitReserved("close", details);
        }
      };
    }
  });

  // node_modules/engine.io-client/build/esm/contrib/yeast.js
  function encode(num) {
    let encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  function yeast() {
    const now = encode(+new Date());
    if (now !== prev)
      return seed = 0, prev = now;
    return now + "." + encode(seed++);
  }
  var alphabet, length, map2, seed, i, prev;
  var init_yeast = __esm({
    "node_modules/engine.io-client/build/esm/contrib/yeast.js"() {
      "use strict";
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
      length = 64;
      map2 = {};
      seed = 0;
      i = 0;
      for (; i < length; i++)
        map2[alphabet[i]] = i;
    }
  });

  // node_modules/engine.io-client/build/esm/contrib/parseqs.js
  function encode2(obj) {
    let str = "";
    for (let i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        if (str.length)
          str += "&";
        str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
      }
    }
    return str;
  }
  function decode2(qs) {
    let qry = {};
    let pairs = qs.split("&");
    for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
      let pair = pairs[i2].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  }
  var init_parseqs = __esm({
    "node_modules/engine.io-client/build/esm/contrib/parseqs.js"() {
    }
  });

  // node_modules/engine.io-client/build/esm/contrib/has-cors.js
  var value, hasCORS;
  var init_has_cors = __esm({
    "node_modules/engine.io-client/build/esm/contrib/has-cors.js"() {
      value = false;
      try {
        value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
      } catch (err) {
      }
      hasCORS = value;
    }
  });

  // node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
  function XHR(opts) {
    const xdomain = opts.xdomain;
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {
    }
    if (!xdomain) {
      try {
        return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
  }
  var init_xmlhttprequest_browser = __esm({
    "node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js"() {
      init_has_cors();
      init_globalThis_browser();
    }
  });

  // node_modules/engine.io-client/build/esm/transports/polling.js
  function empty() {
  }
  function unloadHandler() {
    for (let i2 in Request.requests) {
      if (Request.requests.hasOwnProperty(i2)) {
        Request.requests[i2].abort();
      }
    }
  }
  var hasXHR2, Polling, Request;
  var init_polling = __esm({
    "node_modules/engine.io-client/build/esm/transports/polling.js"() {
      init_transport();
      init_yeast();
      init_parseqs();
      init_esm();
      init_xmlhttprequest_browser();
      init_component_emitter();
      init_util();
      init_globalThis_browser();
      hasXHR2 = function() {
        const xhr = new XHR({
          xdomain: false
        });
        return null != xhr.responseType;
      }();
      Polling = class extends Transport {
        constructor(opts) {
          super(opts);
          this.polling = false;
          if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            if (!port) {
              port = isSSL ? "443" : "80";
            }
            this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
            this.xs = opts.secure !== isSSL;
          }
          const forceBase64 = opts && opts.forceBase64;
          this.supportsBinary = hasXHR2 && !forceBase64;
        }
        get name() {
          return "polling";
        }
        doOpen() {
          this.poll();
        }
        pause(onPause) {
          this.readyState = "pausing";
          const pause = () => {
            this.readyState = "paused";
            onPause();
          };
          if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
              total++;
              this.once("pollComplete", function() {
                --total || pause();
              });
            }
            if (!this.writable) {
              total++;
              this.once("drain", function() {
                --total || pause();
              });
            }
          } else {
            pause();
          }
        }
        poll() {
          this.polling = true;
          this.doPoll();
          this.emitReserved("poll");
        }
        onData(data) {
          const callback2 = (packet) => {
            if ("opening" === this.readyState && packet.type === "open") {
              this.onOpen();
            }
            if ("close" === packet.type) {
              this.onClose({ description: "transport closed by the server" });
              return false;
            }
            this.onPacket(packet);
          };
          decodePayload(data, this.socket.binaryType).forEach(callback2);
          if ("closed" !== this.readyState) {
            this.polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
              this.poll();
            } else {
            }
          }
        }
        doClose() {
          const close = () => {
            this.write([{ type: "close" }]);
          };
          if ("open" === this.readyState) {
            close();
          } else {
            this.once("open", close);
          }
        }
        write(packets) {
          this.writable = false;
          encodePayload(packets, (data) => {
            this.doWrite(data, () => {
              this.writable = true;
              this.emitReserved("drain");
            });
          });
        }
        uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "https" : "http";
          let port = "";
          if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast();
          }
          if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
          }
          if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
            port = ":" + this.opts.port;
          }
          const encodedQuery = encode2(query);
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
        }
        request(opts = {}) {
          Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
          return new Request(this.uri(), opts);
        }
        doWrite(data, fn) {
          const req = this.request({
            method: "POST",
            data
          });
          req.on("success", fn);
          req.on("error", (xhrStatus, context2) => {
            this.onError("xhr post error", xhrStatus, context2);
          });
        }
        doPoll() {
          const req = this.request();
          req.on("data", this.onData.bind(this));
          req.on("error", (xhrStatus, context2) => {
            this.onError("xhr poll error", xhrStatus, context2);
          });
          this.pollXhr = req;
        }
      };
      Request = class extends Emitter {
        constructor(uri, opts) {
          super();
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.method = opts.method || "GET";
          this.uri = uri;
          this.async = false !== opts.async;
          this.data = void 0 !== opts.data ? opts.data : null;
          this.create();
        }
        create() {
          const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
          opts.xdomain = !!this.opts.xd;
          opts.xscheme = !!this.opts.xs;
          const xhr = this.xhr = new XHR(opts);
          try {
            xhr.open(this.method, this.uri, this.async);
            try {
              if (this.opts.extraHeaders) {
                xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                for (let i2 in this.opts.extraHeaders) {
                  if (this.opts.extraHeaders.hasOwnProperty(i2)) {
                    xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
                  }
                }
              }
            } catch (e) {
            }
            if ("POST" === this.method) {
              try {
                xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
              } catch (e) {
              }
            }
            try {
              xhr.setRequestHeader("Accept", "*/*");
            } catch (e) {
            }
            if ("withCredentials" in xhr) {
              xhr.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
              xhr.timeout = this.opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
              if (4 !== xhr.readyState)
                return;
              if (200 === xhr.status || 1223 === xhr.status) {
                this.onLoad();
              } else {
                this.setTimeoutFn(() => {
                  this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                }, 0);
              }
            };
            xhr.send(this.data);
          } catch (e) {
            this.setTimeoutFn(() => {
              this.onError(e);
            }, 0);
            return;
          }
          if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
          }
        }
        onError(err) {
          this.emitReserved("error", err, this.xhr);
          this.cleanup(true);
        }
        cleanup(fromError) {
          if ("undefined" === typeof this.xhr || null === this.xhr) {
            return;
          }
          this.xhr.onreadystatechange = empty;
          if (fromError) {
            try {
              this.xhr.abort();
            } catch (e) {
            }
          }
          if (typeof document !== "undefined") {
            delete Request.requests[this.index];
          }
          this.xhr = null;
        }
        onLoad() {
          const data = this.xhr.responseText;
          if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this.cleanup();
          }
        }
        abort() {
          this.cleanup();
        }
      };
      Request.requestsCount = 0;
      Request.requests = {};
      if (typeof document !== "undefined") {
        if (typeof attachEvent === "function") {
          attachEvent("onunload", unloadHandler);
        } else if (typeof addEventListener === "function") {
          const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
          addEventListener(terminationEvent, unloadHandler, false);
        }
      }
    }
  });

  // node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
  var nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType;
  var init_websocket_constructor_browser = __esm({
    "node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js"() {
      init_globalThis_browser();
      nextTick = (() => {
        const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
        if (isPromiseAvailable) {
          return (cb) => Promise.resolve().then(cb);
        } else {
          return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
        }
      })();
      WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
      usingBrowserWebSocket = true;
      defaultBinaryType = "arraybuffer";
    }
  });

  // node_modules/engine.io-client/build/esm/transports/websocket.js
  var isReactNative, WS;
  var init_websocket = __esm({
    "node_modules/engine.io-client/build/esm/transports/websocket.js"() {
      init_transport();
      init_parseqs();
      init_yeast();
      init_util();
      init_websocket_constructor_browser();
      init_esm();
      isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
      WS = class extends Transport {
        constructor(opts) {
          super(opts);
          this.supportsBinary = !opts.forceBase64;
        }
        get name() {
          return "websocket";
        }
        doOpen() {
          if (!this.check()) {
            return;
          }
          const uri = this.uri();
          const protocols = this.opts.protocols;
          const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
          if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
          }
          try {
            this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
          } catch (err) {
            return this.emitReserved("error", err);
          }
          this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
          this.addEventListeners();
        }
        addEventListeners() {
          this.ws.onopen = () => {
            if (this.opts.autoUnref) {
              this.ws._socket.unref();
            }
            this.onOpen();
          };
          this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent
          });
          this.ws.onmessage = (ev) => this.onData(ev.data);
          this.ws.onerror = (e) => this.onError("websocket error", e);
        }
        write(packets) {
          this.writable = false;
          for (let i2 = 0; i2 < packets.length; i2++) {
            const packet = packets[i2];
            const lastPacket = i2 === packets.length - 1;
            encodePacket_browser_default(packet, this.supportsBinary, (data) => {
              const opts = {};
              if (!usingBrowserWebSocket) {
                if (packet.options) {
                  opts.compress = packet.options.compress;
                }
                if (this.opts.perMessageDeflate) {
                  const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                  if (len < this.opts.perMessageDeflate.threshold) {
                    opts.compress = false;
                  }
                }
              }
              try {
                if (usingBrowserWebSocket) {
                  this.ws.send(data);
                } else {
                  this.ws.send(data, opts);
                }
              } catch (e) {
              }
              if (lastPacket) {
                nextTick(() => {
                  this.writable = true;
                  this.emitReserved("drain");
                }, this.setTimeoutFn);
              }
            });
          }
        }
        doClose() {
          if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
          }
        }
        uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "wss" : "ws";
          let port = "";
          if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
            port = ":" + this.opts.port;
          }
          if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast();
          }
          if (!this.supportsBinary) {
            query.b64 = 1;
          }
          const encodedQuery = encode2(query);
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
        }
        check() {
          return !!WebSocket;
        }
      };
    }
  });

  // node_modules/engine.io-client/build/esm/transports/index.js
  var transports;
  var init_transports = __esm({
    "node_modules/engine.io-client/build/esm/transports/index.js"() {
      init_polling();
      init_websocket();
      transports = {
        websocket: WS,
        polling: Polling
      };
    }
  });

  // node_modules/engine.io-client/build/esm/contrib/parseuri.js
  function parse2(str) {
    const src = str, b = str.indexOf("["), e = str.indexOf("]");
    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
    }
    let m = re.exec(str || ""), uri = {}, i2 = 14;
    while (i2--) {
      uri[parts[i2]] = m[i2] || "";
    }
    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  }
  function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names2 = path.replace(regx, "/").split("/");
    if (path.substr(0, 1) == "/" || path.length === 0) {
      names2.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == "/") {
      names2.splice(names2.length - 1, 1);
    }
    return names2;
  }
  function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }
  var re, parts;
  var init_parseuri = __esm({
    "node_modules/engine.io-client/build/esm/contrib/parseuri.js"() {
      re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      parts = [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ];
    }
  });

  // node_modules/engine.io-client/build/esm/socket.js
  var Socket;
  var init_socket = __esm({
    "node_modules/engine.io-client/build/esm/socket.js"() {
      init_transports();
      init_util();
      init_parseqs();
      init_parseuri();
      init_component_emitter();
      init_esm();
      Socket = class extends Emitter {
        constructor(uri, opts = {}) {
          super();
          if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
          }
          if (uri) {
            uri = parse2(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
              opts.query = uri.query;
          } else if (opts.host) {
            opts.hostname = parse2(opts.host).host;
          }
          installTimerFunctions(this, opts);
          this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
          if (opts.hostname && !opts.port) {
            opts.port = this.secure ? "443" : "80";
          }
          this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
          this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
          this.transports = opts.transports || ["polling", "websocket"];
          this.readyState = "";
          this.writeBuffer = [];
          this.prevBufferLen = 0;
          this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            rejectUnauthorized: true,
            perMessageDeflate: {
              threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: true
          }, opts);
          this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
          if (typeof this.opts.query === "string") {
            this.opts.query = decode2(this.opts.query);
          }
          this.id = null;
          this.upgrades = null;
          this.pingInterval = null;
          this.pingTimeout = null;
          this.pingTimeoutTimer = null;
          if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
              addEventListener("beforeunload", () => {
                if (this.transport) {
                  this.transport.removeAllListeners();
                  this.transport.close();
                }
              }, false);
            }
            if (this.hostname !== "localhost") {
              this.offlineEventListener = () => {
                this.onClose("transport close", {
                  description: "network connection lost"
                });
              };
              addEventListener("offline", this.offlineEventListener, false);
            }
          }
          this.open();
        }
        createTransport(name) {
          const query = Object.assign({}, this.opts.query);
          query.EIO = protocol;
          query.transport = name;
          if (this.id)
            query.sid = this.id;
          const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
          });
          return new transports[name](opts);
        }
        open() {
          let transport;
          if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
          } else if (0 === this.transports.length) {
            this.setTimeoutFn(() => {
              this.emitReserved("error", "No transports available");
            }, 0);
            return;
          } else {
            transport = this.transports[0];
          }
          this.readyState = "opening";
          try {
            transport = this.createTransport(transport);
          } catch (e) {
            this.transports.shift();
            this.open();
            return;
          }
          transport.open();
          this.setTransport(transport);
        }
        setTransport(transport) {
          if (this.transport) {
            this.transport.removeAllListeners();
          }
          this.transport = transport;
          transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
        }
        probe(name) {
          let transport = this.createTransport(name);
          let failed = false;
          Socket.priorWebsocketSuccess = false;
          const onTransportOpen = () => {
            if (failed)
              return;
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
              if (failed)
                return;
              if ("pong" === msg.type && "probe" === msg.data) {
                this.upgrading = true;
                this.emitReserved("upgrading", transport);
                if (!transport)
                  return;
                Socket.priorWebsocketSuccess = "websocket" === transport.name;
                this.transport.pause(() => {
                  if (failed)
                    return;
                  if ("closed" === this.readyState)
                    return;
                  cleanup();
                  this.setTransport(transport);
                  transport.send([{ type: "upgrade" }]);
                  this.emitReserved("upgrade", transport);
                  transport = null;
                  this.upgrading = false;
                  this.flush();
                });
              } else {
                const err = new Error("probe error");
                err.transport = transport.name;
                this.emitReserved("upgradeError", err);
              }
            });
          };
          function freezeTransport() {
            if (failed)
              return;
            failed = true;
            cleanup();
            transport.close();
            transport = null;
          }
          const onerror = (err) => {
            const error = new Error("probe error: " + err);
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
          };
          function onTransportClose() {
            onerror("transport closed");
          }
          function onclose() {
            onerror("socket closed");
          }
          function onupgrade(to2) {
            if (transport && to2.name !== transport.name) {
              freezeTransport();
            }
          }
          const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
          };
          transport.once("open", onTransportOpen);
          transport.once("error", onerror);
          transport.once("close", onTransportClose);
          this.once("close", onclose);
          this.once("upgrading", onupgrade);
          transport.open();
        }
        onOpen() {
          this.readyState = "open";
          Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
          this.emitReserved("open");
          this.flush();
          if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
            let i2 = 0;
            const l = this.upgrades.length;
            for (; i2 < l; i2++) {
              this.probe(this.upgrades[i2]);
            }
          }
        }
        onPacket(packet) {
          if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            this.emitReserved("heartbeat");
            switch (packet.type) {
              case "open":
                this.onHandshake(JSON.parse(packet.data));
                break;
              case "ping":
                this.resetPingTimeout();
                this.sendPacket("pong");
                this.emitReserved("ping");
                this.emitReserved("pong");
                break;
              case "error":
                const err = new Error("server error");
                err.code = packet.data;
                this.onError(err);
                break;
              case "message":
                this.emitReserved("data", packet.data);
                this.emitReserved("message", packet.data);
                break;
            }
          } else {
          }
        }
        onHandshake(data) {
          this.emitReserved("handshake", data);
          this.id = data.sid;
          this.transport.query.sid = data.sid;
          this.upgrades = this.filterUpgrades(data.upgrades);
          this.pingInterval = data.pingInterval;
          this.pingTimeout = data.pingTimeout;
          this.maxPayload = data.maxPayload;
          this.onOpen();
          if ("closed" === this.readyState)
            return;
          this.resetPingTimeout();
        }
        resetPingTimeout() {
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
          }, this.pingInterval + this.pingTimeout);
          if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
          }
        }
        onDrain() {
          this.writeBuffer.splice(0, this.prevBufferLen);
          this.prevBufferLen = 0;
          if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
          } else {
            this.flush();
          }
        }
        flush() {
          if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const packets = this.getWritablePackets();
            this.transport.send(packets);
            this.prevBufferLen = packets.length;
            this.emitReserved("flush");
          }
        }
        getWritablePackets() {
          const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
          if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
          }
          let payloadSize = 1;
          for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
            const data = this.writeBuffer[i2].data;
            if (data) {
              payloadSize += byteLength(data);
            }
            if (i2 > 0 && payloadSize > this.maxPayload) {
              return this.writeBuffer.slice(0, i2);
            }
            payloadSize += 2;
          }
          return this.writeBuffer;
        }
        write(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
        }
        send(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
        }
        sendPacket(type, data, options, fn) {
          if ("function" === typeof data) {
            fn = data;
            data = void 0;
          }
          if ("function" === typeof options) {
            fn = options;
            options = null;
          }
          if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
          }
          options = options || {};
          options.compress = false !== options.compress;
          const packet = {
            type,
            data,
            options
          };
          this.emitReserved("packetCreate", packet);
          this.writeBuffer.push(packet);
          if (fn)
            this.once("flush", fn);
          this.flush();
        }
        close() {
          const close = () => {
            this.onClose("forced close");
            this.transport.close();
          };
          const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
          };
          const waitForUpgrade = () => {
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
          };
          if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
              this.once("drain", () => {
                if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              });
            } else if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          }
          return this;
        }
        onError(err) {
          Socket.priorWebsocketSuccess = false;
          this.emitReserved("error", err);
          this.onClose("transport error", err);
        }
        onClose(reason, description) {
          if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            this.clearTimeoutFn(this.pingTimeoutTimer);
            this.transport.removeAllListeners("close");
            this.transport.close();
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
              removeEventListener("offline", this.offlineEventListener, false);
            }
            this.readyState = "closed";
            this.id = null;
            this.emitReserved("close", reason, description);
            this.writeBuffer = [];
            this.prevBufferLen = 0;
          }
        }
        filterUpgrades(upgrades) {
          const filteredUpgrades = [];
          let i2 = 0;
          const j = upgrades.length;
          for (; i2 < j; i2++) {
            if (~this.transports.indexOf(upgrades[i2]))
              filteredUpgrades.push(upgrades[i2]);
          }
          return filteredUpgrades;
        }
      };
      Socket.protocol = protocol;
    }
  });

  // node_modules/engine.io-client/build/esm/index.js
  var protocol2;
  var init_esm2 = __esm({
    "node_modules/engine.io-client/build/esm/index.js"() {
      init_socket();
      init_transport();
      init_transports();
      init_util();
      init_parseuri();
      protocol2 = Socket.protocol;
    }
  });

  // node_modules/socket.io-client/build/esm/url.js
  function url(uri, path = "", loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      obj = parse2(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  var init_url = __esm({
    "node_modules/socket.io-client/build/esm/url.js"() {
      init_esm2();
    }
  });

  // node_modules/socket.io-parser/build/esm/is-binary.js
  function isBinary(obj) {
    return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i2 = 0, l = obj.length; i2 < l; i2++) {
        if (hasBinary(obj[i2])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  var withNativeArrayBuffer3, isView2, toString, withNativeBlob2, withNativeFile;
  var init_is_binary = __esm({
    "node_modules/socket.io-parser/build/esm/is-binary.js"() {
      withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
      isView2 = (obj) => {
        return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
      };
      toString = Object.prototype.toString;
      withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
      withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    }
  });

  // node_modules/socket.io-parser/build/esm/binary.js
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  }
  function _deconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (isBinary(data)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i2 = 0; i2 < data.length; i2++) {
        newData[i2] = _deconstructPacket(data[i2], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = void 0;
    return packet;
  }
  function _reconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder === true) {
      const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = _reconstructPacket(data[i2], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }
  var init_binary = __esm({
    "node_modules/socket.io-parser/build/esm/binary.js"() {
      init_is_binary();
    }
  });

  // node_modules/socket.io-parser/build/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Decoder: () => Decoder,
    Encoder: () => Encoder,
    PacketType: () => PacketType,
    protocol: () => protocol3
  });
  var protocol3, PacketType, Encoder, Decoder, BinaryReconstructor;
  var init_esm3 = __esm({
    "node_modules/socket.io-parser/build/esm/index.js"() {
      init_component_emitter();
      init_binary();
      init_is_binary();
      protocol3 = 5;
      (function(PacketType2) {
        PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
        PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
        PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
        PacketType2[PacketType2["ACK"] = 3] = "ACK";
        PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
        PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
        PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
      })(PacketType || (PacketType = {}));
      Encoder = class {
        constructor(replacer) {
          this.replacer = replacer;
        }
        encode(obj) {
          if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (hasBinary(obj)) {
              obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
              return this.encodeAsBinary(obj);
            }
          }
          return [this.encodeAsString(obj)];
        }
        encodeAsString(obj) {
          let str = "" + obj.type;
          if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
          }
          if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
          }
          if (null != obj.id) {
            str += obj.id;
          }
          if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
          }
          return str;
        }
        encodeAsBinary(obj) {
          const deconstruction = deconstructPacket(obj);
          const pack = this.encodeAsString(deconstruction.packet);
          const buffers = deconstruction.buffers;
          buffers.unshift(pack);
          return buffers;
        }
      };
      Decoder = class extends Emitter {
        constructor(reviver) {
          super();
          this.reviver = reviver;
        }
        add(obj) {
          let packet;
          if (typeof obj === "string") {
            if (this.reconstructor) {
              throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
              this.reconstructor = new BinaryReconstructor(packet);
              if (packet.attachments === 0) {
                super.emitReserved("decoded", packet);
              }
            } else {
              super.emitReserved("decoded", packet);
            }
          } else if (isBinary(obj) || obj.base64) {
            if (!this.reconstructor) {
              throw new Error("got binary data when not reconstructing a packet");
            } else {
              packet = this.reconstructor.takeBinaryData(obj);
              if (packet) {
                this.reconstructor = null;
                super.emitReserved("decoded", packet);
              }
            }
          } else {
            throw new Error("Unknown type: " + obj);
          }
        }
        decodeString(str) {
          let i2 = 0;
          const p = {
            type: Number(str.charAt(0))
          };
          if (PacketType[p.type] === void 0) {
            throw new Error("unknown packet type " + p.type);
          }
          if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
            const start = i2 + 1;
            while (str.charAt(++i2) !== "-" && i2 != str.length) {
            }
            const buf = str.substring(start, i2);
            if (buf != Number(buf) || str.charAt(i2) !== "-") {
              throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
          }
          if ("/" === str.charAt(i2 + 1)) {
            const start = i2 + 1;
            while (++i2) {
              const c = str.charAt(i2);
              if ("," === c)
                break;
              if (i2 === str.length)
                break;
            }
            p.nsp = str.substring(start, i2);
          } else {
            p.nsp = "/";
          }
          const next = str.charAt(i2 + 1);
          if ("" !== next && Number(next) == next) {
            const start = i2 + 1;
            while (++i2) {
              const c = str.charAt(i2);
              if (null == c || Number(c) != c) {
                --i2;
                break;
              }
              if (i2 === str.length)
                break;
            }
            p.id = Number(str.substring(start, i2 + 1));
          }
          if (str.charAt(++i2)) {
            const payload = this.tryParse(str.substr(i2));
            if (Decoder.isPayloadValid(p.type, payload)) {
              p.data = payload;
            } else {
              throw new Error("invalid payload");
            }
          }
          return p;
        }
        tryParse(str) {
          try {
            return JSON.parse(str, this.reviver);
          } catch (e) {
            return false;
          }
        }
        static isPayloadValid(type, payload) {
          switch (type) {
            case PacketType.CONNECT:
              return typeof payload === "object";
            case PacketType.DISCONNECT:
              return payload === void 0;
            case PacketType.CONNECT_ERROR:
              return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
              return Array.isArray(payload) && payload.length > 0;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
              return Array.isArray(payload);
          }
        }
        destroy() {
          if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
          }
        }
      };
      BinaryReconstructor = class {
        constructor(packet) {
          this.packet = packet;
          this.buffers = [];
          this.reconPack = packet;
        }
        takeBinaryData(binData) {
          this.buffers.push(binData);
          if (this.buffers.length === this.reconPack.attachments) {
            const packet = reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
          }
          return null;
        }
        finishedReconstruction() {
          this.reconPack = null;
          this.buffers = [];
        }
      };
    }
  });

  // node_modules/socket.io-client/build/esm/on.js
  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }
  var init_on = __esm({
    "node_modules/socket.io-client/build/esm/on.js"() {
    }
  });

  // node_modules/socket.io-client/build/esm/socket.js
  var RESERVED_EVENTS, Socket2;
  var init_socket2 = __esm({
    "node_modules/socket.io-client/build/esm/socket.js"() {
      init_esm3();
      init_on();
      init_component_emitter();
      RESERVED_EVENTS = Object.freeze({
        connect: 1,
        connect_error: 1,
        disconnect: 1,
        disconnecting: 1,
        newListener: 1,
        removeListener: 1
      });
      Socket2 = class extends Emitter {
        constructor(io, nsp, opts) {
          super();
          this.connected = false;
          this.receiveBuffer = [];
          this.sendBuffer = [];
          this.ids = 0;
          this.acks = {};
          this.flags = {};
          this.io = io;
          this.nsp = nsp;
          if (opts && opts.auth) {
            this.auth = opts.auth;
          }
          if (this.io._autoConnect)
            this.open();
        }
        get disconnected() {
          return !this.connected;
        }
        subEvents() {
          if (this.subs)
            return;
          const io = this.io;
          this.subs = [
            on(io, "open", this.onopen.bind(this)),
            on(io, "packet", this.onpacket.bind(this)),
            on(io, "error", this.onerror.bind(this)),
            on(io, "close", this.onclose.bind(this))
          ];
        }
        get active() {
          return !!this.subs;
        }
        connect() {
          if (this.connected)
            return this;
          this.subEvents();
          if (!this.io["_reconnecting"])
            this.io.open();
          if ("open" === this.io._readyState)
            this.onopen();
          return this;
        }
        open() {
          return this.connect();
        }
        send(...args) {
          args.unshift("message");
          this.emit.apply(this, args);
          return this;
        }
        emit(ev, ...args) {
          if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev + '" is a reserved event name');
          }
          args.unshift(ev);
          const packet = {
            type: PacketType.EVENT,
            data: args
          };
          packet.options = {};
          packet.options.compress = this.flags.compress !== false;
          if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
          }
          const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
          const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
          if (discardPacket) {
          } else if (this.connected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
          } else {
            this.sendBuffer.push(packet);
          }
          this.flags = {};
          return this;
        }
        _registerAckCallback(id, ack) {
          const timeout = this.flags.timeout;
          if (timeout === void 0) {
            this.acks[id] = ack;
            return;
          }
          const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
              if (this.sendBuffer[i2].id === id) {
                this.sendBuffer.splice(i2, 1);
              }
            }
            ack.call(this, new Error("operation has timed out"));
          }, timeout);
          this.acks[id] = (...args) => {
            this.io.clearTimeoutFn(timer);
            ack.apply(this, [null, ...args]);
          };
        }
        packet(packet) {
          packet.nsp = this.nsp;
          this.io._packet(packet);
        }
        onopen() {
          if (typeof this.auth == "function") {
            this.auth((data) => {
              this.packet({ type: PacketType.CONNECT, data });
            });
          } else {
            this.packet({ type: PacketType.CONNECT, data: this.auth });
          }
        }
        onerror(err) {
          if (!this.connected) {
            this.emitReserved("connect_error", err);
          }
        }
        onclose(reason, description) {
          this.connected = false;
          delete this.id;
          this.emitReserved("disconnect", reason, description);
        }
        onpacket(packet) {
          const sameNamespace = packet.nsp === this.nsp;
          if (!sameNamespace)
            return;
          switch (packet.type) {
            case PacketType.CONNECT:
              if (packet.data && packet.data.sid) {
                const id = packet.data.sid;
                this.onconnect(id);
              } else {
                this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
              }
              break;
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
              this.onevent(packet);
              break;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
              this.onack(packet);
              break;
            case PacketType.DISCONNECT:
              this.ondisconnect();
              break;
            case PacketType.CONNECT_ERROR:
              this.destroy();
              const err = new Error(packet.data.message);
              err.data = packet.data.data;
              this.emitReserved("connect_error", err);
              break;
          }
        }
        onevent(packet) {
          const args = packet.data || [];
          if (null != packet.id) {
            args.push(this.ack(packet.id));
          }
          if (this.connected) {
            this.emitEvent(args);
          } else {
            this.receiveBuffer.push(Object.freeze(args));
          }
        }
        emitEvent(args) {
          if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
              listener.apply(this, args);
            }
          }
          super.emit.apply(this, args);
        }
        ack(id) {
          const self2 = this;
          let sent = false;
          return function(...args) {
            if (sent)
              return;
            sent = true;
            self2.packet({
              type: PacketType.ACK,
              id,
              data: args
            });
          };
        }
        onack(packet) {
          const ack = this.acks[packet.id];
          if ("function" === typeof ack) {
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
          } else {
          }
        }
        onconnect(id) {
          this.id = id;
          this.connected = true;
          this.emitBuffered();
          this.emitReserved("connect");
        }
        emitBuffered() {
          this.receiveBuffer.forEach((args) => this.emitEvent(args));
          this.receiveBuffer = [];
          this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
          });
          this.sendBuffer = [];
        }
        ondisconnect() {
          this.destroy();
          this.onclose("io server disconnect");
        }
        destroy() {
          if (this.subs) {
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = void 0;
          }
          this.io["_destroy"](this);
        }
        disconnect() {
          if (this.connected) {
            this.packet({ type: PacketType.DISCONNECT });
          }
          this.destroy();
          if (this.connected) {
            this.onclose("io client disconnect");
          }
          return this;
        }
        close() {
          return this.disconnect();
        }
        compress(compress) {
          this.flags.compress = compress;
          return this;
        }
        get volatile() {
          this.flags.volatile = true;
          return this;
        }
        timeout(timeout) {
          this.flags.timeout = timeout;
          return this;
        }
        onAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.push(listener);
          return this;
        }
        prependAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.unshift(listener);
          return this;
        }
        offAny(listener) {
          if (!this._anyListeners) {
            return this;
          }
          if (listener) {
            const listeners = this._anyListeners;
            for (let i2 = 0; i2 < listeners.length; i2++) {
              if (listener === listeners[i2]) {
                listeners.splice(i2, 1);
                return this;
              }
            }
          } else {
            this._anyListeners = [];
          }
          return this;
        }
        listenersAny() {
          return this._anyListeners || [];
        }
        onAnyOutgoing(listener) {
          this._anyOutgoingListeners = this._anyOutgoingListeners || [];
          this._anyOutgoingListeners.push(listener);
          return this;
        }
        prependAnyOutgoing(listener) {
          this._anyOutgoingListeners = this._anyOutgoingListeners || [];
          this._anyOutgoingListeners.unshift(listener);
          return this;
        }
        offAnyOutgoing(listener) {
          if (!this._anyOutgoingListeners) {
            return this;
          }
          if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i2 = 0; i2 < listeners.length; i2++) {
              if (listener === listeners[i2]) {
                listeners.splice(i2, 1);
                return this;
              }
            }
          } else {
            this._anyOutgoingListeners = [];
          }
          return this;
        }
        listenersAnyOutgoing() {
          return this._anyOutgoingListeners || [];
        }
        notifyOutgoingListeners(packet) {
          if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
              listener.apply(this, packet.data);
            }
          }
        }
      };
    }
  });

  // node_modules/socket.io-client/build/esm/contrib/backo2.js
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  var init_backo2 = __esm({
    "node_modules/socket.io-client/build/esm/contrib/backo2.js"() {
      Backoff.prototype.duration = function() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      };
      Backoff.prototype.reset = function() {
        this.attempts = 0;
      };
      Backoff.prototype.setMin = function(min) {
        this.ms = min;
      };
      Backoff.prototype.setMax = function(max) {
        this.max = max;
      };
      Backoff.prototype.setJitter = function(jitter) {
        this.jitter = jitter;
      };
    }
  });

  // node_modules/socket.io-client/build/esm/manager.js
  var Manager;
  var init_manager = __esm({
    "node_modules/socket.io-client/build/esm/manager.js"() {
      init_esm2();
      init_socket2();
      init_esm3();
      init_on();
      init_backo2();
      init_component_emitter();
      Manager = class extends Emitter {
        constructor(uri, opts) {
          var _a;
          super();
          this.nsps = {};
          this.subs = [];
          if (uri && "object" === typeof uri) {
            opts = uri;
            uri = void 0;
          }
          opts = opts || {};
          opts.path = opts.path || "/socket.io";
          this.opts = opts;
          installTimerFunctions(this, opts);
          this.reconnection(opts.reconnection !== false);
          this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
          this.reconnectionDelay(opts.reconnectionDelay || 1e3);
          this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
          this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
          this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          });
          this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
          this._readyState = "closed";
          this.uri = uri;
          const _parser = opts.parser || esm_exports;
          this.encoder = new _parser.Encoder();
          this.decoder = new _parser.Decoder();
          this._autoConnect = opts.autoConnect !== false;
          if (this._autoConnect)
            this.open();
        }
        reconnection(v) {
          if (!arguments.length)
            return this._reconnection;
          this._reconnection = !!v;
          return this;
        }
        reconnectionAttempts(v) {
          if (v === void 0)
            return this._reconnectionAttempts;
          this._reconnectionAttempts = v;
          return this;
        }
        reconnectionDelay(v) {
          var _a;
          if (v === void 0)
            return this._reconnectionDelay;
          this._reconnectionDelay = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
          return this;
        }
        randomizationFactor(v) {
          var _a;
          if (v === void 0)
            return this._randomizationFactor;
          this._randomizationFactor = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
          return this;
        }
        reconnectionDelayMax(v) {
          var _a;
          if (v === void 0)
            return this._reconnectionDelayMax;
          this._reconnectionDelayMax = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
          return this;
        }
        timeout(v) {
          if (!arguments.length)
            return this._timeout;
          this._timeout = v;
          return this;
        }
        maybeReconnectOnOpen() {
          if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
            this.reconnect();
          }
        }
        open(fn) {
          if (~this._readyState.indexOf("open"))
            return this;
          this.engine = new Socket(this.uri, this.opts);
          const socket = this.engine;
          const self2 = this;
          this._readyState = "opening";
          this.skipReconnect = false;
          const openSubDestroy = on(socket, "open", function() {
            self2.onopen();
            fn && fn();
          });
          const errorSub = on(socket, "error", (err) => {
            self2.cleanup();
            self2._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
              fn(err);
            } else {
              self2.maybeReconnectOnOpen();
            }
          });
          if (false !== this._timeout) {
            const timeout = this._timeout;
            if (timeout === 0) {
              openSubDestroy();
            }
            const timer = this.setTimeoutFn(() => {
              openSubDestroy();
              socket.close();
              socket.emit("error", new Error("timeout"));
            }, timeout);
            if (this.opts.autoUnref) {
              timer.unref();
            }
            this.subs.push(function subDestroy() {
              clearTimeout(timer);
            });
          }
          this.subs.push(openSubDestroy);
          this.subs.push(errorSub);
          return this;
        }
        connect(fn) {
          return this.open(fn);
        }
        onopen() {
          this.cleanup();
          this._readyState = "open";
          this.emitReserved("open");
          const socket = this.engine;
          this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
        }
        onping() {
          this.emitReserved("ping");
        }
        ondata(data) {
          this.decoder.add(data);
        }
        ondecoded(packet) {
          this.emitReserved("packet", packet);
        }
        onerror(err) {
          this.emitReserved("error", err);
        }
        socket(nsp, opts) {
          let socket = this.nsps[nsp];
          if (!socket) {
            socket = new Socket2(this, nsp, opts);
            this.nsps[nsp] = socket;
          }
          return socket;
        }
        _destroy(socket) {
          const nsps = Object.keys(this.nsps);
          for (const nsp of nsps) {
            const socket2 = this.nsps[nsp];
            if (socket2.active) {
              return;
            }
          }
          this._close();
        }
        _packet(packet) {
          const encodedPackets = this.encoder.encode(packet);
          for (let i2 = 0; i2 < encodedPackets.length; i2++) {
            this.engine.write(encodedPackets[i2], packet.options);
          }
        }
        cleanup() {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs.length = 0;
          this.decoder.destroy();
        }
        _close() {
          this.skipReconnect = true;
          this._reconnecting = false;
          this.onclose("forced close");
          if (this.engine)
            this.engine.close();
        }
        disconnect() {
          return this._close();
        }
        onclose(reason, description) {
          this.cleanup();
          this.backoff.reset();
          this._readyState = "closed";
          this.emitReserved("close", reason, description);
          if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
          }
        }
        reconnect() {
          if (this._reconnecting || this.skipReconnect)
            return this;
          const self2 = this;
          if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
          } else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
              if (self2.skipReconnect)
                return;
              this.emitReserved("reconnect_attempt", self2.backoff.attempts);
              if (self2.skipReconnect)
                return;
              self2.open((err) => {
                if (err) {
                  self2._reconnecting = false;
                  self2.reconnect();
                  this.emitReserved("reconnect_error", err);
                } else {
                  self2.onreconnect();
                }
              });
            }, delay);
            if (this.opts.autoUnref) {
              timer.unref();
            }
            this.subs.push(function subDestroy() {
              clearTimeout(timer);
            });
          }
        }
        onreconnect() {
          const attempt = this.backoff.attempts;
          this._reconnecting = false;
          this.backoff.reset();
          this.emitReserved("reconnect", attempt);
        }
      };
    }
  });

  // node_modules/socket.io-client/build/esm/index.js
  function lookup2(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    const parsed = url(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    let io;
    if (newConnection) {
      io = new Manager(source, opts);
    } else {
      if (!cache[id]) {
        cache[id] = new Manager(source, opts);
      }
      io = cache[id];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
  }
  var cache;
  var init_esm4 = __esm({
    "node_modules/socket.io-client/build/esm/index.js"() {
      init_url();
      init_manager();
      init_socket2();
      init_esm3();
      cache = {};
      Object.assign(lookup2, {
        Manager,
        Socket: Socket2,
        io: lookup2,
        connect: lookup2
      });
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/SerpAnalysis/CompetitorAnalyzer.js
  var CompetitorAnalyzer;
  var init_CompetitorAnalyzer = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/SerpAnalysis/CompetitorAnalyzer.js"() {
      init_RequestManager();
      CompetitorAnalyzer = class {
        constructor(ContentAnalysis2, KeywordFinder2, GenieHelpers10) {
          this.ContentAnalysis = ContentAnalysis2;
          this.KeywordFinder = KeywordFinder2;
          this.GenieHelpers = GenieHelpers10;
        }
        getDomainName(url2) {
          try {
            const parsedUrl = new URL(url2);
            return parsedUrl.hostname.split(".").slice(-2).join(".");
          } catch (e) {
            return "";
          }
        }
        saveCompetitor = (competitorData2) => {
          this.GenieHelpers.callStoreApi("serpData", {
            competitorData: competitorData2
          });
        };
        getNlpKeywords = async (focusKeyword, competitorData2, competitorKeywords, url2) => {
          return new Promise((resolve2, reject) => {
            const config = window.getGenie.config;
            const options = {
              method: "POST",
              headers: {
                "Content-type": "application/json; charset=UTF-8",
                "Site-Token": config?.siteToken || "",
                "Auth-Token": config?.authToken || "",
                "X-WP-Nonce": config?.restNonce || "",
                "Plugin-Version": config?.version
              }
            };
            (async () => {
              let keywords = competitorKeywords || [];
              let nlpKeywords2 = [];
              for (const webItem of competitorData2) {
                options.body = JSON.stringify({
                  textContent: webItem?.textContent,
                  requestId: webItem?.requestId
                });
                const keywordCluster = await fetch(url2, options);
                let result = await keywordCluster.json();
                for (let item of result?.data || []) {
                  nlpKeywords2.push(item[0].toLowerCase());
                }
              }
              nlpKeywords2 = [...new Set(nlpKeywords2)];
              options.body = JSON.stringify({
                mainKeywords: competitorKeywords.length === 0 ? [focusKeyword] : competitorKeywords.map((item) => item?.keyword || "").slice(0, 10),
                nlpKeywords: nlpKeywords2
              });
              const filterNlpKeywords = await fetch(EndPoints_exports.filterNlpKeywordsUrl, options).catch((err) => resolve2(keywords));
              if (!filterNlpKeywords.ok) {
                resolve2(keywords);
                return;
              }
              const filteredKeywords = await filterNlpKeywords.json();
              try {
                const keywordDetail = (filteredKeywords?.data || nlpKeywords2)?.map((item) => {
                  let keyword = Array.isArray(item) ? item[0] : item;
                  return { keyword, type: "nlp" };
                });
                keywords = [...keywords, ...keywordDetail || []];
                keywords = keywords.filter(
                  (obj1, index2, arr) => index2 === arr.findIndex((obj2) => obj2?.keyword === obj1?.keyword)
                );
                resolve2(keywords);
              } catch (error) {
                resolve2(keywords);
                console.log(error);
              }
            })();
          });
        };
        analyze = async (competitorData2, statisticsData) => {
          return new Promise((resolve2, reject) => {
            let analyzedCompetitors = [];
            let statistics = {}, serpDomains = {};
            const finder = new this.KeywordFinder();
            let avgScore = 0, maxScore = 0, totalScore = 0, index2 = 0;
            for (const site of competitorData2) {
              let url2 = this.getDomainName(site?.url);
              const analyzedContent = new this.ContentAnalysis({
                content: site?.source,
                url: url2,
                title: site?.title,
                description: site?.description
              }, statisticsData);
              const analysis = analyzedContent.getStat();
              const keywordList = finder.findAllMatch(site?.source, Object.keys(statisticsData.keywords));
              serpDomains[site.keySlug] = {
                url: site.url,
                title: site.title,
                rank: index2,
                favicon: site.favicon
              };
              for (const item of keywordList) {
                if (!statisticsData.keywords?.[item.keyword]?.total) {
                  continue;
                }
                if (!statistics[item.keyword]) {
                  statistics[item.keyword] = {
                    keyPhrase: item.keyword,
                    recommendation: statisticsData.keywords?.[item.keyword]?.total,
                    heatMap: {
                      [site.keySlug]: {
                        matchedKeyPhrase: item.count
                      }
                    }
                  };
                } else {
                  statistics[item.keyword].heatMap[site.keySlug] = {
                    matchedKeyPhrase: item.count
                  };
                }
              }
              index2++;
              if (site.title === "myContent") {
                continue;
              }
              let competitorScore = parseFloat(analysis.contentStats.totalScore);
              analyzedCompetitors.push({
                url: site.url,
                statistics: analysis.statistics,
                score: parseInt(Math.ceil(competitorScore)) || 0
              });
              if (maxScore < competitorScore) {
                maxScore = parseInt(Math.ceil(competitorScore)) || 0;
              }
              totalScore += competitorScore;
            }
            avgScore = Math.ceil(totalScore / analyzedCompetitors.length - 1);
            avgScore = parseInt(avgScore) || 0;
            const competitorStats = {
              headToHeadData: {
                serpDomains,
                statistics
              },
              analyzedCompetitors,
              avgScore,
              maxScore,
              firstCompetitorScore: analyzedCompetitors?.[1]?.score || 0
            };
            resolve2(competitorStats);
          });
        };
      };
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/SerpAnalysis/index.js
  var useEffect6, useState5, HandleResponse2, EndPoints, ComposeComponents8, Libs9, Utilities4, GenieHelpers4, fetchError, calling, SerpAnalysis;
  var init_SerpAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/SerpAnalysis/index.js"() {
      init_Utilities2();
      init_Competitor();
      init_Keywords();
      init_QuestionsAsked();
      init_esm4();
      init_CompetitorAnalyzer();
      ({ useEffect: useEffect6, useState: useState5 } = window.React);
      ({ HandleResponse: HandleResponse2, EndPoints } = window.getGenie.Components.Common.RequestManager);
      ({ ComposeComponents: ComposeComponents8 } = window.getGenie.Components.Common.ReduxManager);
      ({ Libs: Libs9, Utilities: Utilities4 } = window.getGenie.Components.Common);
      ({ GenieHelpers: GenieHelpers4 } = Utilities4);
      fetchError = false;
      calling = false;
      SerpAnalysis = ComposeComponents8(({ sidebar: sidebar4, getInputs, setInput, setSidebar }) => {
        const [loadingText, setLoadingText] = useState5("");
        const [websiteScraped, setWebsiteScraped] = useState5(getInputs["competitorData"]);
        const [page, setPage] = useState5(getGenie.blogWizardData?.serpData?.pageCount || 0);
        const [loading, setLoading] = useState5(false);
        const activeTab = getInputs["seoDataTab"] || "keywords";
        const analysisData = getInputs["searchVolume"];
        useEffect6(() => {
          if (!loading) {
            setLoadingText("");
          }
        }, [loading]);
        useEffect6(() => {
          if (!getInputs["competitorData"]) {
            setWebsiteScraped(null);
            setPage(0);
          } else {
            setWebsiteScraped(getInputs["competitorData"]);
          }
        }, [getInputs["competitorData"]]);
        useEffect6(() => {
          if (Object.keys(getInputs["searchVolume"] || {})?.length && sidebar4.component === "OutlineScreen") {
            setInput("seoDataTab", "competitor");
          }
        }, [getInputs["generatedOutlines"]]);
        useEffect6(() => {
          if (sidebar4.statisticsScreen.triggered && !getInputs["competitorData"]) {
            setInput("seoDataTab", "competitor");
            fetchCompetitorData();
          }
        }, [sidebar4.statisticsScreen.triggered, getInputs["competitorData"]]);
        useEffect6(() => {
          if (!getInputs["searchVolume"]) {
            setInput("seoDataTab", "keywords");
          }
          setLoadingText("");
        }, [getInputs["searchVolume"]]);
        const waitFor = (delay) => new Promise((resolve2) => {
          setTimeout(resolve2, delay);
        });
        async function showLoadingText() {
          setLoadingText(sidebar4.__(`Getting competitor list `, `getgenie`));
          await waitFor(15e3);
          if (!getInputs["questionsAsked"] && !fetchError) {
            setLoadingText(sidebar4.__(`Fetching competitor websites `, `getgenie`));
          }
        }
        const fetchCompetitorData = () => {
          const competitorAllData = wp.data.select("getgenie").getInputs()?.competitorData;
          if (loading) {
            return;
          }
          setLoading(true);
          setSidebar({ analyzingCompetitors: true });
          showLoadingText();
          let relatedKeywords2 = getInputs["relatedKeywords"] || [];
          let peopleAlsoSearched = (getInputs["peopleAlsoSearched"] || []).map((item) => item.title);
          relatedKeywords2 = [...relatedKeywords2, ...peopleAlsoSearched].map((rel, index2) => {
            let keyword = typeof rel === "string" ? rel.toLowerCase() : rel.keyword.toLowerCase();
            let focusKeyword = (getInputs["keyword"] || "").toLowerCase();
            keyword = keyword.trim();
            focusKeyword = focusKeyword.trim();
            let type = keyword == focusKeyword ? "focus" : "common";
            return { keyword, type };
          });
          const socket = lookup2(window.getGenie.config?.parserApi, {
            extraHeaders: {
              "Site-Token": window.getGenie.config?.siteToken,
              "Auth-Token": window.getGenie.config?.authToken,
              "Plugin-Version": window.getGenie.config?.version,
              "Plugin-Name": "getgenie"
            },
            query: {
              location: getInputs["seoCountry"],
              keyword: getInputs["keyword"],
              page
            },
            reconnection: false
          });
          if (window.getGenie?.isPlayground) {
            window.getGenie.socket = socket;
          }
          const engine = socket.io.engine;
          engine.on("close", (reason) => {
            if (window.getGenie.webview?.isDocumentClicked) {
              setLoading(false);
              setSidebar({ analyzingCompetitors: false });
            }
          });
          const scrape = new WebSourceAnalysis();
          let webArray = [], questions = [], competitorKeywords = [...relatedKeywords2], socketTimeout, connectionAttempts = 0;
          let datasetDetail = [];
          socket.on("connect", () => {
            socket.on("DATASET_DETAIL", (data) => {
              datasetDetail = datasetDetail.map((item) => {
                if (item?.datasetId === data.datasetDetail.datasetId) {
                  return { ...item, offset: data.datasetDetail.offset, rank: data.datasetDetail.rank };
                }
                return item;
              });
            });
            socket.on("DATASETS", (data) => {
              datasetDetail = data;
            });
            socket.emit("TRANSPORT_DATA", { datasetDetail, datasetLogs: {} });
            socket.on("COMPETITOR_LIST", (res) => {
              HandleResponse2(res, () => {
                questions = res.data?.question || [];
                setInput("questionsAsked", [...getInputs["questionsAsked"] || [], ...questions]);
                setInput("peopleAlsoSearched", res.data?.peopleAlsoSearched);
                GenieHelpers4.callStoreApi("keywordData", {
                  searchVolume: getInputs["searchVolume"],
                  relatedKeywords: getInputs["relatedKeywords"],
                  peopleAlsoSearched: res.data?.peopleAlsoSearched
                });
              });
              if (res?.status === "fail") {
                setLoadingText("");
                setLoading(false);
                setSidebar({ analyzingCompetitors: false });
                fetchError = true;
                return;
              }
              setLoadingText(sidebar4.__("Analyzing and fetching data ", "getgenie"));
            });
            socket.on("SCRAPED_URLS", (res) => {
              if (socketTimeout) {
                clearTimeout(socketTimeout);
              }
              setLoadingText(sidebar4.__("Analyzing and fetching data ", "getgenie"));
              HandleResponse2(res, async () => {
                let scrapped = scrape.scrapping(res.data, (getInputs["keyword"] || "").trim());
                if (!scrapped) {
                  return;
                }
                if (!webArray.find((item) => item?.url === scrapped?.url)) {
                  let webDetails = { ...scrapped, requestId: res?.requestId, url: res.data?.url, keySlug: res.data?.keySlug };
                  webArray.push(webDetails);
                  setWebsiteScraped([...websiteScraped || [], ...webArray]);
                  GenieHelpers4.callStoreApi("serpData", {
                    competitorData: [webDetails]
                  });
                }
              });
              if (res?.status === "fail") {
                fetchError = true;
                setLoading(false);
                setSidebar({ analyzingCompetitors: false });
              }
            });
          });
          const disconnectReasons = ["ping timeout", "transport close", "transport error"];
          let recall = 0;
          socket.on("disconnect", async (reason) => {
            console.log(reason);
            if (disconnectReasons.includes(reason) && recall < 4) {
              datasetDetail = datasetDetail.sort((a, b) => a?.offset - b?.offset);
              datasetDetail = datasetDetail.slice(-2);
              datasetDetail = datasetDetail.reduce((acc, current) => {
                const x = acc.find((item) => item?.datasetId === current?.datasetId);
                if (!x) {
                  return acc.concat([current]);
                } else {
                  return acc;
                }
              }, []);
              recall++;
              setLoading(true);
              setSidebar({ analyzingCompetitors: false });
              socket.connect();
              return;
            } else {
              calling = false;
              datasetDetail = [];
              if (window.getGenie?.isPlayground) {
                window.getGenie.socket = null;
              }
            }
            if (webArray.length === 0) {
              setLoading(false);
              return;
            }
            try {
              let competitorData2 = [...competitorAllData || [], ...webArray];
              competitorData2 = competitorData2.sort((a, b) => a.rank - b.rank);
              competitorData2 = competitorData2.reduce((acc, current) => {
                const x = acc.find((item) => item.url === current.url);
                if (!x) {
                  return acc.concat([current]);
                } else {
                  return acc;
                }
              }, []);
              let pageCount = page + 1;
              if (!competitorAllData) {
                let competitorAnalyzer = new CompetitorAnalyzer(ContentAnalysis, KeywordFinder, GenieHelpers4);
                competitorKeywords = await competitorAnalyzer.getNlpKeywords(getInputs["keyword"], competitorData2.slice(0, 10), competitorKeywords, EndPoints.nlpKeywordsUrl);
                let statisticsData = scrape.getStat(competitorData2, competitorKeywords);
                setSidebar({
                  statisticsData,
                  statisticsScreen: {
                    loading: false
                  }
                });
                GenieHelpers4.callStoreApi("serpData", {
                  pageCount,
                  questionsAsked: questions,
                  statisticsData
                });
              }
              setInput("competitorData", competitorData2);
              calling = false;
              setPage(pageCount);
              setLoading(false);
              setLoadingText("");
              setSidebar({ analyzingCompetitors: false });
            } catch (err) {
              setLoading(false);
              console.log(err);
            }
          });
          socket.on("connect_error", () => {
            console.log("error");
            connectionAttempts++;
            if (connectionAttempts > 2) {
              setLoading(false);
              setLoadingText("");
              fetchError = true;
            } else {
              setLoading(true);
              socket.connect();
            }
          });
        };
        const tabPaneList = [
          {
            label: sidebar4.__("Keywords", "getgenie"),
            key: "keywords",
            children: /* @__PURE__ */ React.createElement(Keywords, null)
          },
          {
            label: sidebar4.__("Competitor", "getgenie"),
            key: "competitor",
            children: /* @__PURE__ */ React.createElement(Competitor, {
              loadingText,
              page,
              loading,
              data: websiteScraped,
              fetchData: fetchCompetitorData
            }),
            disabled: !analysisData
          },
          {
            label: sidebar4.__("Questions Asked", "getgenie"),
            key: "questionsAsked",
            children: /* @__PURE__ */ React.createElement(QuestionsAsked, {
              loadingText,
              loading: !getInputs["questionsAsked"] && loading,
              fetchData: fetchCompetitorData
            }),
            disabled: !analysisData
          }
        ];
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-seo-keyword-tab"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-seo-container"
        }, /* @__PURE__ */ React.createElement(Libs9.Navbar, {
          tabPaneList,
          activeKey: activeTab,
          destroyInactiveTabPane: false,
          handleActiveKey: (key) => setInput("seoDataTab", key),
          className: "keyword-analysis-navbar"
        })));
      }, ["getInputs", "sidebar", "setInput", "setSidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/SeoData/index.js
  var init_SeoData = __esm({
    "assets/src/admin/js/BlogWizard/SeoData/index.js"() {
      init_SerpAnalysis();
    }
  });

  // assets/src/admin/js/BlogWizard/AnalyzeKeywordScreen/index.js
  var init_AnalyzeKeywordScreen = __esm({
    "assets/src/admin/js/BlogWizard/AnalyzeKeywordScreen/index.js"() {
      init_SeoData();
    }
  });

  // assets/src/admin/js/BlogWizard/SidebarNav/index.js
  var Radio, ComposeComponents9, SidebarNav;
  var init_SidebarNav = __esm({
    "assets/src/admin/js/BlogWizard/SidebarNav/index.js"() {
      ({ Radio } = window.antd);
      ({ ComposeComponents: ComposeComponents9 } = window.getGenie.Components.Common.ReduxManager);
      SidebarNav = ComposeComponents9(({ sidebar: sidebar4, navigation = "title", setSidebar, getInputs }) => {
        let navs = {
          title: { title: "Title", screen: "TitleScreen", selected: !!getInputs["generatedTitles"] },
          intro: { title: "Intro", screen: "IntroScreen", selected: !!getInputs["generatedIntros"] },
          outline: { title: "Outline", screen: "OutlineScreen", selected: !!(getInputs["selectedOutlines"] || getInputs["generatedOutlines"]) }
        };
        const handleChange = (e) => {
          let target = e.target, value2 = target.value, screen = target.screen, selected = navs[value2].selected;
          if (!selected) {
            return false;
          }
          setSidebar({
            component: screen
          });
          screen !== "OutlineScreen" && setSidebar({
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: false
            }
          });
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "genie-nav-container"
        }, /* @__PURE__ */ React.createElement(Radio.Group, {
          onChange: handleChange,
          value: navigation
        }, Object.keys(navs).map((key, index2) => {
          let nav = navs[key];
          return /* @__PURE__ */ React.createElement(Radio.Button, {
            key: index2,
            className: nav.selected ? "selected" : "",
            value: key,
            screen: nav.screen
          }, nav.title);
        })));
      }, ["sidebar", "setSidebar", "getInputs"]);
    }
  });

  // assets/src/admin/js/Common/Static/index.js
  var StaticData, Static_default;
  var init_Static = __esm({
    "assets/src/admin/js/Common/Static/index.js"() {
      StaticData = {
        countries: [
          { label: "Global", value: "global" },
          { label: "Australia", value: 2036 },
          { label: "Canada", value: 2124 },
          { label: "India", value: 2356 },
          { label: "New Zealand", value: 2554 },
          { label: "South Africa", value: 2710 },
          { label: "United States (USA)", value: 2840 },
          { label: "United Kingdom", value: 2826 },
          { label: "Germany", value: 2276 },
          { label: "Portugal", value: 2620 },
          { label: "Spain", value: 2724 },
          { label: "Vietnam", value: 2704 },
          { label: "Indonesia", value: 2360 },
          { label: "Malaysia", value: 2458 },
          { label: "South Korea", value: 2410 },
          { label: "Japan", value: 2392 },
          { label: "China", value: 2156 },
          { label: "Turkey", value: 2792 },
          { label: "Ukraine", value: 2804 },
          { label: "Italy", value: 2380 },
          { label: "France", value: 2250 },
          { label: "Poland", value: 2616 },
          { label: "Netherland", value: 2528 },
          { label: "Lithuania", value: 2440 },
          { label: "Hungary", value: 2348 },
          { label: "Denmark", value: 2208 },
          { label: "Czechia", value: 2203 },
          { label: "Thailand", value: 2764 },
          { label: "Latvia", value: 2428 },
          { label: "Slovakia", value: 2703 },
          { label: "Greece", value: 2300 },
          { label: "Sweden", value: 2752 },
          { label: "Saudi Arabia", value: 2682 },
          { label: "Russia", value: 2643 },
          { label: "Bulgaria", value: 2100 },
          { label: "Mexico", value: 2484 },
          { label: "Norway", value: 2578 },
          { label: "Pakistan", value: 2586 },
          { label: "Israel", value: 2376 }
        ],
        languages: [
          {
            "value": "en",
            "label": "English"
          },
          {
            "value": "es",
            "label": "Spanish"
          },
          {
            "value": "de",
            "label": "German"
          }
        ],
        outputSizes: [
          { label: "Small", value: "sm" },
          { label: "Medium", value: "md" },
          { label: "Large", value: "lg" }
        ],
        maxToken: [
          { label: "Small", value: 200 },
          { label: "Medium", value: 400 },
          { label: "Large", value: 1200 }
        ],
        chatCharacters: [
          { label: "Professional Writer", value: "professional-writer" },
          { label: "General Purpose", value: "general-purpose" },
          { label: "Standup Comedian", value: "standup-comedian" },
          { label: "Life Coach", value: "life-coach" },
          { label: "Career Counselor", value: "career-counselor" },
          { label: "Nutritionist", value: "nutritionist" },
          { label: "Product Manager", value: "product-manager" },
          { label: "Personal Trainer", value: "personal-trainer" },
          { label: "Life Hacker", value: "life-hacker" },
          { label: "Travel Advisor", value: "travel-advisor" },
          { label: "Mindfulness Coach", value: "mindfulness-coach" },
          { label: "Financial Advisor", value: "financial-advisor" },
          { label: "Language Tutor", value: "language-tutor" },
          { label: "Travel Guide", value: "travel-guide" },
          { label: "Marketing Expert", value: "marketing-expert" },
          { label: "Software Developer", value: "software-developer" },
          { label: "Dating Coach", value: "dating-coach" },
          { label: "DIY Expert", value: "diy-expert" },
          { label: "Journalist", value: "journalist" },
          { label: "Tech Writer", value: "tech-writer" },
          { label: "Pro Chef", value: "professional-chef" },
          { label: "Pro Salesperson", value: "professional-salesperson" },
          { label: "Startup Tech Lawyer", value: "startup-tech-lawyer" },
          { label: "Email Copywriter", value: "email-copywriter" }
        ]
      };
      Static_default = StaticData;
    }
  });

  // assets/src/admin/js/Common/SidebarControllerOption/index.js
  var Row3, Col3, Libs10, Utilities5, PromotionalNotice, ComposeComponents10, useEffect7, SidebarControllerOption, SidebarControllerOption_default;
  var init_SidebarControllerOption = __esm({
    "assets/src/admin/js/Common/SidebarControllerOption/index.js"() {
      init_Static();
      ({ Row: Row3, Col: Col3 } = window.antd);
      ({ Libs: Libs10, Utilities: Utilities5, PromotionalNotice } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents10 } = window.getGenie.Components.Common.ReduxManager);
      ({ useEffect: useEffect7 } = window.React);
      SidebarControllerOption = ComposeComponents10(({ unsupportedLanguages, setSidebar, sidebar: sidebar4, getInputs, className = "", language = true, tone = true, creativity = true, result = true, outputSize = false }) => {
        if (!Utilities5) {
          return;
        }
        ;
        const { GenieHelpers: GenieHelpers10 } = Utilities5;
        useEffect7(() => {
          GenieHelpers10.storeData("creativity");
        }, [getInputs["creativity"]]);
        useEffect7(() => {
          GenieHelpers10.storeData("numberOfResult");
        }, [getInputs["numberOfResult"]]);
        let toneOfVoice = Object.values(window.getGenie.config?.templateAssets?.toneOfVoice || {});
        toneOfVoice = toneOfVoice.map((item) => ({ label: item, value: item }));
        toneOfVoice = toneOfVoice.sort();
        toneOfVoice = toneOfVoice.reverse();
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Row3, {
          gutter: 16,
          className
        }, language && /* @__PURE__ */ React.createElement(Col3, {
          span: 24
        }, /* @__PURE__ */ React.createElement(Libs10.Select, {
          handleOnChange: (val) => GenieHelpers10.saveSidebarControllerOption("getgenie-language", val),
          name: "selectedLanguage",
          except: unsupportedLanguages,
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Language", "getgenie"), /* @__PURE__ */ React.createElement(Libs10.Tooltip, {
            title: sidebar4.__("Choose the desired language of your input and the outputs", "getgenie"),
            placement: "top"
          })),
          options: sidebar4.languages,
          defaultValue: sidebar4.currentLanguage
        })), outputSize && /* @__PURE__ */ React.createElement(Col3, {
          span: 12
        }, /* @__PURE__ */ React.createElement(Libs10.Select, {
          handleOnChange: (val) => GenieHelpers10.saveSidebarControllerOption("getgenie-outputSize", val),
          name: "outputSize",
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Output Size", "getgenie"), /* @__PURE__ */ React.createElement(Libs10.Tooltip, {
            title: sidebar4.__("Define what type of size you want the outputs to have", "getgenie"),
            placement: "top"
          })),
          options: Static_default.outputSizes,
          defaultValue: sidebar4.outputSize
        }))), /* @__PURE__ */ React.createElement(Row3, {
          style: { marginTop: "10px" },
          gutter: 16,
          className
        }, creativity && /* @__PURE__ */ React.createElement(Col3, {
          span: 12
        }, /* @__PURE__ */ React.createElement(Libs10.Slider, {
          name: "creativity",
          handleOnChange: (val) => GenieHelpers10.saveSidebarControllerOption("getgenie-creativity", val),
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Creativity", "getgenie"), " ", /* @__PURE__ */ React.createElement(Libs10.Tooltip, {
            title: sidebar4.__("How much creative you want genie to be", "getgenie"),
            placement: "top"
          })),
          message: false,
          defaultValue: sidebar4?.creativityLevel
        })), result && /* @__PURE__ */ React.createElement(Col3, {
          span: 12
        }, /* @__PURE__ */ React.createElement(Libs10.NumberInput, {
          name: "numberOfResult",
          handleOnChange: (val) => GenieHelpers10.saveSidebarControllerOption("getgenie-numberOfResult", val),
          className: "ResultLimitNumberInput",
          max: 6,
          type: "text",
          defaultValue: sidebar4?.numberOfResult,
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Max Results", "getgenie"), " ", /* @__PURE__ */ React.createElement(Libs10.Tooltip, {
            title: sidebar4.__("Maximum content you want to generate", "getgenie"),
            placement: "top"
          })),
          required: true,
          errorMessage: sidebar4.__("Please choose valid limit", "getgenie")
        }))), /* @__PURE__ */ React.createElement(PromotionalNotice, {
          type: "promotionalNotice",
          names: ["word_generate"]
        }));
      }, ["sidebar", "getInputs", "setSidebar"]);
      SidebarControllerOption_default = SidebarControllerOption;
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/TitleScreen/index.js
  var Libs11, Utilities6, ContentFeedback, StaticData2, PromotionalNotice2, Form, Divider3, Button3, GenieHelpers5, ComposeComponents11, HandleFetch2, HandleResponse3, useEffect8, useState6, TitleScreen, TitleScreen_default;
  var init_TitleScreen = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/TitleScreen/index.js"() {
      init_SidebarControllerOption();
      ({ Libs: Libs11, Utilities: Utilities6, ContentFeedback, StaticData: StaticData2, PromotionalNotice: PromotionalNotice2 } = window.getGenie.Components.Common);
      ({ Form, Divider: Divider3, Button: Button3 } = window.antd);
      ({ GenieHelpers: GenieHelpers5 } = Utilities6);
      ({ ComposeComponents: ComposeComponents11 } = window.getGenie.Components.Common.ReduxManager);
      ({ HandleFetch: HandleFetch2, HandleResponse: HandleResponse3 } = window.getGenie.Components.Common.RequestManager);
      ({ useEffect: useEffect8, useState: useState6 } = window.React);
      TitleScreen = ComposeComponents11(({ sidebar: sidebar4, setSidebar, getInputs, setInput }) => {
        const [countries, setCountries] = useState6(StaticData2.countries);
        const [loading, setLoading] = useState6(false);
        const list = getInputs["generatedTitles"] || [];
        const seoEnabled = getInputs["seoEnabled"] || false;
        const [countryLoading, setCountryLoading] = useState6(false);
        const keywordAnalyzing = sidebar4.analyzingSearchVolume || sidebar4.analyzingRelatedKeyword;
        useEffect8(() => {
          if (!getInputs["searchVolume"]) {
            setInput("seoEnabled", true);
          }
        }, []);
        useEffect8(() => {
          if (sidebar4.analyzeKeyword?.triggered && getInputs["keyword"]) {
            analyzeData();
          }
        }, [sidebar4.analyzeKeyword?.triggered]);
        const generateTitle = () => {
          setLoading(true);
          let data = {
            input: {
              keyword: (getInputs["keyword"] || "").replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/g, ""),
              context: getInputs["inputContext"]
            },
            templateSlug: "blog-wizard-title"
          };
          setInput("generatedTitles", []);
          HandleFetch2((res) => {
            setLoading(false);
            HandleResponse3(res, () => {
              let titles = res.data.map((item) => {
                return { title: item, like: false, dislike: false };
              });
              setInput("generatedTitles", titles);
              GenieHelpers5.callStoreApi("generatedTitles", titles);
            });
          }, "writeTitle", data);
        };
        const analyzeData = () => {
          if (getInputs["keyword"] !== getInputs["searchVolume"]?.keyword || getInputs["seoCountry"] !== getInputs["searchVolume"]?.country) {
            setInput("searchVolume", "");
            setInput("relatedKeywords", "");
            setInput("competitorData", "");
            setInput("questionsAsked", "");
            setInput("peopleAlsoSearched", "");
            GenieHelpers5.callStoreApi("serpData", {
              competitorData: "",
              pageCount: 0,
              questionsAsked: "",
              statisticsData: "",
              restStatisticsKeyword: "",
              selectedKeywordList: "",
              nlpKeywordList: ""
            });
            setSidebar({
              statisticsData: "",
              analyzeKeyword: {
                open: true,
                triggered: false
              },
              analyzingSearchVolume: true
            });
          }
        };
        const handleClick = (e, item) => {
          setInput("selectedTitle", item.title);
        };
        const handlePrev = () => {
          setSidebar({
            component: "TemplateListScreen"
          });
        };
        useEffect8(() => {
          GenieHelpers5.storeData("keyword");
          if (document.getElementsByClassName("block-editor__container").length) {
            wp.data.dispatch("core/editor").editPost({ excerpt: " " });
          }
        }, [getInputs["keyword"]]);
        useEffect8(() => {
          GenieHelpers5.storeData("seoEnabled");
        }, [getInputs["seoEnabled"]]);
        useEffect8(() => {
          GenieHelpers5.storeData("seoCountry");
        }, [getInputs["seoCountry"]]);
        useEffect8(() => {
          GenieHelpers5.storeData("selectedTitle");
        }, [getInputs["selectedTitle"]]);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-title-form getgenie-wrapper-screen"
        }, /* @__PURE__ */ React.createElement(Form, {
          layout: "vertical",
          onFinish: generateTitle
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-screen-content title"
        }, /* @__PURE__ */ React.createElement(Libs11.Input, {
          name: "keyword",
          type: "text",
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Keyword", "getgenie"), /* @__PURE__ */ React.createElement(Libs11.Tooltip, {
            title: sidebar4.__("Enter the focus keyword or topic of your blog post.", "getgenie"),
            placement: "top"
          })),
          placeholder: sidebar4.__("e.g. bean coffee, best coffee maker, how to make coffee, etc.", "getgenie"),
          required: true,
          errorMessage: sidebar4.__("Keyword is missing. Please enter keyword.", "getgenie")
        }), /* @__PURE__ */ React.createElement(Libs11.Select, {
          handleOnChange: (val) => GenieHelpers5.saveSidebarControllerOption("getgenie-language", val),
          name: "selectedLanguage",
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Language", "getgenie"), /* @__PURE__ */ React.createElement(Libs11.Tooltip, {
            title: sidebar4.__("Choose the desired language of your input and the outputs", "getgenie"),
            placement: "top"
          })),
          options: sidebar4.languages,
          defaultValue: sidebar4.currentLanguage
        }), /* @__PURE__ */ React.createElement(Divider3, null), /* @__PURE__ */ React.createElement(Libs11.Switch, {
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("SEO Mode", "getgenie"), /* @__PURE__ */ React.createElement(Libs11.Tooltip, {
            title: sidebar4.__("Turn on the SEO mode for better search engine optimization.", "getgenie"),
            placement: "top"
          })),
          defaultChecked: seoEnabled,
          name: "seoEnabled"
        }), seoEnabled && /* @__PURE__ */ React.createElement(Libs11.Select, {
          name: "seoCountry",
          handleOnChange: (val) => GenieHelpers5.saveSidebarControllerOption("getgenie-seoCountry", val),
          loading: countryLoading,
          className: "seoCountry",
          options: countries,
          defaultValue: sidebar4?.seoCountry
        }), seoEnabled && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Libs11.Button, {
          onClick: analyzeData,
          className: "getgenie-analyze-btn",
          type: "primary",
          loading: keywordAnalyzing,
          disabled: !getInputs.keyword
        }, sidebar4.__("Analyze keyword", "getgenie"))), /* @__PURE__ */ React.createElement(Divider3, null), /* @__PURE__ */ React.createElement(Libs11.Textarea, {
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Context (Optional)", "getgenie"), /* @__PURE__ */ React.createElement(Libs11.Tooltip, {
            title: sidebar4.__("Let the genie know the context of your blog post.", "getgenie"),
            placement: "top"
          })),
          name: "inputContext",
          rows: 4,
          placeholder: sidebar4.__("Enter a context for this keyword. e.g. a list of best selling coffee maker on amazon, step-by-step process to make coffee at home. etc.", "getgenie"),
          errorMessage: sidebar4.__("Please enter the context here", "getgenie")
        }), /* @__PURE__ */ React.createElement(Divider3, null), /* @__PURE__ */ React.createElement(SidebarControllerOption_default, {
          language: false,
          className: "getgenie-sidebar-controller-options"
        }), /* @__PURE__ */ React.createElement(Libs11.Button, {
          htmlType: "submit",
          className: "submit-btn",
          type: "primary",
          loading,
          disabled: !getInputs.keyword
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-edit"
        }), sidebar4.__("Generate title", "getgenie"))), /* @__PURE__ */ React.createElement(Libs11.TitleMsg, {
          list,
          loading,
          title: "title"
        }), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-card-container getgenie-title-cards",
          style: { backgroundColor: list.length === 0 && "transparent" }
        }, /* @__PURE__ */ React.createElement(Libs11.Card, {
          showActiveItem: true,
          value: getInputs["selectedTitle"],
          list,
          handleClick,
          column: 1,
          skeleton: loading ? () => /* @__PURE__ */ React.createElement(Libs11.SkeletonSingle, {
            count: 10
          }) : ""
        }, (item) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h5", {
          className: "generated-content"
        }, item.title), /* @__PURE__ */ React.createElement(ContentFeedback, {
          content: item,
          input: getInputs["keyword"],
          contentType: "blogWizard-title",
          creativityLevel: getInputs["creativity"],
          listName: "generatedTitles"
        }))))), /* @__PURE__ */ React.createElement(Libs11.DrawerFooter, {
          handleNext: () => setInput("writingScreen", "introScreen"),
          handlePrev,
          enableNextBtn: !!list.find((item) => item.title === getInputs["selectedTitle"])
        })));
      }, ["setSidebar", "getInputs", "setInput", "sidebar"]);
      TitleScreen_default = TitleScreen;
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/IntroScreen/index.js
  var Form2, Divider4, ContentFeedback2, Libs12, Utilities7, HandleFetch3, HandleResponse4, ComposeComponents12, useState7, IntroScreen, IntroScreen_default;
  var init_IntroScreen = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/IntroScreen/index.js"() {
      init_SidebarControllerOption();
      ({ Form: Form2, Divider: Divider4 } = window.antd);
      ({ ContentFeedback: ContentFeedback2, Libs: Libs12, Utilities: Utilities7 } = window.getGenie.Components.Common);
      ({ HandleFetch: HandleFetch3, HandleResponse: HandleResponse4 } = window.getGenie.Components.Common.RequestManager);
      ({ ComposeComponents: ComposeComponents12 } = window.getGenie.Components.Common.ReduxManager);
      ({ useState: useState7 } = window.React);
      IntroScreen = ComposeComponents12(({ getInputs, setInput, setSidebar, sidebar: sidebar4 }) => {
        const [loading, setLoading] = useState7(false);
        const list = getInputs["generatedIntros"] || [];
        const generateIntro = () => {
          setLoading(true);
          let data = {
            input: {
              keyword: getInputs["keyword"] || "",
              title: getInputs["selectedTitle"],
              context: getInputs["inputContext"]
            },
            templateSlug: "blog-wizard-intro"
          };
          setInput("generatedIntros", []);
          HandleFetch3((res) => {
            setLoading(false);
            HandleResponse4(res, () => {
              let intros = res.data.map((item) => {
                return { title: item, like: false, dislike: false };
              });
              setInput("generatedIntros", intros);
              Utilities7.GenieHelpers.callStoreApi("generatedIntros", intros);
            });
          }, "writeIntro", data);
        };
        const handleClick = (e, item) => {
          setInput("selectedIntro", item.title);
        };
        const handleNext = () => {
          setInput("writingScreen", "outlineScreen");
        };
        const handlePrev = () => {
          setInput("writingScreen", "titleScreen");
          setSidebar({
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: false
            }
          });
        };
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-title-form getgenie-wrapper-screen"
        }, /* @__PURE__ */ React.createElement(Form2, {
          layout: "vertical",
          onFinish: generateIntro
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-screen-content intro"
        }, /* @__PURE__ */ React.createElement(Libs12.Collapse, {
          defaultActiveKey: ["generated-content"],
          className: "getgenie-collapse"
        }, /* @__PURE__ */ React.createElement(Libs12.Collapse.Panel, {
          header: /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-collapse-header"
          }, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-collapse-header-title"
          }, "Title"), /* @__PURE__ */ React.createElement(Libs12.Tooltip, {
            title: sidebar4.__("Edit or change the blog post title", "getgenie"),
            placement: "top"
          }), " "),
          key: "generated-content"
        }, /* @__PURE__ */ React.createElement(Libs12.Textarea, {
          name: "selectedTitle",
          type: "text",
          placeholder: sidebar4.__("Enter the blog post title here.", "getgenie"),
          required: true,
          errorMessage: sidebar4.__("Please enter the title here", "getgenie")
        }))), /* @__PURE__ */ React.createElement(Divider4, null), /* @__PURE__ */ React.createElement(SidebarControllerOption_default, {
          className: "getgenie-sidebar-controller-options"
        }), /* @__PURE__ */ React.createElement(Libs12.Button, {
          htmlType: "submit",
          type: "primary",
          className: "submit-btn",
          loading
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-edit"
        }), sidebar4.__("Generate Intro", "getgenie"))), /* @__PURE__ */ React.createElement(Libs12.TitleMsg, {
          list,
          loading,
          title: "intro"
        }), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-card-container getgenie-title-cards",
          style: { backgroundColor: list.length === 0 && "transparent" }
        }, /* @__PURE__ */ React.createElement(Libs12.Card, {
          showActiveItem: true,
          value: getInputs["selectedIntro"],
          list,
          handleClick,
          skeleton: loading ? () => /* @__PURE__ */ React.createElement(Libs12.SkeletonSingle, {
            count: 10
          }) : ""
        }, (item) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h5", {
          className: "generated-content"
        }, item.title), /* @__PURE__ */ React.createElement(ContentFeedback2, {
          content: item,
          input: getInputs["selectedTitle"],
          contentType: "blogWizard-intro",
          creativityLevel: getInputs["creativity"],
          listName: "generatedIntros"
        }))))), /* @__PURE__ */ React.createElement(Libs12.DrawerFooter, {
          handleNext,
          handlePrev,
          enableNextBtn: !!list.find((item) => item.title === getInputs["selectedIntro"])
        })));
      }, ["getInputs", "setInput", "setSidebar", "sidebar"]);
      IntroScreen_default = IntroScreen;
    }
  });

  // node_modules/react-dnd/dist/core/DndContext.js
  var import_react2, DndContext;
  var init_DndContext = __esm({
    "node_modules/react-dnd/dist/core/DndContext.js"() {
      import_react2 = __toESM(require_react(), 1);
      DndContext = (0, import_react2.createContext)({
        dragDropManager: void 0
      });
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i2 = 0; i2 < 10; i2++) {
            test2["_" + String.fromCharCode(i2)] = i2;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to2 = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from2 = Object(arguments[s]);
          for (var key in from2) {
            if (hasOwnProperty.call(from2, key)) {
              to2[key] = from2[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              if (propIsEnumerable.call(from2, symbols[i2])) {
                to2[symbols[i2]] = from2[symbols[i2]];
              }
            }
          }
        }
        return to2;
      };
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React6 = require_react();
          var _assign = require_object_assign();
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          exports.Fragment = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            exports.Fragment = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          function isValidElementType2(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case exports.Fragment:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context2 = type;
                  return getContextName(context2) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample2) {
              if (sample2 && control && typeof sample2.stack === "string") {
                var sampleLines = sample2.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config, self2) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentName(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                key = "" + maybeKey;
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config, self2);
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement2(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentName(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (Array.isArray(node)) {
                for (var i2 = 0; i2 < node.length; i2++) {
                  var child = node[i2];
                  if (isValidElement2(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement2(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement2(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentName(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentName(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i2 = 0; i2 < keys.length; i2++) {
                var key = keys[i2];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType2(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (Array.isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (Array.isArray(children)) {
                      for (var i2 = 0; i2 < children.length; i2++) {
                        validateChildKeys(children[i2], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              if (type === exports.Fragment) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx = jsxWithValidationDynamic;
          var jsxs = jsxWithValidationStatic;
          exports.jsx = jsx;
          exports.jsxs = jsxs;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  var init_defineProperty = __esm({
    "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  var init_objectSpread2 = __esm({
    "node_modules/@babel/runtime/helpers/esm/objectSpread2.js"() {
      init_defineProperty();
    }
  });

  // node_modules/redux/es/redux.js
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    var constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    var typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }
      return enhancer(createStore)(reducer, preloadedState);
    }
    if (typeof reducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
    }
    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe2(listener) {
      if (typeof listener !== "function") {
        throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index2 = nextListeners.indexOf(listener);
        nextListeners.splice(index2, 1);
        currentListeners = null;
      };
    }
    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i2 = 0; i2 < listeners.length; i2++) {
        var listener = listeners[i2];
        listener();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }
      currentReducer = nextReducer;
      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    function observable() {
      var _ref;
      var outerSubscribe = subscribe2;
      return _ref = {
        subscribe: function subscribe3(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        }
      }, _ref[$$observable] = function() {
        return this;
      }, _ref;
    }
    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch,
      subscribe: subscribe2,
      getState,
      replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }
  function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
  function isCrushed() {
  }
  var $$observable, randomString, ActionTypes;
  var init_redux = __esm({
    "node_modules/redux/es/redux.js"() {
      init_objectSpread2();
      $$observable = function() {
        return typeof Symbol === "function" && Symbol.observable || "@@observable";
      }();
      randomString = function randomString2() {
        return Math.random().toString(36).substring(7).split("").join(".");
      };
      ActionTypes = {
        INIT: "@@redux/INIT" + randomString(),
        REPLACE: "@@redux/REPLACE" + randomString(),
        PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
          return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
        }
      };
      if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
        warning('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
      }
    }
  });

  // node_modules/@react-dnd/invariant/dist/index.js
  function invariant(condition, format, ...args) {
    if (isProduction()) {
      if (format === void 0) {
        throw new Error("invariant requires an error message argument");
      }
    }
    if (!condition) {
      let error;
      if (format === void 0) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        let argIndex = 0;
        error = new Error(format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
        error.name = "Invariant Violation";
      }
      error.framesToPop = 1;
      throw error;
    }
  }
  function isProduction() {
    return typeof process !== "undefined" && false;
  }
  var init_dist2 = __esm({
    "node_modules/@react-dnd/invariant/dist/index.js"() {
    }
  });

  // node_modules/dnd-core/dist/utils/js_utils.js
  function get(obj, path, defaultValue) {
    return path.split(".").reduce(
      (a, c) => a && a[c] ? a[c] : defaultValue || null,
      obj
    );
  }
  function without(items, item) {
    return items.filter(
      (i2) => i2 !== item
    );
  }
  function isObject2(input) {
    return typeof input === "object";
  }
  function xor(itemsA, itemsB) {
    const map3 = /* @__PURE__ */ new Map();
    const insertItem = (item) => {
      map3.set(item, map3.has(item) ? map3.get(item) + 1 : 1);
    };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    map3.forEach((count, key) => {
      if (count === 1) {
        result.push(key);
      }
    });
    return result;
  }
  function intersection(itemsA, itemsB) {
    return itemsA.filter(
      (t) => itemsB.indexOf(t) > -1
    );
  }
  var init_js_utils = __esm({
    "node_modules/dnd-core/dist/utils/js_utils.js"() {
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/types.js
  var INIT_COORDS, BEGIN_DRAG, PUBLISH_DRAG_SOURCE, HOVER, DROP, END_DRAG;
  var init_types = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/types.js"() {
      INIT_COORDS = "dnd-core/INIT_COORDS";
      BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
      PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
      HOVER = "dnd-core/HOVER";
      DROP = "dnd-core/DROP";
      END_DRAG = "dnd-core/END_DRAG";
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js
  function setClientOffset(clientOffset, sourceClientOffset) {
    return {
      type: INIT_COORDS,
      payload: {
        sourceClientOffset: sourceClientOffset || null,
        clientOffset: clientOffset || null
      }
    };
  }
  var init_setClientOffset = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js"() {
      init_types();
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js
  function createBeginDrag(manager) {
    return function beginDrag(sourceIds = [], options = {
      publishSource: true
    }) {
      const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
      const monitor = manager.getMonitor();
      const registry2 = manager.getRegistry();
      manager.dispatch(setClientOffset(clientOffset));
      verifyInvariants(sourceIds, monitor, registry2);
      const sourceId = getDraggableSource(sourceIds, monitor);
      if (sourceId == null) {
        manager.dispatch(ResetCoordinatesAction);
        return;
      }
      let sourceClientOffset = null;
      if (clientOffset) {
        if (!getSourceClientOffset2) {
          throw new Error("getSourceClientOffset must be defined");
        }
        verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
        sourceClientOffset = getSourceClientOffset2(sourceId);
      }
      manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
      const source = registry2.getSource(sourceId);
      const item = source.beginDrag(monitor, sourceId);
      if (item == null) {
        return void 0;
      }
      verifyItemIsObject(item);
      registry2.pinSource(sourceId);
      const itemType = registry2.getSourceType(sourceId);
      return {
        type: BEGIN_DRAG,
        payload: {
          itemType,
          item,
          sourceId,
          clientOffset: clientOffset || null,
          sourceClientOffset: sourceClientOffset || null,
          isSourcePublic: !!publishSource
        }
      };
    };
  }
  function verifyInvariants(sourceIds, monitor, registry2) {
    invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
    sourceIds.forEach(function(sourceId) {
      invariant(registry2.getSource(sourceId), "Expected sourceIds to be registered.");
    });
  }
  function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
    invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
  }
  function verifyItemIsObject(item) {
    invariant(isObject2(item), "Item must be an object.");
  }
  function getDraggableSource(sourceIds, monitor) {
    let sourceId = null;
    for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
      if (monitor.canDragSource(sourceIds[i2])) {
        sourceId = sourceIds[i2];
        break;
      }
    }
    return sourceId;
  }
  var ResetCoordinatesAction;
  var init_beginDrag = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js"() {
      init_dist2();
      init_js_utils();
      init_setClientOffset();
      init_types();
      ResetCoordinatesAction = {
        type: INIT_COORDS,
        payload: {
          clientOffset: null,
          sourceClientOffset: null
        }
      };
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/drop.js
  function _defineProperty2(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function createDrop(manager) {
    return function drop(options = {}) {
      const monitor = manager.getMonitor();
      const registry2 = manager.getRegistry();
      verifyInvariants2(monitor);
      const targetIds = getDroppableTargets(monitor);
      targetIds.forEach((targetId, index2) => {
        const dropResult = determineDropResult(targetId, index2, registry2, monitor);
        const action = {
          type: DROP,
          payload: {
            dropResult: _objectSpread({}, options, dropResult)
          }
        };
        manager.dispatch(action);
      });
    };
  }
  function verifyInvariants2(monitor) {
    invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
    invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
  }
  function determineDropResult(targetId, index2, registry2, monitor) {
    const target = registry2.getTarget(targetId);
    let dropResult = target ? target.drop(monitor, targetId) : void 0;
    verifyDropResultType(dropResult);
    if (typeof dropResult === "undefined") {
      dropResult = index2 === 0 ? {} : monitor.getDropResult();
    }
    return dropResult;
  }
  function verifyDropResultType(dropResult) {
    invariant(typeof dropResult === "undefined" || isObject2(dropResult), "Drop result must either be an object or undefined.");
  }
  function getDroppableTargets(monitor) {
    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
    targetIds.reverse();
    return targetIds;
  }
  var init_drop = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/drop.js"() {
      init_dist2();
      init_js_utils();
      init_types();
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/endDrag.js
  function createEndDrag(manager) {
    return function endDrag() {
      const monitor = manager.getMonitor();
      const registry2 = manager.getRegistry();
      verifyIsDragging(monitor);
      const sourceId = monitor.getSourceId();
      if (sourceId != null) {
        const source = registry2.getSource(sourceId, true);
        source.endDrag(monitor, sourceId);
        registry2.unpinSource();
      }
      return {
        type: END_DRAG
      };
    };
  }
  function verifyIsDragging(monitor) {
    invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
  }
  var init_endDrag = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/endDrag.js"() {
      init_dist2();
      init_types();
    }
  });

  // node_modules/dnd-core/dist/utils/matchesType.js
  function matchesType(targetType, draggedItemType) {
    if (draggedItemType === null) {
      return targetType === null;
    }
    return Array.isArray(targetType) ? targetType.some(
      (t) => t === draggedItemType
    ) : targetType === draggedItemType;
  }
  var init_matchesType = __esm({
    "node_modules/dnd-core/dist/utils/matchesType.js"() {
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/hover.js
  function createHover(manager) {
    return function hover(targetIdsArg, { clientOffset } = {}) {
      verifyTargetIdsIsArray(targetIdsArg);
      const targetIds = targetIdsArg.slice(0);
      const monitor = manager.getMonitor();
      const registry2 = manager.getRegistry();
      const draggedItemType = monitor.getItemType();
      removeNonMatchingTargetIds(targetIds, registry2, draggedItemType);
      checkInvariants(targetIds, monitor, registry2);
      hoverAllTargets(targetIds, monitor, registry2);
      return {
        type: HOVER,
        payload: {
          targetIds,
          clientOffset: clientOffset || null
        }
      };
    };
  }
  function verifyTargetIdsIsArray(targetIdsArg) {
    invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
  }
  function checkInvariants(targetIds, monitor, registry2) {
    invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
    invariant(!monitor.didDrop(), "Cannot call hover after drop.");
    for (let i2 = 0; i2 < targetIds.length; i2++) {
      const targetId = targetIds[i2];
      invariant(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
      const target = registry2.getTarget(targetId);
      invariant(target, "Expected targetIds to be registered.");
    }
  }
  function removeNonMatchingTargetIds(targetIds, registry2, draggedItemType) {
    for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
      const targetId = targetIds[i2];
      const targetType = registry2.getTargetType(targetId);
      if (!matchesType(targetType, draggedItemType)) {
        targetIds.splice(i2, 1);
      }
    }
  }
  function hoverAllTargets(targetIds, monitor, registry2) {
    targetIds.forEach(function(targetId) {
      const target = registry2.getTarget(targetId);
      target.hover(monitor, targetId);
    });
  }
  var init_hover = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/hover.js"() {
      init_dist2();
      init_matchesType();
      init_types();
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js
  function createPublishDragSource(manager) {
    return function publishDragSource() {
      const monitor = manager.getMonitor();
      if (monitor.isDragging()) {
        return {
          type: PUBLISH_DRAG_SOURCE
        };
      }
      return;
    };
  }
  var init_publishDragSource = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js"() {
      init_types();
    }
  });

  // node_modules/dnd-core/dist/actions/dragDrop/index.js
  function createDragDropActions(manager) {
    return {
      beginDrag: createBeginDrag(manager),
      publishDragSource: createPublishDragSource(manager),
      hover: createHover(manager),
      drop: createDrop(manager),
      endDrag: createEndDrag(manager)
    };
  }
  var init_dragDrop = __esm({
    "node_modules/dnd-core/dist/actions/dragDrop/index.js"() {
      init_beginDrag();
      init_drop();
      init_endDrag();
      init_hover();
      init_publishDragSource();
      init_types();
    }
  });

  // node_modules/dnd-core/dist/classes/DragDropManagerImpl.js
  var DragDropManagerImpl;
  var init_DragDropManagerImpl = __esm({
    "node_modules/dnd-core/dist/classes/DragDropManagerImpl.js"() {
      init_dragDrop();
      DragDropManagerImpl = class {
        receiveBackend(backend) {
          this.backend = backend;
        }
        getMonitor() {
          return this.monitor;
        }
        getBackend() {
          return this.backend;
        }
        getRegistry() {
          return this.monitor.registry;
        }
        getActions() {
          const manager = this;
          const { dispatch } = this.store;
          function bindActionCreator(actionCreator) {
            return (...args) => {
              const action = actionCreator.apply(manager, args);
              if (typeof action !== "undefined") {
                dispatch(action);
              }
            };
          }
          const actions = createDragDropActions(this);
          return Object.keys(actions).reduce((boundActions, key) => {
            const action = actions[key];
            boundActions[key] = bindActionCreator(action);
            return boundActions;
          }, {});
        }
        dispatch(action) {
          this.store.dispatch(action);
        }
        constructor(store, monitor) {
          this.isSetUp = false;
          this.handleRefCountChange = () => {
            const shouldSetUp = this.store.getState().refCount > 0;
            if (this.backend) {
              if (shouldSetUp && !this.isSetUp) {
                this.backend.setup();
                this.isSetUp = true;
              } else if (!shouldSetUp && this.isSetUp) {
                this.backend.teardown();
                this.isSetUp = false;
              }
            }
          };
          this.store = store;
          this.monitor = monitor;
          store.subscribe(this.handleRefCountChange);
        }
      };
    }
  });

  // node_modules/dnd-core/dist/utils/coords.js
  function add(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }
  function subtract(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  function getSourceClientOffset(state) {
    const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
      return null;
    }
    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
  }
  function getDifferenceFromInitialOffset(state) {
    const { clientOffset, initialClientOffset } = state;
    if (!clientOffset || !initialClientOffset) {
      return null;
    }
    return subtract(clientOffset, initialClientOffset);
  }
  var init_coords = __esm({
    "node_modules/dnd-core/dist/utils/coords.js"() {
    }
  });

  // node_modules/dnd-core/dist/utils/dirtiness.js
  function areDirty(dirtyIds, handlerIds) {
    if (dirtyIds === NONE) {
      return false;
    }
    if (dirtyIds === ALL || typeof handlerIds === "undefined") {
      return true;
    }
    const commonIds = intersection(handlerIds, dirtyIds);
    return commonIds.length > 0;
  }
  var NONE, ALL;
  var init_dirtiness = __esm({
    "node_modules/dnd-core/dist/utils/dirtiness.js"() {
      init_js_utils();
      NONE = [];
      ALL = [];
      NONE.__IS_NONE__ = true;
      ALL.__IS_ALL__ = true;
    }
  });

  // node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js
  var DragDropMonitorImpl;
  var init_DragDropMonitorImpl = __esm({
    "node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js"() {
      init_dist2();
      init_coords();
      init_dirtiness();
      init_matchesType();
      DragDropMonitorImpl = class {
        subscribeToStateChange(listener, options = {}) {
          const { handlerIds } = options;
          invariant(typeof listener === "function", "listener must be a function.");
          invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
          let prevStateId = this.store.getState().stateId;
          const handleChange = () => {
            const state = this.store.getState();
            const currentStateId = state.stateId;
            try {
              const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
              if (!canSkipListener) {
                listener();
              }
            } finally {
              prevStateId = currentStateId;
            }
          };
          return this.store.subscribe(handleChange);
        }
        subscribeToOffsetChange(listener) {
          invariant(typeof listener === "function", "listener must be a function.");
          let previousState = this.store.getState().dragOffset;
          const handleChange = () => {
            const nextState = this.store.getState().dragOffset;
            if (nextState === previousState) {
              return;
            }
            previousState = nextState;
            listener();
          };
          return this.store.subscribe(handleChange);
        }
        canDragSource(sourceId) {
          if (!sourceId) {
            return false;
          }
          const source = this.registry.getSource(sourceId);
          invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
          if (this.isDragging()) {
            return false;
          }
          return source.canDrag(this, sourceId);
        }
        canDropOnTarget(targetId) {
          if (!targetId) {
            return false;
          }
          const target = this.registry.getTarget(targetId);
          invariant(target, `Expected to find a valid target. targetId=${targetId}`);
          if (!this.isDragging() || this.didDrop()) {
            return false;
          }
          const targetType = this.registry.getTargetType(targetId);
          const draggedItemType = this.getItemType();
          return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
        }
        isDragging() {
          return Boolean(this.getItemType());
        }
        isDraggingSource(sourceId) {
          if (!sourceId) {
            return false;
          }
          const source = this.registry.getSource(sourceId, true);
          invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
          if (!this.isDragging() || !this.isSourcePublic()) {
            return false;
          }
          const sourceType = this.registry.getSourceType(sourceId);
          const draggedItemType = this.getItemType();
          if (sourceType !== draggedItemType) {
            return false;
          }
          return source.isDragging(this, sourceId);
        }
        isOverTarget(targetId, options = {
          shallow: false
        }) {
          if (!targetId) {
            return false;
          }
          const { shallow } = options;
          if (!this.isDragging()) {
            return false;
          }
          const targetType = this.registry.getTargetType(targetId);
          const draggedItemType = this.getItemType();
          if (draggedItemType && !matchesType(targetType, draggedItemType)) {
            return false;
          }
          const targetIds = this.getTargetIds();
          if (!targetIds.length) {
            return false;
          }
          const index2 = targetIds.indexOf(targetId);
          if (shallow) {
            return index2 === targetIds.length - 1;
          } else {
            return index2 > -1;
          }
        }
        getItemType() {
          return this.store.getState().dragOperation.itemType;
        }
        getItem() {
          return this.store.getState().dragOperation.item;
        }
        getSourceId() {
          return this.store.getState().dragOperation.sourceId;
        }
        getTargetIds() {
          return this.store.getState().dragOperation.targetIds;
        }
        getDropResult() {
          return this.store.getState().dragOperation.dropResult;
        }
        didDrop() {
          return this.store.getState().dragOperation.didDrop;
        }
        isSourcePublic() {
          return Boolean(this.store.getState().dragOperation.isSourcePublic);
        }
        getInitialClientOffset() {
          return this.store.getState().dragOffset.initialClientOffset;
        }
        getInitialSourceClientOffset() {
          return this.store.getState().dragOffset.initialSourceClientOffset;
        }
        getClientOffset() {
          return this.store.getState().dragOffset.clientOffset;
        }
        getSourceClientOffset() {
          return getSourceClientOffset(this.store.getState().dragOffset);
        }
        getDifferenceFromInitialOffset() {
          return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
        }
        constructor(store, registry2) {
          this.store = store;
          this.registry = registry2;
        }
      };
    }
  });

  // node_modules/@react-dnd/asap/dist/makeRequestCall.js
  function makeRequestCallFromTimer(callback2) {
    return function requestCall() {
      const timeoutHandle = setTimeout(handleTimer, 0);
      const intervalHandle = setInterval(handleTimer, 50);
      function handleTimer() {
        clearTimeout(timeoutHandle);
        clearInterval(intervalHandle);
        callback2();
      }
    };
  }
  function makeRequestCallFromMutationObserver(callback2) {
    let toggle = 1;
    const observer = new BrowserMutationObserver(callback2);
    const node = document.createTextNode("");
    observer.observe(node, {
      characterData: true
    });
    return function requestCall() {
      toggle = -toggle;
      node.data = toggle;
    };
  }
  var scope, BrowserMutationObserver, makeRequestCall;
  var init_makeRequestCall = __esm({
    "node_modules/@react-dnd/asap/dist/makeRequestCall.js"() {
      scope = typeof global !== "undefined" ? global : self;
      BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
      makeRequestCall = typeof BrowserMutationObserver === "function" ? makeRequestCallFromMutationObserver : makeRequestCallFromTimer;
    }
  });

  // node_modules/@react-dnd/asap/dist/AsapQueue.js
  var AsapQueue;
  var init_AsapQueue = __esm({
    "node_modules/@react-dnd/asap/dist/AsapQueue.js"() {
      init_makeRequestCall();
      AsapQueue = class {
        enqueueTask(task) {
          const { queue: q, requestFlush } = this;
          if (!q.length) {
            requestFlush();
            this.flushing = true;
          }
          q[q.length] = task;
        }
        constructor() {
          this.queue = [];
          this.pendingErrors = [];
          this.flushing = false;
          this.index = 0;
          this.capacity = 1024;
          this.flush = () => {
            const { queue: q } = this;
            while (this.index < q.length) {
              const currentIndex = this.index;
              this.index++;
              q[currentIndex].call();
              if (this.index > this.capacity) {
                for (let scan = 0, newLength = q.length - this.index; scan < newLength; scan++) {
                  q[scan] = q[scan + this.index];
                }
                q.length -= this.index;
                this.index = 0;
              }
            }
            q.length = 0;
            this.index = 0;
            this.flushing = false;
          };
          this.registerPendingError = (err) => {
            this.pendingErrors.push(err);
            this.requestErrorThrow();
          };
          this.requestFlush = makeRequestCall(this.flush);
          this.requestErrorThrow = makeRequestCallFromTimer(() => {
            if (this.pendingErrors.length) {
              throw this.pendingErrors.shift();
            }
          });
        }
      };
    }
  });

  // node_modules/@react-dnd/asap/dist/RawTask.js
  var RawTask;
  var init_RawTask = __esm({
    "node_modules/@react-dnd/asap/dist/RawTask.js"() {
      RawTask = class {
        call() {
          try {
            this.task && this.task();
          } catch (error) {
            this.onError(error);
          } finally {
            this.task = null;
            this.release(this);
          }
        }
        constructor(onError, release) {
          this.onError = onError;
          this.release = release;
          this.task = null;
        }
      };
    }
  });

  // node_modules/@react-dnd/asap/dist/TaskFactory.js
  var TaskFactory;
  var init_TaskFactory = __esm({
    "node_modules/@react-dnd/asap/dist/TaskFactory.js"() {
      init_RawTask();
      TaskFactory = class {
        create(task) {
          const tasks = this.freeTasks;
          const t1 = tasks.length ? tasks.pop() : new RawTask(
            this.onError,
            (t) => tasks[tasks.length] = t
          );
          t1.task = task;
          return t1;
        }
        constructor(onError) {
          this.onError = onError;
          this.freeTasks = [];
        }
      };
    }
  });

  // node_modules/@react-dnd/asap/dist/asap.js
  function asap(task) {
    asapQueue.enqueueTask(taskFactory.create(task));
  }
  var asapQueue, taskFactory;
  var init_asap = __esm({
    "node_modules/@react-dnd/asap/dist/asap.js"() {
      init_AsapQueue();
      init_TaskFactory();
      asapQueue = new AsapQueue();
      taskFactory = new TaskFactory(asapQueue.registerPendingError);
    }
  });

  // node_modules/@react-dnd/asap/dist/types.js
  var init_types2 = __esm({
    "node_modules/@react-dnd/asap/dist/types.js"() {
    }
  });

  // node_modules/@react-dnd/asap/dist/index.js
  var init_dist3 = __esm({
    "node_modules/@react-dnd/asap/dist/index.js"() {
      init_asap();
      init_AsapQueue();
      init_TaskFactory();
      init_types2();
    }
  });

  // node_modules/dnd-core/dist/actions/registry.js
  function addSource(sourceId) {
    return {
      type: ADD_SOURCE,
      payload: {
        sourceId
      }
    };
  }
  function addTarget(targetId) {
    return {
      type: ADD_TARGET,
      payload: {
        targetId
      }
    };
  }
  function removeSource(sourceId) {
    return {
      type: REMOVE_SOURCE,
      payload: {
        sourceId
      }
    };
  }
  function removeTarget(targetId) {
    return {
      type: REMOVE_TARGET,
      payload: {
        targetId
      }
    };
  }
  var ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET;
  var init_registry = __esm({
    "node_modules/dnd-core/dist/actions/registry.js"() {
      ADD_SOURCE = "dnd-core/ADD_SOURCE";
      ADD_TARGET = "dnd-core/ADD_TARGET";
      REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
      REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
    }
  });

  // node_modules/dnd-core/dist/contracts.js
  function validateSourceContract(source) {
    invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
    invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
    invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
  }
  function validateTargetContract(target) {
    invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
    invariant(typeof target.hover === "function", "Expected hover to be a function.");
    invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
  }
  function validateType(type, allowArray) {
    if (allowArray && Array.isArray(type)) {
      type.forEach(
        (t) => validateType(t, false)
      );
      return;
    }
    invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
  }
  var init_contracts = __esm({
    "node_modules/dnd-core/dist/contracts.js"() {
      init_dist2();
    }
  });

  // node_modules/dnd-core/dist/interfaces.js
  var HandlerRole;
  var init_interfaces = __esm({
    "node_modules/dnd-core/dist/interfaces.js"() {
      (function(HandlerRole2) {
        HandlerRole2["SOURCE"] = "SOURCE";
        HandlerRole2["TARGET"] = "TARGET";
      })(HandlerRole || (HandlerRole = {}));
    }
  });

  // node_modules/dnd-core/dist/utils/getNextUniqueId.js
  function getNextUniqueId() {
    return nextUniqueId++;
  }
  var nextUniqueId;
  var init_getNextUniqueId = __esm({
    "node_modules/dnd-core/dist/utils/getNextUniqueId.js"() {
      nextUniqueId = 0;
    }
  });

  // node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js
  function getNextHandlerId(role) {
    const id = getNextUniqueId().toString();
    switch (role) {
      case HandlerRole.SOURCE:
        return `S${id}`;
      case HandlerRole.TARGET:
        return `T${id}`;
      default:
        throw new Error(`Unknown Handler Role: ${role}`);
    }
  }
  function parseRoleFromHandlerId(handlerId) {
    switch (handlerId[0]) {
      case "S":
        return HandlerRole.SOURCE;
      case "T":
        return HandlerRole.TARGET;
      default:
        throw new Error(`Cannot parse handler ID: ${handlerId}`);
    }
  }
  function mapContainsValue(map3, searchValue) {
    const entries = map3.entries();
    let isDone = false;
    do {
      const { done, value: [, value2] } = entries.next();
      if (value2 === searchValue) {
        return true;
      }
      isDone = !!done;
    } while (!isDone);
    return false;
  }
  var HandlerRegistryImpl;
  var init_HandlerRegistryImpl = __esm({
    "node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js"() {
      init_dist3();
      init_dist2();
      init_registry();
      init_contracts();
      init_interfaces();
      init_getNextUniqueId();
      HandlerRegistryImpl = class {
        addSource(type, source) {
          validateType(type);
          validateSourceContract(source);
          const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
          this.store.dispatch(addSource(sourceId));
          return sourceId;
        }
        addTarget(type, target) {
          validateType(type, true);
          validateTargetContract(target);
          const targetId = this.addHandler(HandlerRole.TARGET, type, target);
          this.store.dispatch(addTarget(targetId));
          return targetId;
        }
        containsHandler(handler) {
          return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
        }
        getSource(sourceId, includePinned = false) {
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          const isPinned = includePinned && sourceId === this.pinnedSourceId;
          const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
          return source;
        }
        getTarget(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.dropTargets.get(targetId);
        }
        getSourceType(sourceId) {
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          return this.types.get(sourceId);
        }
        getTargetType(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.types.get(targetId);
        }
        isSourceId(handlerId) {
          const role = parseRoleFromHandlerId(handlerId);
          return role === HandlerRole.SOURCE;
        }
        isTargetId(handlerId) {
          const role = parseRoleFromHandlerId(handlerId);
          return role === HandlerRole.TARGET;
        }
        removeSource(sourceId) {
          invariant(this.getSource(sourceId), "Expected an existing source.");
          this.store.dispatch(removeSource(sourceId));
          asap(() => {
            this.dragSources.delete(sourceId);
            this.types.delete(sourceId);
          });
        }
        removeTarget(targetId) {
          invariant(this.getTarget(targetId), "Expected an existing target.");
          this.store.dispatch(removeTarget(targetId));
          this.dropTargets.delete(targetId);
          this.types.delete(targetId);
        }
        pinSource(sourceId) {
          const source = this.getSource(sourceId);
          invariant(source, "Expected an existing source.");
          this.pinnedSourceId = sourceId;
          this.pinnedSource = source;
        }
        unpinSource() {
          invariant(this.pinnedSource, "No source is pinned at the time.");
          this.pinnedSourceId = null;
          this.pinnedSource = null;
        }
        addHandler(role, type, handler) {
          const id = getNextHandlerId(role);
          this.types.set(id, type);
          if (role === HandlerRole.SOURCE) {
            this.dragSources.set(id, handler);
          } else if (role === HandlerRole.TARGET) {
            this.dropTargets.set(id, handler);
          }
          return id;
        }
        constructor(store) {
          this.types = /* @__PURE__ */ new Map();
          this.dragSources = /* @__PURE__ */ new Map();
          this.dropTargets = /* @__PURE__ */ new Map();
          this.pinnedSourceId = null;
          this.pinnedSource = null;
          this.store = store;
        }
      };
    }
  });

  // node_modules/dnd-core/dist/utils/equality.js
  function areCoordsEqual(offsetA, offsetB) {
    if (!offsetA && !offsetB) {
      return true;
    } else if (!offsetA || !offsetB) {
      return false;
    } else {
      return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
    }
  }
  function areArraysEqual(a, b, isEqual = strictEquality) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < a.length; ++i2) {
      if (!isEqual(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  }
  var strictEquality;
  var init_equality = __esm({
    "node_modules/dnd-core/dist/utils/equality.js"() {
      strictEquality = (a, b) => a === b;
    }
  });

  // node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js
  function reduce(_state = NONE, action) {
    switch (action.type) {
      case HOVER:
        break;
      case ADD_SOURCE:
      case ADD_TARGET:
      case REMOVE_TARGET:
      case REMOVE_SOURCE:
        return NONE;
      case BEGIN_DRAG:
      case PUBLISH_DRAG_SOURCE:
      case END_DRAG:
      case DROP:
      default:
        return ALL;
    }
    const { targetIds = [], prevTargetIds = [] } = action.payload;
    const result = xor(targetIds, prevTargetIds);
    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
    if (!didChange) {
      return NONE;
    }
    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
    const innermostTargetId = targetIds[targetIds.length - 1];
    if (prevInnermostTargetId !== innermostTargetId) {
      if (prevInnermostTargetId) {
        result.push(prevInnermostTargetId);
      }
      if (innermostTargetId) {
        result.push(innermostTargetId);
      }
    }
    return result;
  }
  var init_dirtyHandlerIds = __esm({
    "node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js"() {
      init_dragDrop();
      init_registry();
      init_dirtiness();
      init_equality();
      init_js_utils();
    }
  });

  // node_modules/dnd-core/dist/reducers/dragOffset.js
  function _defineProperty3(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    }
    return target;
  }
  function reduce2(state = initialState, action) {
    const { payload } = action;
    switch (action.type) {
      case INIT_COORDS:
      case BEGIN_DRAG:
        return {
          initialSourceClientOffset: payload.sourceClientOffset,
          initialClientOffset: payload.clientOffset,
          clientOffset: payload.clientOffset
        };
      case HOVER:
        if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
          return state;
        }
        return _objectSpread3({}, state, {
          clientOffset: payload.clientOffset
        });
      case END_DRAG:
      case DROP:
        return initialState;
      default:
        return state;
    }
  }
  var initialState;
  var init_dragOffset = __esm({
    "node_modules/dnd-core/dist/reducers/dragOffset.js"() {
      init_dragDrop();
      init_equality();
      initialState = {
        initialSourceClientOffset: null,
        initialClientOffset: null,
        clientOffset: null
      };
    }
  });

  // node_modules/dnd-core/dist/reducers/dragOperation.js
  function _defineProperty4(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _objectSpread4(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty4(target, key, source[key]);
      });
    }
    return target;
  }
  function reduce3(state = initialState2, action) {
    const { payload } = action;
    switch (action.type) {
      case BEGIN_DRAG:
        return _objectSpread4({}, state, {
          itemType: payload.itemType,
          item: payload.item,
          sourceId: payload.sourceId,
          isSourcePublic: payload.isSourcePublic,
          dropResult: null,
          didDrop: false
        });
      case PUBLISH_DRAG_SOURCE:
        return _objectSpread4({}, state, {
          isSourcePublic: true
        });
      case HOVER:
        return _objectSpread4({}, state, {
          targetIds: payload.targetIds
        });
      case REMOVE_TARGET:
        if (state.targetIds.indexOf(payload.targetId) === -1) {
          return state;
        }
        return _objectSpread4({}, state, {
          targetIds: without(state.targetIds, payload.targetId)
        });
      case DROP:
        return _objectSpread4({}, state, {
          dropResult: payload.dropResult,
          didDrop: true,
          targetIds: []
        });
      case END_DRAG:
        return _objectSpread4({}, state, {
          itemType: null,
          item: null,
          sourceId: null,
          dropResult: null,
          didDrop: false,
          isSourcePublic: null,
          targetIds: []
        });
      default:
        return state;
    }
  }
  var initialState2;
  var init_dragOperation = __esm({
    "node_modules/dnd-core/dist/reducers/dragOperation.js"() {
      init_dragDrop();
      init_registry();
      init_js_utils();
      initialState2 = {
        itemType: null,
        item: null,
        sourceId: null,
        targetIds: [],
        dropResult: null,
        didDrop: false,
        isSourcePublic: null
      };
    }
  });

  // node_modules/dnd-core/dist/reducers/refCount.js
  function reduce4(state = 0, action) {
    switch (action.type) {
      case ADD_SOURCE:
      case ADD_TARGET:
        return state + 1;
      case REMOVE_SOURCE:
      case REMOVE_TARGET:
        return state - 1;
      default:
        return state;
    }
  }
  var init_refCount = __esm({
    "node_modules/dnd-core/dist/reducers/refCount.js"() {
      init_registry();
    }
  });

  // node_modules/dnd-core/dist/reducers/stateId.js
  function reduce5(state = 0) {
    return state + 1;
  }
  var init_stateId = __esm({
    "node_modules/dnd-core/dist/reducers/stateId.js"() {
    }
  });

  // node_modules/dnd-core/dist/reducers/index.js
  function _defineProperty5(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _objectSpread5(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty5(target, key, source[key]);
      });
    }
    return target;
  }
  function reduce6(state = {}, action) {
    return {
      dirtyHandlerIds: reduce(state.dirtyHandlerIds, {
        type: action.type,
        payload: _objectSpread5({}, action.payload, {
          prevTargetIds: get(state, "dragOperation.targetIds", [])
        })
      }),
      dragOffset: reduce2(state.dragOffset, action),
      refCount: reduce4(state.refCount, action),
      dragOperation: reduce3(state.dragOperation, action),
      stateId: reduce5(state.stateId)
    };
  }
  var init_reducers = __esm({
    "node_modules/dnd-core/dist/reducers/index.js"() {
      init_js_utils();
      init_dirtyHandlerIds();
      init_dragOffset();
      init_dragOperation();
      init_refCount();
      init_stateId();
    }
  });

  // node_modules/dnd-core/dist/createDragDropManager.js
  function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
    const store = makeStoreInstance(debugMode);
    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
    const manager = new DragDropManagerImpl(store, monitor);
    const backend = backendFactory(manager, globalContext, backendOptions);
    manager.receiveBackend(backend);
    return manager;
  }
  function makeStoreInstance(debugMode) {
    const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
    return createStore(reduce6, debugMode && reduxDevTools && reduxDevTools({
      name: "dnd-core",
      instanceId: "dnd-core"
    }));
  }
  var init_createDragDropManager = __esm({
    "node_modules/dnd-core/dist/createDragDropManager.js"() {
      init_redux();
      init_DragDropManagerImpl();
      init_DragDropMonitorImpl();
      init_HandlerRegistryImpl();
      init_reducers();
    }
  });

  // node_modules/dnd-core/dist/index.js
  var init_dist4 = __esm({
    "node_modules/dnd-core/dist/index.js"() {
      init_createDragDropManager();
      init_interfaces();
    }
  });

  // node_modules/react-dnd/dist/core/DndProvider.js
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function getDndContextValue(props) {
    if ("manager" in props) {
      const manager2 = {
        dragDropManager: props.manager
      };
      return [
        manager2,
        false
      ];
    }
    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
    const isGlobalInstance = !props.context;
    return [
      manager,
      isGlobalInstance
    ];
  }
  function createSingletonDndContext(backend, context2 = getGlobalContext(), options, debugMode) {
    const ctx = context2;
    if (!ctx[INSTANCE_SYM]) {
      ctx[INSTANCE_SYM] = {
        dragDropManager: createDragDropManager(backend, context2, options, debugMode)
      };
    }
    return ctx[INSTANCE_SYM];
  }
  function getGlobalContext() {
    return typeof global !== "undefined" ? global : window;
  }
  var import_jsx_runtime, import_react3, refCount, INSTANCE_SYM, DndProvider;
  var init_DndProvider = __esm({
    "node_modules/react-dnd/dist/core/DndProvider.js"() {
      import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
      init_dist4();
      import_react3 = __toESM(require_react(), 1);
      init_DndContext();
      refCount = 0;
      INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
      DndProvider = /* @__PURE__ */ (0, import_react3.memo)(function DndProvider2(_param) {
        var { children } = _param, props = _objectWithoutProperties(_param, [
          "children"
        ]);
        const [manager, isGlobalInstance] = getDndContextValue(props);
        (0, import_react3.useEffect)(() => {
          if (isGlobalInstance) {
            const context2 = getGlobalContext();
            ++refCount;
            return () => {
              if (--refCount === 0) {
                context2[INSTANCE_SYM] = null;
              }
            };
          }
          return;
        }, []);
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DndContext.Provider, {
          value: manager,
          children
        });
      });
    }
  });

  // node_modules/react-dnd/dist/core/DragPreviewImage.js
  var import_react4, DragPreviewImage;
  var init_DragPreviewImage = __esm({
    "node_modules/react-dnd/dist/core/DragPreviewImage.js"() {
      import_react4 = __toESM(require_react(), 1);
      DragPreviewImage = (0, import_react4.memo)(function DragPreviewImage2({ connect, src }) {
        (0, import_react4.useEffect)(() => {
          if (typeof Image === "undefined")
            return;
          let connected = false;
          const img = new Image();
          img.src = src;
          img.onload = () => {
            connect(img);
            connected = true;
          };
          return () => {
            if (connected) {
              connect(null);
            }
          };
        });
        return null;
      });
    }
  });

  // node_modules/react-dnd/dist/core/index.js
  var init_core = __esm({
    "node_modules/react-dnd/dist/core/index.js"() {
      init_DndContext();
      init_DndProvider();
      init_DragPreviewImage();
    }
  });

  // node_modules/react-dnd/dist/hooks/types.js
  var init_types3 = __esm({
    "node_modules/react-dnd/dist/hooks/types.js"() {
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal2(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length2, i2, keys;
          if (Array.isArray(a)) {
            length2 = a.length;
            if (length2 != b.length)
              return false;
            for (i2 = length2; i2-- !== 0; )
              if (!equal2(a[i2], b[i2]))
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          keys = Object.keys(a);
          length2 = keys.length;
          if (length2 !== Object.keys(b).length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i2]))
              return false;
          for (i2 = length2; i2-- !== 0; ) {
            var key = keys[i2];
            if (!equal2(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js
  var import_react5, useIsomorphicLayoutEffect;
  var init_useIsomorphicLayoutEffect = __esm({
    "node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js"() {
      import_react5 = __toESM(require_react(), 1);
      useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react5.useLayoutEffect : import_react5.useEffect;
    }
  });

  // node_modules/react-dnd/dist/hooks/useCollector.js
  function useCollector(monitor, collect, onUpdate) {
    const [collected, setCollected] = (0, import_react6.useState)(
      () => collect(monitor)
    );
    const updateCollected = (0, import_react6.useCallback)(() => {
      const nextValue = collect(monitor);
      if (!(0, import_fast_deep_equal.default)(collected, nextValue)) {
        setCollected(nextValue);
        if (onUpdate) {
          onUpdate();
        }
      }
    }, [
      collected,
      monitor,
      onUpdate
    ]);
    useIsomorphicLayoutEffect(updateCollected);
    return [
      collected,
      updateCollected
    ];
  }
  var import_fast_deep_equal, import_react6;
  var init_useCollector = __esm({
    "node_modules/react-dnd/dist/hooks/useCollector.js"() {
      import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
      import_react6 = __toESM(require_react(), 1);
      init_useIsomorphicLayoutEffect();
    }
  });

  // node_modules/react-dnd/dist/hooks/useMonitorOutput.js
  function useMonitorOutput(monitor, collect, onCollect) {
    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
      const handlerId = monitor.getHandlerId();
      if (handlerId == null) {
        return;
      }
      return monitor.subscribeToStateChange(updateCollected, {
        handlerIds: [
          handlerId
        ]
      });
    }, [
      monitor,
      updateCollected
    ]);
    return collected;
  }
  var init_useMonitorOutput = __esm({
    "node_modules/react-dnd/dist/hooks/useMonitorOutput.js"() {
      init_useCollector();
      init_useIsomorphicLayoutEffect();
    }
  });

  // node_modules/react-dnd/dist/hooks/useCollectedProps.js
  function useCollectedProps(collector, monitor, connector) {
    return useMonitorOutput(
      monitor,
      collector || (() => ({})),
      () => connector.reconnect()
    );
  }
  var init_useCollectedProps = __esm({
    "node_modules/react-dnd/dist/hooks/useCollectedProps.js"() {
      init_useMonitorOutput();
    }
  });

  // node_modules/react-dnd/dist/hooks/useOptionalFactory.js
  function useOptionalFactory(arg, deps) {
    const memoDeps = [
      ...deps || []
    ];
    if (deps == null && typeof arg !== "function") {
      memoDeps.push(arg);
    }
    return (0, import_react7.useMemo)(() => {
      return typeof arg === "function" ? arg() : arg;
    }, memoDeps);
  }
  var import_react7;
  var init_useOptionalFactory = __esm({
    "node_modules/react-dnd/dist/hooks/useOptionalFactory.js"() {
      import_react7 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/connectors.js
  function useConnectDragSource(connector) {
    return (0, import_react8.useMemo)(
      () => connector.hooks.dragSource(),
      [
        connector
      ]
    );
  }
  function useConnectDragPreview(connector) {
    return (0, import_react8.useMemo)(
      () => connector.hooks.dragPreview(),
      [
        connector
      ]
    );
  }
  var import_react8;
  var init_connectors = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/connectors.js"() {
      import_react8 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js
  var isCallingCanDrag, isCallingIsDragging, DragSourceMonitorImpl;
  var init_DragSourceMonitorImpl = __esm({
    "node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js"() {
      init_dist2();
      isCallingCanDrag = false;
      isCallingIsDragging = false;
      DragSourceMonitorImpl = class {
        receiveHandlerId(sourceId) {
          this.sourceId = sourceId;
        }
        getHandlerId() {
          return this.sourceId;
        }
        canDrag() {
          invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
          } finally {
            isCallingCanDrag = false;
          }
        }
        isDragging() {
          if (!this.sourceId) {
            return false;
          }
          invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
          } finally {
            isCallingIsDragging = false;
          }
        }
        subscribeToStateChange(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        }
        isDraggingSource(sourceId) {
          return this.internalMonitor.isDraggingSource(sourceId);
        }
        isOverTarget(targetId, options) {
          return this.internalMonitor.isOverTarget(targetId, options);
        }
        getTargetIds() {
          return this.internalMonitor.getTargetIds();
        }
        isSourcePublic() {
          return this.internalMonitor.isSourcePublic();
        }
        getSourceId() {
          return this.internalMonitor.getSourceId();
        }
        subscribeToOffsetChange(listener) {
          return this.internalMonitor.subscribeToOffsetChange(listener);
        }
        canDragSource(sourceId) {
          return this.internalMonitor.canDragSource(sourceId);
        }
        canDropOnTarget(targetId) {
          return this.internalMonitor.canDropOnTarget(targetId);
        }
        getItemType() {
          return this.internalMonitor.getItemType();
        }
        getItem() {
          return this.internalMonitor.getItem();
        }
        getDropResult() {
          return this.internalMonitor.getDropResult();
        }
        didDrop() {
          return this.internalMonitor.didDrop();
        }
        getInitialClientOffset() {
          return this.internalMonitor.getInitialClientOffset();
        }
        getInitialSourceClientOffset() {
          return this.internalMonitor.getInitialSourceClientOffset();
        }
        getSourceClientOffset() {
          return this.internalMonitor.getSourceClientOffset();
        }
        getClientOffset() {
          return this.internalMonitor.getClientOffset();
        }
        getDifferenceFromInitialOffset() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        }
        constructor(manager) {
          this.sourceId = null;
          this.internalMonitor = manager.getMonitor();
        }
      };
    }
  });

  // node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js
  var isCallingCanDrop, DropTargetMonitorImpl;
  var init_DropTargetMonitorImpl = __esm({
    "node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js"() {
      init_dist2();
      isCallingCanDrop = false;
      DropTargetMonitorImpl = class {
        receiveHandlerId(targetId) {
          this.targetId = targetId;
        }
        getHandlerId() {
          return this.targetId;
        }
        subscribeToStateChange(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        }
        canDrop() {
          if (!this.targetId) {
            return false;
          }
          invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
          try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
          } finally {
            isCallingCanDrop = false;
          }
        }
        isOver(options) {
          if (!this.targetId) {
            return false;
          }
          return this.internalMonitor.isOverTarget(this.targetId, options);
        }
        getItemType() {
          return this.internalMonitor.getItemType();
        }
        getItem() {
          return this.internalMonitor.getItem();
        }
        getDropResult() {
          return this.internalMonitor.getDropResult();
        }
        didDrop() {
          return this.internalMonitor.didDrop();
        }
        getInitialClientOffset() {
          return this.internalMonitor.getInitialClientOffset();
        }
        getInitialSourceClientOffset() {
          return this.internalMonitor.getInitialSourceClientOffset();
        }
        getSourceClientOffset() {
          return this.internalMonitor.getSourceClientOffset();
        }
        getClientOffset() {
          return this.internalMonitor.getClientOffset();
        }
        getDifferenceFromInitialOffset() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        }
        constructor(manager) {
          this.targetId = null;
          this.internalMonitor = manager.getMonitor();
        }
      };
    }
  });

  // node_modules/react-dnd/dist/internals/registration.js
  function registerTarget(type, target, manager) {
    const registry2 = manager.getRegistry();
    const targetId = registry2.addTarget(type, target);
    return [
      targetId,
      () => registry2.removeTarget(targetId)
    ];
  }
  function registerSource(type, source, manager) {
    const registry2 = manager.getRegistry();
    const sourceId = registry2.addSource(type, source);
    return [
      sourceId,
      () => registry2.removeSource(sourceId)
    ];
  }
  var init_registration = __esm({
    "node_modules/react-dnd/dist/internals/registration.js"() {
    }
  });

  // node_modules/@react-dnd/shallowequal/dist/index.js
  function shallowEqual(objA, objB, compare, compareContext) {
    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (compareResult !== void 0) {
      return !!compareResult;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    for (let idx = 0; idx < keysA.length; idx++) {
      const key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      const valueA = objA[key];
      const valueB = objB[key];
      compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
      if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  }
  var init_dist5 = __esm({
    "node_modules/@react-dnd/shallowequal/dist/index.js"() {
    }
  });

  // node_modules/react-dnd/dist/internals/isRef.js
  function isRef(obj) {
    return obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current");
  }
  var init_isRef = __esm({
    "node_modules/react-dnd/dist/internals/isRef.js"() {
    }
  });

  // node_modules/react-dnd/dist/internals/wrapConnectorHooks.js
  function throwIfCompositeComponentElement(element) {
    if (typeof element.type === "string") {
      return;
    }
    const displayName = element.type.displayName || element.type.name || "the component";
    throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
  }
  function wrapHookToRecognizeElement(hook) {
    return (elementOrNode = null, options = null) => {
      if (!(0, import_react9.isValidElement)(elementOrNode)) {
        const node = elementOrNode;
        hook(node, options);
        return node;
      }
      const element = elementOrNode;
      throwIfCompositeComponentElement(element);
      const ref = options ? (node) => hook(node, options) : hook;
      return cloneWithRef(element, ref);
    };
  }
  function wrapConnectorHooks(hooks2) {
    const wrappedHooks = {};
    Object.keys(hooks2).forEach((key) => {
      const hook = hooks2[key];
      if (key.endsWith("Ref")) {
        wrappedHooks[key] = hooks2[key];
      } else {
        const wrappedHook = wrapHookToRecognizeElement(hook);
        wrappedHooks[key] = () => wrappedHook;
      }
    });
    return wrappedHooks;
  }
  function setRef(ref, node) {
    if (typeof ref === "function") {
      ref(node);
    } else {
      ref.current = node;
    }
  }
  function cloneWithRef(element, newRef) {
    const previousRef = element.ref;
    invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
    if (!previousRef) {
      return (0, import_react9.cloneElement)(element, {
        ref: newRef
      });
    } else {
      return (0, import_react9.cloneElement)(element, {
        ref: (node) => {
          setRef(previousRef, node);
          setRef(newRef, node);
        }
      });
    }
  }
  var import_react9;
  var init_wrapConnectorHooks = __esm({
    "node_modules/react-dnd/dist/internals/wrapConnectorHooks.js"() {
      init_dist2();
      import_react9 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/internals/SourceConnector.js
  var SourceConnector;
  var init_SourceConnector = __esm({
    "node_modules/react-dnd/dist/internals/SourceConnector.js"() {
      init_dist5();
      init_isRef();
      init_wrapConnectorHooks();
      SourceConnector = class {
        receiveHandlerId(newHandlerId) {
          if (this.handlerId === newHandlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        }
        get connectTarget() {
          return this.dragSource;
        }
        get dragSourceOptions() {
          return this.dragSourceOptionsInternal;
        }
        set dragSourceOptions(options) {
          this.dragSourceOptionsInternal = options;
        }
        get dragPreviewOptions() {
          return this.dragPreviewOptionsInternal;
        }
        set dragPreviewOptions(options) {
          this.dragPreviewOptionsInternal = options;
        }
        reconnect() {
          const didChange = this.reconnectDragSource();
          this.reconnectDragPreview(didChange);
        }
        reconnectDragSource() {
          const dragSource = this.dragSource;
          const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
          if (didChange) {
            this.disconnectDragSource();
          }
          if (!this.handlerId) {
            return didChange;
          }
          if (!dragSource) {
            this.lastConnectedDragSource = dragSource;
            return didChange;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragSource = dragSource;
            this.lastConnectedDragSourceOptions = this.dragSourceOptions;
            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
          }
          return didChange;
        }
        reconnectDragPreview(forceDidChange = false) {
          const dragPreview = this.dragPreview;
          const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
          if (didChange) {
            this.disconnectDragPreview();
          }
          if (!this.handlerId) {
            return;
          }
          if (!dragPreview) {
            this.lastConnectedDragPreview = dragPreview;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragPreview = dragPreview;
            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
          }
        }
        didHandlerIdChange() {
          return this.lastConnectedHandlerId !== this.handlerId;
        }
        didConnectedDragSourceChange() {
          return this.lastConnectedDragSource !== this.dragSource;
        }
        didConnectedDragPreviewChange() {
          return this.lastConnectedDragPreview !== this.dragPreview;
        }
        didDragSourceOptionsChange() {
          return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
        }
        didDragPreviewOptionsChange() {
          return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
        }
        disconnectDragSource() {
          if (this.dragSourceUnsubscribe) {
            this.dragSourceUnsubscribe();
            this.dragSourceUnsubscribe = void 0;
          }
        }
        disconnectDragPreview() {
          if (this.dragPreviewUnsubscribe) {
            this.dragPreviewUnsubscribe();
            this.dragPreviewUnsubscribe = void 0;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
          }
        }
        get dragSource() {
          return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
        }
        get dragPreview() {
          return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
        }
        clearDragSource() {
          this.dragSourceNode = null;
          this.dragSourceRef = null;
        }
        clearDragPreview() {
          this.dragPreviewNode = null;
          this.dragPreviewRef = null;
        }
        constructor(backend) {
          this.hooks = wrapConnectorHooks({
            dragSource: (node, options) => {
              this.clearDragSource();
              this.dragSourceOptions = options || null;
              if (isRef(node)) {
                this.dragSourceRef = node;
              } else {
                this.dragSourceNode = node;
              }
              this.reconnectDragSource();
            },
            dragPreview: (node, options) => {
              this.clearDragPreview();
              this.dragPreviewOptions = options || null;
              if (isRef(node)) {
                this.dragPreviewRef = node;
              } else {
                this.dragPreviewNode = node;
              }
              this.reconnectDragPreview();
            }
          });
          this.handlerId = null;
          this.dragSourceRef = null;
          this.dragSourceOptionsInternal = null;
          this.dragPreviewRef = null;
          this.dragPreviewOptionsInternal = null;
          this.lastConnectedHandlerId = null;
          this.lastConnectedDragSource = null;
          this.lastConnectedDragSourceOptions = null;
          this.lastConnectedDragPreview = null;
          this.lastConnectedDragPreviewOptions = null;
          this.backend = backend;
        }
      };
    }
  });

  // node_modules/react-dnd/dist/internals/TargetConnector.js
  var TargetConnector;
  var init_TargetConnector = __esm({
    "node_modules/react-dnd/dist/internals/TargetConnector.js"() {
      init_dist5();
      init_isRef();
      init_wrapConnectorHooks();
      TargetConnector = class {
        get connectTarget() {
          return this.dropTarget;
        }
        reconnect() {
          const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
          if (didChange) {
            this.disconnectDropTarget();
          }
          const dropTarget = this.dropTarget;
          if (!this.handlerId) {
            return;
          }
          if (!dropTarget) {
            this.lastConnectedDropTarget = dropTarget;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDropTarget = dropTarget;
            this.lastConnectedDropTargetOptions = this.dropTargetOptions;
            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
          }
        }
        receiveHandlerId(newHandlerId) {
          if (newHandlerId === this.handlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        }
        get dropTargetOptions() {
          return this.dropTargetOptionsInternal;
        }
        set dropTargetOptions(options) {
          this.dropTargetOptionsInternal = options;
        }
        didHandlerIdChange() {
          return this.lastConnectedHandlerId !== this.handlerId;
        }
        didDropTargetChange() {
          return this.lastConnectedDropTarget !== this.dropTarget;
        }
        didOptionsChange() {
          return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
        }
        disconnectDropTarget() {
          if (this.unsubscribeDropTarget) {
            this.unsubscribeDropTarget();
            this.unsubscribeDropTarget = void 0;
          }
        }
        get dropTarget() {
          return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
        }
        clearDropTarget() {
          this.dropTargetRef = null;
          this.dropTargetNode = null;
        }
        constructor(backend) {
          this.hooks = wrapConnectorHooks({
            dropTarget: (node, options) => {
              this.clearDropTarget();
              this.dropTargetOptions = options;
              if (isRef(node)) {
                this.dropTargetRef = node;
              } else {
                this.dropTargetNode = node;
              }
              this.reconnect();
            }
          });
          this.handlerId = null;
          this.dropTargetRef = null;
          this.dropTargetOptionsInternal = null;
          this.lastConnectedHandlerId = null;
          this.lastConnectedDropTarget = null;
          this.lastConnectedDropTargetOptions = null;
          this.backend = backend;
        }
      };
    }
  });

  // node_modules/react-dnd/dist/internals/index.js
  var init_internals = __esm({
    "node_modules/react-dnd/dist/internals/index.js"() {
      init_DragSourceMonitorImpl();
      init_DropTargetMonitorImpl();
      init_registration();
      init_SourceConnector();
      init_TargetConnector();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDragDropManager.js
  function useDragDropManager() {
    const { dragDropManager } = (0, import_react10.useContext)(DndContext);
    invariant(dragDropManager != null, "Expected drag drop context");
    return dragDropManager;
  }
  var import_react10;
  var init_useDragDropManager = __esm({
    "node_modules/react-dnd/dist/hooks/useDragDropManager.js"() {
      init_dist2();
      import_react10 = __toESM(require_react(), 1);
      init_core();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js
  function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
    const manager = useDragDropManager();
    const connector = (0, import_react11.useMemo)(
      () => new SourceConnector(manager.getBackend()),
      [
        manager
      ]
    );
    useIsomorphicLayoutEffect(() => {
      connector.dragSourceOptions = dragSourceOptions || null;
      connector.reconnect();
      return () => connector.disconnectDragSource();
    }, [
      connector,
      dragSourceOptions
    ]);
    useIsomorphicLayoutEffect(() => {
      connector.dragPreviewOptions = dragPreviewOptions || null;
      connector.reconnect();
      return () => connector.disconnectDragPreview();
    }, [
      connector,
      dragPreviewOptions
    ]);
    return connector;
  }
  var import_react11;
  var init_useDragSourceConnector = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js"() {
      import_react11 = __toESM(require_react(), 1);
      init_internals();
      init_useDragDropManager();
      init_useIsomorphicLayoutEffect();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js
  function useDragSourceMonitor() {
    const manager = useDragDropManager();
    return (0, import_react12.useMemo)(
      () => new DragSourceMonitorImpl(manager),
      [
        manager
      ]
    );
  }
  var import_react12;
  var init_useDragSourceMonitor = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js"() {
      import_react12 = __toESM(require_react(), 1);
      init_internals();
      init_useDragDropManager();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js
  var DragSourceImpl;
  var init_DragSourceImpl = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js"() {
      DragSourceImpl = class {
        beginDrag() {
          const spec = this.spec;
          const monitor = this.monitor;
          let result = null;
          if (typeof spec.item === "object") {
            result = spec.item;
          } else if (typeof spec.item === "function") {
            result = spec.item(monitor);
          } else {
            result = {};
          }
          return result !== null && result !== void 0 ? result : null;
        }
        canDrag() {
          const spec = this.spec;
          const monitor = this.monitor;
          if (typeof spec.canDrag === "boolean") {
            return spec.canDrag;
          } else if (typeof spec.canDrag === "function") {
            return spec.canDrag(monitor);
          } else {
            return true;
          }
        }
        isDragging(globalMonitor, target) {
          const spec = this.spec;
          const monitor = this.monitor;
          const { isDragging } = spec;
          return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
        }
        endDrag() {
          const spec = this.spec;
          const monitor = this.monitor;
          const connector = this.connector;
          const { end } = spec;
          if (end) {
            end(monitor.getItem(), monitor);
          }
          connector.reconnect();
        }
        constructor(spec, monitor, connector) {
          this.spec = spec;
          this.monitor = monitor;
          this.connector = connector;
        }
      };
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js
  function useDragSource(spec, monitor, connector) {
    const handler = (0, import_react13.useMemo)(
      () => new DragSourceImpl(spec, monitor, connector),
      [
        monitor,
        connector
      ]
    );
    (0, import_react13.useEffect)(() => {
      handler.spec = spec;
    }, [
      spec
    ]);
    return handler;
  }
  var import_react13;
  var init_useDragSource = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js"() {
      import_react13 = __toESM(require_react(), 1);
      init_DragSourceImpl();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useDragType.js
  function useDragType(spec) {
    return (0, import_react14.useMemo)(() => {
      const result = spec.type;
      invariant(result != null, "spec.type must be defined");
      return result;
    }, [
      spec
    ]);
  }
  var import_react14;
  var init_useDragType = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useDragType.js"() {
      init_dist2();
      import_react14 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js
  function useRegisteredDragSource(spec, monitor, connector) {
    const manager = useDragDropManager();
    const handler = useDragSource(spec, monitor, connector);
    const itemType = useDragType(spec);
    useIsomorphicLayoutEffect(function registerDragSource() {
      if (itemType != null) {
        const [handlerId, unregister] = registerSource(itemType, handler, manager);
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
      }
      return;
    }, [
      manager,
      monitor,
      connector,
      handler,
      itemType
    ]);
  }
  var init_useRegisteredDragSource = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js"() {
      init_internals();
      init_useDragDropManager();
      init_useIsomorphicLayoutEffect();
      init_useDragSource();
      init_useDragType();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/useDrag.js
  function useDrag(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
    const monitor = useDragSourceMonitor();
    const connector = useDragSourceConnector(spec.options, spec.previewOptions);
    useRegisteredDragSource(spec, monitor, connector);
    return [
      useCollectedProps(spec.collect, monitor, connector),
      useConnectDragSource(connector),
      useConnectDragPreview(connector)
    ];
  }
  var init_useDrag = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/useDrag.js"() {
      init_dist2();
      init_useCollectedProps();
      init_useOptionalFactory();
      init_connectors();
      init_useDragSourceConnector();
      init_useDragSourceMonitor();
      init_useRegisteredDragSource();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrag/index.js
  var init_useDrag2 = __esm({
    "node_modules/react-dnd/dist/hooks/useDrag/index.js"() {
      init_useDrag();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDragLayer.js
  var import_react15;
  var init_useDragLayer = __esm({
    "node_modules/react-dnd/dist/hooks/useDragLayer.js"() {
      import_react15 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/connectors.js
  function useConnectDropTarget(connector) {
    return (0, import_react16.useMemo)(
      () => connector.hooks.dropTarget(),
      [
        connector
      ]
    );
  }
  var import_react16;
  var init_connectors2 = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/connectors.js"() {
      import_react16 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js
  function useDropTargetConnector(options) {
    const manager = useDragDropManager();
    const connector = (0, import_react17.useMemo)(
      () => new TargetConnector(manager.getBackend()),
      [
        manager
      ]
    );
    useIsomorphicLayoutEffect(() => {
      connector.dropTargetOptions = options || null;
      connector.reconnect();
      return () => connector.disconnectDropTarget();
    }, [
      options
    ]);
    return connector;
  }
  var import_react17;
  var init_useDropTargetConnector = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js"() {
      import_react17 = __toESM(require_react(), 1);
      init_internals();
      init_useDragDropManager();
      init_useIsomorphicLayoutEffect();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js
  function useDropTargetMonitor() {
    const manager = useDragDropManager();
    return (0, import_react18.useMemo)(
      () => new DropTargetMonitorImpl(manager),
      [
        manager
      ]
    );
  }
  var import_react18;
  var init_useDropTargetMonitor = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js"() {
      import_react18 = __toESM(require_react(), 1);
      init_internals();
      init_useDragDropManager();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useAccept.js
  function useAccept(spec) {
    const { accept } = spec;
    return (0, import_react19.useMemo)(() => {
      invariant(spec.accept != null, "accept must be defined");
      return Array.isArray(accept) ? accept : [
        accept
      ];
    }, [
      accept
    ]);
  }
  var import_react19;
  var init_useAccept = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useAccept.js"() {
      init_dist2();
      import_react19 = __toESM(require_react(), 1);
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js
  var DropTargetImpl;
  var init_DropTargetImpl = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js"() {
      DropTargetImpl = class {
        canDrop() {
          const spec = this.spec;
          const monitor = this.monitor;
          return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
        }
        hover() {
          const spec = this.spec;
          const monitor = this.monitor;
          if (spec.hover) {
            spec.hover(monitor.getItem(), monitor);
          }
        }
        drop() {
          const spec = this.spec;
          const monitor = this.monitor;
          if (spec.drop) {
            return spec.drop(monitor.getItem(), monitor);
          }
          return;
        }
        constructor(spec, monitor) {
          this.spec = spec;
          this.monitor = monitor;
        }
      };
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js
  function useDropTarget(spec, monitor) {
    const dropTarget = (0, import_react20.useMemo)(
      () => new DropTargetImpl(spec, monitor),
      [
        monitor
      ]
    );
    (0, import_react20.useEffect)(() => {
      dropTarget.spec = spec;
    }, [
      spec
    ]);
    return dropTarget;
  }
  var import_react20;
  var init_useDropTarget = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js"() {
      import_react20 = __toESM(require_react(), 1);
      init_DropTargetImpl();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js
  function useRegisteredDropTarget(spec, monitor, connector) {
    const manager = useDragDropManager();
    const dropTarget = useDropTarget(spec, monitor);
    const accept = useAccept(spec);
    useIsomorphicLayoutEffect(function registerDropTarget() {
      const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }, [
      manager,
      monitor,
      dropTarget,
      connector,
      accept.map(
        (a) => a.toString()
      ).join("|")
    ]);
  }
  var init_useRegisteredDropTarget = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js"() {
      init_internals();
      init_useDragDropManager();
      init_useIsomorphicLayoutEffect();
      init_useAccept();
      init_useDropTarget();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/useDrop.js
  function useDrop(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    const monitor = useDropTargetMonitor();
    const connector = useDropTargetConnector(spec.options);
    useRegisteredDropTarget(spec, monitor, connector);
    return [
      useCollectedProps(spec.collect, monitor, connector),
      useConnectDropTarget(connector)
    ];
  }
  var init_useDrop = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/useDrop.js"() {
      init_useCollectedProps();
      init_useOptionalFactory();
      init_connectors2();
      init_useDropTargetConnector();
      init_useDropTargetMonitor();
      init_useRegisteredDropTarget();
    }
  });

  // node_modules/react-dnd/dist/hooks/useDrop/index.js
  var init_useDrop2 = __esm({
    "node_modules/react-dnd/dist/hooks/useDrop/index.js"() {
      init_useDrop();
    }
  });

  // node_modules/react-dnd/dist/hooks/index.js
  var init_hooks = __esm({
    "node_modules/react-dnd/dist/hooks/index.js"() {
      init_types3();
      init_useDrag2();
      init_useDragDropManager();
      init_useDragLayer();
      init_useDrop2();
    }
  });

  // node_modules/react-dnd/dist/types/connectors.js
  var init_connectors3 = __esm({
    "node_modules/react-dnd/dist/types/connectors.js"() {
    }
  });

  // node_modules/react-dnd/dist/types/monitors.js
  var init_monitors = __esm({
    "node_modules/react-dnd/dist/types/monitors.js"() {
    }
  });

  // node_modules/react-dnd/dist/types/options.js
  var init_options = __esm({
    "node_modules/react-dnd/dist/types/options.js"() {
    }
  });

  // node_modules/react-dnd/dist/types/index.js
  var init_types4 = __esm({
    "node_modules/react-dnd/dist/types/index.js"() {
      init_connectors3();
      init_monitors();
      init_options();
    }
  });

  // node_modules/react-dnd/dist/index.js
  var init_dist6 = __esm({
    "node_modules/react-dnd/dist/index.js"() {
      init_core();
      init_hooks();
      init_types4();
    }
  });

  // node_modules/react-dnd-html5-backend/dist/utils/js_utils.js
  function memoize(fn) {
    let result = null;
    const memoized = () => {
      if (result == null) {
        result = fn();
      }
      return result;
    };
    return memoized;
  }
  function without2(items, item) {
    return items.filter(
      (i2) => i2 !== item
    );
  }
  function union(itemsA, itemsB) {
    const set2 = /* @__PURE__ */ new Set();
    const insertItem = (item) => set2.add(item);
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    set2.forEach(
      (key) => result.push(key)
    );
    return result;
  }
  var init_js_utils2 = __esm({
    "node_modules/react-dnd-html5-backend/dist/utils/js_utils.js"() {
    }
  });

  // node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js
  var EnterLeaveCounter;
  var init_EnterLeaveCounter = __esm({
    "node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js"() {
      init_js_utils2();
      EnterLeaveCounter = class {
        enter(enteringNode) {
          const previousLength = this.entered.length;
          const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
          this.entered = union(this.entered.filter(isNodeEntered), [
            enteringNode
          ]);
          return previousLength === 0 && this.entered.length > 0;
        }
        leave(leavingNode) {
          const previousLength = this.entered.length;
          this.entered = without2(this.entered.filter(this.isNodeInDocument), leavingNode);
          return previousLength > 0 && this.entered.length === 0;
        }
        reset() {
          this.entered = [];
        }
        constructor(isNodeInDocument) {
          this.entered = [];
          this.isNodeInDocument = isNodeInDocument;
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js
  var NativeDragSource;
  var init_NativeDragSource = __esm({
    "node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js"() {
      NativeDragSource = class {
        initializeExposedProperties() {
          Object.keys(this.config.exposeProperties).forEach((property) => {
            Object.defineProperty(this.item, property, {
              configurable: true,
              enumerable: true,
              get() {
                console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
                return null;
              }
            });
          });
        }
        loadDataTransfer(dataTransfer) {
          if (dataTransfer) {
            const newProperties = {};
            Object.keys(this.config.exposeProperties).forEach((property) => {
              const propertyFn2 = this.config.exposeProperties[property];
              if (propertyFn2 != null) {
                newProperties[property] = {
                  value: propertyFn2(dataTransfer, this.config.matchesTypes),
                  configurable: true,
                  enumerable: true
                };
              }
            });
            Object.defineProperties(this.item, newProperties);
          }
        }
        canDrag() {
          return true;
        }
        beginDrag() {
          return this.item;
        }
        isDragging(monitor, handle) {
          return handle === monitor.getSourceId();
        }
        endDrag() {
        }
        constructor(config) {
          this.config = config;
          this.item = {};
          this.initializeExposedProperties();
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/NativeTypes.js
  var NativeTypes_exports = {};
  __export(NativeTypes_exports, {
    FILE: () => FILE,
    HTML: () => HTML,
    TEXT: () => TEXT,
    URL: () => URL2
  });
  var FILE, URL2, TEXT, HTML;
  var init_NativeTypes = __esm({
    "node_modules/react-dnd-html5-backend/dist/NativeTypes.js"() {
      FILE = "__NATIVE_FILE__";
      URL2 = "__NATIVE_URL__";
      TEXT = "__NATIVE_TEXT__";
      HTML = "__NATIVE_HTML__";
    }
  });

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js
  function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
    const result = typesToTry.reduce(
      (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
      ""
    );
    return result != null ? result : defaultValue;
  }
  var init_getDataFromDataTransfer = __esm({
    "node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js"() {
    }
  });

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js
  var nativeTypesConfig;
  var init_nativeTypesConfig = __esm({
    "node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js"() {
      init_NativeTypes();
      init_getDataFromDataTransfer();
      nativeTypesConfig = {
        [FILE]: {
          exposeProperties: {
            files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
            items: (dataTransfer) => dataTransfer.items,
            dataTransfer: (dataTransfer) => dataTransfer
          },
          matchesTypes: [
            "Files"
          ]
        },
        [HTML]: {
          exposeProperties: {
            html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
            dataTransfer: (dataTransfer) => dataTransfer
          },
          matchesTypes: [
            "Html",
            "text/html"
          ]
        },
        [URL2]: {
          exposeProperties: {
            urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
            dataTransfer: (dataTransfer) => dataTransfer
          },
          matchesTypes: [
            "Url",
            "text/uri-list"
          ]
        },
        [TEXT]: {
          exposeProperties: {
            text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
            dataTransfer: (dataTransfer) => dataTransfer
          },
          matchesTypes: [
            "Text",
            "text/plain"
          ]
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js
  function createNativeDragSource(type, dataTransfer) {
    const config = nativeTypesConfig[type];
    if (!config) {
      throw new Error(`native type ${type} has no configuration`);
    }
    const result = new NativeDragSource(config);
    result.loadDataTransfer(dataTransfer);
    return result;
  }
  function matchNativeItemType(dataTransfer) {
    if (!dataTransfer) {
      return null;
    }
    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
    return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
      const typeConfig = nativeTypesConfig[nativeItemType];
      if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
        return false;
      }
      return typeConfig.matchesTypes.some(
        (t) => dataTransferTypes.indexOf(t) > -1
      );
    })[0] || null;
  }
  var init_NativeDragSources = __esm({
    "node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js"() {
      init_NativeDragSource();
      init_nativeTypesConfig();
    }
  });

  // node_modules/react-dnd-html5-backend/dist/BrowserDetector.js
  var isFirefox, isSafari;
  var init_BrowserDetector = __esm({
    "node_modules/react-dnd-html5-backend/dist/BrowserDetector.js"() {
      init_js_utils2();
      isFirefox = memoize(
        () => /firefox/i.test(navigator.userAgent)
      );
      isSafari = memoize(
        () => Boolean(window.safari)
      );
    }
  });

  // node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js
  var MonotonicInterpolant;
  var init_MonotonicInterpolant = __esm({
    "node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js"() {
      MonotonicInterpolant = class {
        interpolate(x) {
          const { xs, ys, c1s, c2s, c3s } = this;
          let i2 = xs.length - 1;
          if (x === xs[i2]) {
            return ys[i2];
          }
          let low = 0;
          let high = c3s.length - 1;
          let mid;
          while (low <= high) {
            mid = Math.floor(0.5 * (low + high));
            const xHere = xs[mid];
            if (xHere < x) {
              low = mid + 1;
            } else if (xHere > x) {
              high = mid - 1;
            } else {
              return ys[mid];
            }
          }
          i2 = Math.max(0, high);
          const diff = x - xs[i2];
          const diffSq = diff * diff;
          return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
        }
        constructor(xs, ys) {
          const { length: length2 } = xs;
          const indexes = [];
          for (let i2 = 0; i2 < length2; i2++) {
            indexes.push(i2);
          }
          indexes.sort(
            (a, b) => xs[a] < xs[b] ? -1 : 1
          );
          const dys = [];
          const dxs = [];
          const ms = [];
          let dx;
          let dy;
          for (let i1 = 0; i1 < length2 - 1; i1++) {
            dx = xs[i1 + 1] - xs[i1];
            dy = ys[i1 + 1] - ys[i1];
            dxs.push(dx);
            dys.push(dy);
            ms.push(dy / dx);
          }
          const c1s = [
            ms[0]
          ];
          for (let i2 = 0; i2 < dxs.length - 1; i2++) {
            const m2 = ms[i2];
            const mNext = ms[i2 + 1];
            if (m2 * mNext <= 0) {
              c1s.push(0);
            } else {
              dx = dxs[i2];
              const dxNext = dxs[i2 + 1];
              const common = dx + dxNext;
              c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));
            }
          }
          c1s.push(ms[ms.length - 1]);
          const c2s = [];
          const c3s = [];
          let m;
          for (let i3 = 0; i3 < c1s.length - 1; i3++) {
            m = ms[i3];
            const c1 = c1s[i3];
            const invDx = 1 / dxs[i3];
            const common = c1 + c1s[i3 + 1] - m - m;
            c2s.push((m - c1 - common) * invDx);
            c3s.push(common * invDx * invDx);
          }
          this.xs = xs;
          this.ys = ys;
          this.c1s = c1s;
          this.c2s = c2s;
          this.c3s = c3s;
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/OffsetUtils.js
  function getNodeClientOffset(node) {
    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
      return null;
    }
    const { top, left } = el.getBoundingClientRect();
    return {
      x: left,
      y: top
    };
  }
  function getEventClientOffset(e) {
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  function isImageNode(node) {
    var ref;
    return node.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
  }
  function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    if (isSafari() && isImage) {
      dragPreviewHeight /= window.devicePixelRatio;
      dragPreviewWidth /= window.devicePixelRatio;
    }
    return {
      dragPreviewWidth,
      dragPreviewHeight
    };
  }
  function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    const isImage = isImageNode(dragPreview);
    const dragPreviewNode = isImage ? sourceNode : dragPreview;
    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    const offsetFromDragPreview = {
      x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
      y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
    };
    const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
    const { anchorX, anchorY } = anchorPoint;
    const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
    const calculateYOffset = () => {
      const interpolantY = new MonotonicInterpolant([
        0,
        0.5,
        1
      ], [
        offsetFromDragPreview.y,
        offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
        offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
      ]);
      let y = interpolantY.interpolate(anchorY);
      if (isSafari() && isImage) {
        y += (window.devicePixelRatio - 1) * dragPreviewHeight;
      }
      return y;
    };
    const calculateXOffset = () => {
      const interpolantX = new MonotonicInterpolant([
        0,
        0.5,
        1
      ], [
        offsetFromDragPreview.x,
        offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
        offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
      ]);
      return interpolantX.interpolate(anchorX);
    };
    const { offsetX, offsetY } = offsetPoint;
    const isManualOffsetX = offsetX === 0 || offsetX;
    const isManualOffsetY = offsetY === 0 || offsetY;
    return {
      x: isManualOffsetX ? offsetX : calculateXOffset(),
      y: isManualOffsetY ? offsetY : calculateYOffset()
    };
  }
  var ELEMENT_NODE;
  var init_OffsetUtils = __esm({
    "node_modules/react-dnd-html5-backend/dist/OffsetUtils.js"() {
      init_BrowserDetector();
      init_MonotonicInterpolant();
      ELEMENT_NODE = 1;
    }
  });

  // node_modules/react-dnd-html5-backend/dist/OptionsReader.js
  var OptionsReader;
  var init_OptionsReader = __esm({
    "node_modules/react-dnd-html5-backend/dist/OptionsReader.js"() {
      OptionsReader = class {
        get window() {
          if (this.globalContext) {
            return this.globalContext;
          } else if (typeof window !== "undefined") {
            return window;
          }
          return void 0;
        }
        get document() {
          var ref;
          if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
            return this.globalContext.document;
          } else if (this.window) {
            return this.window.document;
          } else {
            return void 0;
          }
        }
        get rootElement() {
          var ref;
          return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
        }
        constructor(globalContext, options) {
          this.ownerDocument = null;
          this.globalContext = globalContext;
          this.optionsArgs = options;
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js
  function _defineProperty6(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _objectSpread6(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty6(target, key, source[key]);
      });
    }
    return target;
  }
  var HTML5BackendImpl;
  var init_HTML5BackendImpl = __esm({
    "node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js"() {
      init_EnterLeaveCounter();
      init_NativeDragSources();
      init_NativeTypes();
      init_OffsetUtils();
      init_OptionsReader();
      HTML5BackendImpl = class {
        profile() {
          var ref, ref1;
          return {
            sourcePreviewNodes: this.sourcePreviewNodes.size,
            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
            sourceNodeOptions: this.sourceNodeOptions.size,
            sourceNodes: this.sourceNodes.size,
            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
            dropTargetIds: this.dropTargetIds.length,
            dragEnterTargetIds: this.dragEnterTargetIds.length,
            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
          };
        }
        get window() {
          return this.options.window;
        }
        get document() {
          return this.options.document;
        }
        get rootElement() {
          return this.options.rootElement;
        }
        setup() {
          const root = this.rootElement;
          if (root === void 0) {
            return;
          }
          if (root.__isReactDndBackendSetUp) {
            throw new Error("Cannot have two HTML5 backends at the same time.");
          }
          root.__isReactDndBackendSetUp = true;
          this.addEventListeners(root);
        }
        teardown() {
          const root = this.rootElement;
          if (root === void 0) {
            return;
          }
          root.__isReactDndBackendSetUp = false;
          this.removeEventListeners(this.rootElement);
          this.clearCurrentDragSourceNode();
          if (this.asyncEndDragFrameId) {
            var ref;
            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
          }
        }
        connectDragPreview(sourceId, node, options) {
          this.sourcePreviewNodeOptions.set(sourceId, options);
          this.sourcePreviewNodes.set(sourceId, node);
          return () => {
            this.sourcePreviewNodes.delete(sourceId);
            this.sourcePreviewNodeOptions.delete(sourceId);
          };
        }
        connectDragSource(sourceId, node, options) {
          this.sourceNodes.set(sourceId, node);
          this.sourceNodeOptions.set(sourceId, options);
          const handleDragStart = (e) => this.handleDragStart(e, sourceId);
          const handleSelectStart = (e) => this.handleSelectStart(e);
          node.setAttribute("draggable", "true");
          node.addEventListener("dragstart", handleDragStart);
          node.addEventListener("selectstart", handleSelectStart);
          return () => {
            this.sourceNodes.delete(sourceId);
            this.sourceNodeOptions.delete(sourceId);
            node.removeEventListener("dragstart", handleDragStart);
            node.removeEventListener("selectstart", handleSelectStart);
            node.setAttribute("draggable", "false");
          };
        }
        connectDropTarget(targetId, node) {
          const handleDragEnter = (e) => this.handleDragEnter(e, targetId);
          const handleDragOver = (e) => this.handleDragOver(e, targetId);
          const handleDrop = (e) => this.handleDrop(e, targetId);
          node.addEventListener("dragenter", handleDragEnter);
          node.addEventListener("dragover", handleDragOver);
          node.addEventListener("drop", handleDrop);
          return () => {
            node.removeEventListener("dragenter", handleDragEnter);
            node.removeEventListener("dragover", handleDragOver);
            node.removeEventListener("drop", handleDrop);
          };
        }
        addEventListeners(target) {
          if (!target.addEventListener) {
            return;
          }
          target.addEventListener("dragstart", this.handleTopDragStart);
          target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
          target.addEventListener("dragend", this.handleTopDragEndCapture, true);
          target.addEventListener("dragenter", this.handleTopDragEnter);
          target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
          target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
          target.addEventListener("dragover", this.handleTopDragOver);
          target.addEventListener("dragover", this.handleTopDragOverCapture, true);
          target.addEventListener("drop", this.handleTopDrop);
          target.addEventListener("drop", this.handleTopDropCapture, true);
        }
        removeEventListeners(target) {
          if (!target.removeEventListener) {
            return;
          }
          target.removeEventListener("dragstart", this.handleTopDragStart);
          target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
          target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
          target.removeEventListener("dragenter", this.handleTopDragEnter);
          target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
          target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
          target.removeEventListener("dragover", this.handleTopDragOver);
          target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
          target.removeEventListener("drop", this.handleTopDrop);
          target.removeEventListener("drop", this.handleTopDropCapture, true);
        }
        getCurrentSourceNodeOptions() {
          const sourceId = this.monitor.getSourceId();
          const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
          return _objectSpread6({
            dropEffect: this.altKeyPressed ? "copy" : "move"
          }, sourceNodeOptions || {});
        }
        getCurrentDropEffect() {
          if (this.isDraggingNativeItem()) {
            return "copy";
          }
          return this.getCurrentSourceNodeOptions().dropEffect;
        }
        getCurrentSourcePreviewNodeOptions() {
          const sourceId = this.monitor.getSourceId();
          const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
          return _objectSpread6({
            anchorX: 0.5,
            anchorY: 0.5,
            captureDraggingState: false
          }, sourcePreviewNodeOptions || {});
        }
        isDraggingNativeItem() {
          const itemType = this.monitor.getItemType();
          return Object.keys(NativeTypes_exports).some(
            (key) => NativeTypes_exports[key] === itemType
          );
        }
        beginDragNativeItem(type, dataTransfer) {
          this.clearCurrentDragSourceNode();
          this.currentNativeSource = createNativeDragSource(type, dataTransfer);
          this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
          this.actions.beginDrag([
            this.currentNativeHandle
          ]);
        }
        setCurrentDragSourceNode(node) {
          this.clearCurrentDragSourceNode();
          this.currentDragSourceNode = node;
          const MOUSE_MOVE_TIMEOUT = 1e3;
          this.mouseMoveTimeoutTimer = setTimeout(() => {
            var ref;
            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
          }, MOUSE_MOVE_TIMEOUT);
        }
        clearCurrentDragSourceNode() {
          if (this.currentDragSourceNode) {
            this.currentDragSourceNode = null;
            if (this.rootElement) {
              var ref;
              (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
              this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
            }
            this.mouseMoveTimeoutTimer = null;
            return true;
          }
          return false;
        }
        handleDragStart(e, sourceId) {
          if (e.defaultPrevented) {
            return;
          }
          if (!this.dragStartSourceIds) {
            this.dragStartSourceIds = [];
          }
          this.dragStartSourceIds.unshift(sourceId);
        }
        handleDragEnter(_e, targetId) {
          this.dragEnterTargetIds.unshift(targetId);
        }
        handleDragOver(_e, targetId) {
          if (this.dragOverTargetIds === null) {
            this.dragOverTargetIds = [];
          }
          this.dragOverTargetIds.unshift(targetId);
        }
        handleDrop(_e, targetId) {
          this.dropTargetIds.unshift(targetId);
        }
        constructor(manager, globalContext, options) {
          this.sourcePreviewNodes = /* @__PURE__ */ new Map();
          this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
          this.sourceNodes = /* @__PURE__ */ new Map();
          this.sourceNodeOptions = /* @__PURE__ */ new Map();
          this.dragStartSourceIds = null;
          this.dropTargetIds = [];
          this.dragEnterTargetIds = [];
          this.currentNativeSource = null;
          this.currentNativeHandle = null;
          this.currentDragSourceNode = null;
          this.altKeyPressed = false;
          this.mouseMoveTimeoutTimer = null;
          this.asyncEndDragFrameId = null;
          this.dragOverTargetIds = null;
          this.lastClientOffset = null;
          this.hoverRafId = null;
          this.getSourceClientOffset = (sourceId) => {
            const source = this.sourceNodes.get(sourceId);
            return source && getNodeClientOffset(source) || null;
          };
          this.endDragNativeItem = () => {
            if (!this.isDraggingNativeItem()) {
              return;
            }
            this.actions.endDrag();
            if (this.currentNativeHandle) {
              this.registry.removeSource(this.currentNativeHandle);
            }
            this.currentNativeHandle = null;
            this.currentNativeSource = null;
          };
          this.isNodeInDocument = (node) => {
            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
          };
          this.endDragIfSourceWasRemovedFromDOM = () => {
            const node = this.currentDragSourceNode;
            if (node == null || this.isNodeInDocument(node)) {
              return;
            }
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
              this.actions.endDrag();
            }
            this.cancelHover();
          };
          this.scheduleHover = (dragOverTargetIds) => {
            if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
              this.hoverRafId = requestAnimationFrame(() => {
                if (this.monitor.isDragging()) {
                  this.actions.hover(dragOverTargetIds || [], {
                    clientOffset: this.lastClientOffset
                  });
                }
                this.hoverRafId = null;
              });
            }
          };
          this.cancelHover = () => {
            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
              cancelAnimationFrame(this.hoverRafId);
              this.hoverRafId = null;
            }
          };
          this.handleTopDragStartCapture = () => {
            this.clearCurrentDragSourceNode();
            this.dragStartSourceIds = [];
          };
          this.handleTopDragStart = (e) => {
            if (e.defaultPrevented) {
              return;
            }
            const { dragStartSourceIds } = this;
            this.dragStartSourceIds = null;
            const clientOffset = getEventClientOffset(e);
            if (this.monitor.isDragging()) {
              this.actions.endDrag();
              this.cancelHover();
            }
            this.actions.beginDrag(dragStartSourceIds || [], {
              publishSource: false,
              getSourceClientOffset: this.getSourceClientOffset,
              clientOffset
            });
            const { dataTransfer } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (this.monitor.isDragging()) {
              if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
                const sourceId = this.monitor.getSourceId();
                const sourceNode = this.sourceNodes.get(sourceId);
                const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
                if (dragPreview) {
                  const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
                  const anchorPoint = {
                    anchorX,
                    anchorY
                  };
                  const offsetPoint = {
                    offsetX,
                    offsetY
                  };
                  const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                  dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
                }
              }
              try {
                dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
              } catch (err) {
              }
              this.setCurrentDragSourceNode(e.target);
              const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
              if (!captureDraggingState) {
                setTimeout(
                  () => this.actions.publishDragSource(),
                  0
                );
              } else {
                this.actions.publishDragSource();
              }
            } else if (nativeType) {
              this.beginDragNativeItem(nativeType);
            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute("draggable"))) {
              return;
            } else {
              e.preventDefault();
            }
          };
          this.handleTopDragEndCapture = () => {
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
              this.actions.endDrag();
            }
            this.cancelHover();
          };
          this.handleTopDragEnterCapture = (e) => {
            this.dragEnterTargetIds = [];
            if (this.isDraggingNativeItem()) {
              var ref;
              (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
            const isFirstEnter = this.enterLeaveCounter.enter(e.target);
            if (!isFirstEnter || this.monitor.isDragging()) {
              return;
            }
            const { dataTransfer } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (nativeType) {
              this.beginDragNativeItem(nativeType, dataTransfer);
            }
          };
          this.handleTopDragEnter = (e) => {
            const { dragEnterTargetIds } = this;
            this.dragEnterTargetIds = [];
            if (!this.monitor.isDragging()) {
              return;
            }
            this.altKeyPressed = e.altKey;
            if (dragEnterTargetIds.length > 0) {
              this.actions.hover(dragEnterTargetIds, {
                clientOffset: getEventClientOffset(e)
              });
            }
            const canDrop = dragEnterTargetIds.some(
              (targetId) => this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
              e.preventDefault();
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = this.getCurrentDropEffect();
              }
            }
          };
          this.handleTopDragOverCapture = (e) => {
            this.dragOverTargetIds = [];
            if (this.isDraggingNativeItem()) {
              var ref;
              (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
          };
          this.handleTopDragOver = (e) => {
            const { dragOverTargetIds } = this;
            this.dragOverTargetIds = [];
            if (!this.monitor.isDragging()) {
              e.preventDefault();
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = "none";
              }
              return;
            }
            this.altKeyPressed = e.altKey;
            this.lastClientOffset = getEventClientOffset(e);
            this.scheduleHover(dragOverTargetIds);
            const canDrop = (dragOverTargetIds || []).some(
              (targetId) => this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
              e.preventDefault();
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = this.getCurrentDropEffect();
              }
            } else if (this.isDraggingNativeItem()) {
              e.preventDefault();
            } else {
              e.preventDefault();
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = "none";
              }
            }
          };
          this.handleTopDragLeaveCapture = (e) => {
            if (this.isDraggingNativeItem()) {
              e.preventDefault();
            }
            const isLastLeave = this.enterLeaveCounter.leave(e.target);
            if (!isLastLeave) {
              return;
            }
            if (this.isDraggingNativeItem()) {
              setTimeout(
                () => this.endDragNativeItem(),
                0
              );
            }
            this.cancelHover();
          };
          this.handleTopDropCapture = (e) => {
            this.dropTargetIds = [];
            if (this.isDraggingNativeItem()) {
              var ref;
              e.preventDefault();
              (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            } else if (matchNativeItemType(e.dataTransfer)) {
              e.preventDefault();
            }
            this.enterLeaveCounter.reset();
          };
          this.handleTopDrop = (e) => {
            const { dropTargetIds } = this;
            this.dropTargetIds = [];
            this.actions.hover(dropTargetIds, {
              clientOffset: getEventClientOffset(e)
            });
            this.actions.drop({
              dropEffect: this.getCurrentDropEffect()
            });
            if (this.isDraggingNativeItem()) {
              this.endDragNativeItem();
            } else if (this.monitor.isDragging()) {
              this.actions.endDrag();
            }
            this.cancelHover();
          };
          this.handleSelectStart = (e) => {
            const target = e.target;
            if (typeof target.dragDrop !== "function") {
              return;
            }
            if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
              return;
            }
            e.preventDefault();
            target.dragDrop();
          };
          this.options = new OptionsReader(globalContext, options);
          this.actions = manager.getActions();
          this.monitor = manager.getMonitor();
          this.registry = manager.getRegistry();
          this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
        }
      };
    }
  });

  // node_modules/react-dnd-html5-backend/dist/index.js
  var HTML5Backend;
  var init_dist7 = __esm({
    "node_modules/react-dnd-html5-backend/dist/index.js"() {
      init_HTML5BackendImpl();
      HTML5Backend = function createBackend(manager, context2, options) {
        return new HTML5BackendImpl(manager, context2, options);
      };
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/GeneratedOutlines.js
  var Libs13, Button4, Card2, Checkbox3, Typography7, Tooltip6, ComposeComponents13, GeneratedOutlines;
  var init_GeneratedOutlines = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/GeneratedOutlines.js"() {
      ({ Libs: Libs13 } = window.getGenie.Components.Common);
      ({ Button: Button4, Card: Card2, Checkbox: Checkbox3, Typography: Typography7, Tooltip: Tooltip6 } = window.antd);
      ({ ComposeComponents: ComposeComponents13 } = window.getGenie.Components.Common.ReduxManager);
      GeneratedOutlines = ComposeComponents13(({ setInput, getInputs, sidebar: sidebar4, visible, width }) => {
        const selectedOutlines = getInputs["selectedOutlines"] || [];
        const generatedOutlines = getInputs["generatedOutlines"] || [];
        const loading = sidebar4.generatedOutlines.loading;
        const onChange = (text) => {
          let items = [...selectedOutlines];
          if (items.indexOf(text) != -1) {
            items.splice(items.indexOf(text), 1);
          } else {
            items.push(text);
          }
          setInput("selectedOutlines", items);
        };
        const checkEveryElementExists = (arr = []) => {
          return [...arr].filter((r) => selectedOutlines.includes(r)).length === arr.length;
        };
        const handleAllSelect = (arr, isAllSelected) => {
          let items = [...selectedOutlines];
          if (isAllSelected) {
            let filtered = [];
            selectedOutlines.forEach((item, index2) => {
              if (arr.indexOf(item) == -1) {
                if (filtered.indexOf(item) === -1) {
                  filtered.push(item);
                }
              }
            });
            items = filtered;
          } else {
            items = [...selectedOutlines, ...arr];
          }
          setInput("selectedOutlines", items);
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: `getgenie-generated-outlines ${visible ? "" : "d-none"}`,
          style: { width: `${width}px` }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-empty-tag"
        }), /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-generated-outlines-title"
        }, /* @__PURE__ */ React.createElement(Tooltip6, {
          title: sidebar4.__("Select subheadings to create your content outline.", "getgenie"),
          placement: "top"
        }, sidebar4.__("Generated Outlines", "getgenie")), /* @__PURE__ */ React.createElement(Typography7.Text, {
          className: "generateMsg outline"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "resultNumber"
        }, generatedOutlines.length))), loading ? /* @__PURE__ */ React.createElement(Libs13.SkeletonCard, {
          count: 5
        }) : generatedOutlines.length === 0 ? /* @__PURE__ */ React.createElement(Typography7.Title, {
          level: 5,
          className: "getgenie-not-found-title"
        }, " ", sidebar4.__("Something Went Wrong! Please Try Again.", "getgenie"), " ") : /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-generated-outlines-cards"
        }, generatedOutlines.map((arr, index2) => /* @__PURE__ */ React.createElement(Card2, {
          key: index2,
          className: "getgenie-generated-outlines-card"
        }, /* @__PURE__ */ React.createElement(Button4, {
          className: "getgenie-generated-outlines-card-select-btn",
          type: "link",
          onClick: () => handleAllSelect(arr, checkEveryElementExists(arr))
        }, checkEveryElementExists(arr) ? sidebar4.__("Unselect All", "getgenie") : sidebar4.__("Select All", "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-checkbox"
        }, arr.map((item, childIndex) => /* @__PURE__ */ React.createElement("div", {
          key: childIndex,
          className: `getgenie-checkbox-container${selectedOutlines.indexOf(item) != -1 ? sidebar4.__(" active", "getgenie") : ""}`
        }, /* @__PURE__ */ React.createElement(Checkbox3, {
          checked: selectedOutlines.indexOf(item) != -1,
          onChange: () => onChange(item)
        }, item))))))));
      }, ["setInput", "getInputs", "sidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/Outline.js
  var useRef2, useState9, Button5, Dropdown, Menu, ComposeComponents14, GenieHelpers6, Outline;
  var init_Outline = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/Outline.js"() {
      init_dist6();
      ({ useRef: useRef2, useState: useState9 } = window.React);
      ({ Button: Button5, Dropdown, Menu } = window.antd);
      ({ ComposeComponents: ComposeComponents14 } = window.getGenie.Components.Common.ReduxManager);
      ({ GenieHelpers: GenieHelpers6 } = window.getGenie.Components.Common.Utilities);
      Outline = ComposeComponents14(({ outlines: outlines2, setOutlines, swapOutlines, id, text, index: index2, setInput, getInputs, sidebar: sidebar4 }) => {
        const [editableText, setEditableText] = useState9("");
        const [inputVal, setInputVal] = useState9("");
        const ref = useRef2(null);
        const [{ handlerId }, drop] = useDrop({
          accept: "card",
          collect(monitor) {
            return {
              handlerId: monitor.getHandlerId()
            };
          },
          hover(item, monitor) {
            if (!ref.current) {
              return;
            }
            const dragIndex = item.index;
            const hoverIndex = index2;
            if (dragIndex === hoverIndex) {
              return;
            }
            const hoverBoundingRect = ref.current?.getBoundingClientRect();
            const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
            const clientOffset = monitor.getClientOffset();
            const hoverClientY = clientOffset.y - hoverBoundingRect.top;
            if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
              return;
            }
            if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
              return;
            }
            swapOutlines(dragIndex, hoverIndex);
            item.index = hoverIndex;
          }
        });
        const [{ isDragging }, drag] = useDrag({
          type: "card",
          item: () => {
            return { id, index: index2 };
          },
          collect: (monitor) => {
            return {
              isDragging: monitor.isDragging()
            };
          }
        });
        const opacity = isDragging ? 0 : 1;
        drag(drop(ref));
        const handleEditedText = (e, itemIndex) => {
          if (e.type === "keyup" && (e.key !== "Enter" || e?.which !== 13)) {
            setInputVal(e.target.value);
            return;
          }
          let items = outlines2.map((item, index3) => index3 === itemIndex ? { ...item, text: inputVal } : item);
          items = items.filter((item) => item.text);
          setOutlines(items);
          setInput("selectedOutlines", items.map((item) => item.text));
          setEditableText("");
          if (e.type === "keyup") {
            setInputVal("");
          }
        };
        const editOutline = (text2) => {
          setEditableText(text2);
          setInputVal(text2);
        };
        const removeOutline = (text2) => {
          let items = outlines2.filter((item) => item.text !== text2);
          let allParagraphs = getInputs["generatedParagraphs"];
          delete allParagraphs?.[text2];
          setInput("generatedParagraphs", allParagraphs);
          GenieHelpers6.callStoreApi("generatedParagraphs", allParagraphs);
          setOutlines(items);
        };
        const menu = (text2) => {
          return /* @__PURE__ */ React.createElement(Menu, {
            className: "getgenie-outline-menu"
          }, /* @__PURE__ */ React.createElement(Menu.Item, {
            key: "0"
          }, /* @__PURE__ */ React.createElement(Button5, {
            type: "text",
            onClick: () => editOutline(text2)
          }, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-edit icon"
          }), sidebar4.__("Edit", "getgenie"))), /* @__PURE__ */ React.createElement(Menu.Item, {
            key: "1"
          }, /* @__PURE__ */ React.createElement(Button5, {
            type: "text",
            onClick: () => removeOutline(text2)
          }, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-trash icon"
          }), sidebar4.__("Delete", "getgenie"))));
        };
        return /* @__PURE__ */ React.createElement("div", {
          ref,
          "data-handler-id": handlerId,
          style: { cursor: "grab", opacity },
          className: `getgenie-single-outline ${editableText === text ? "outline-input" : "outline-content"}`
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-outline-cards-content"
        }, editableText === text ? /* @__PURE__ */ React.createElement("textarea", {
          autoFocus: true,
          onFocus: (e) => e.target.selectionStart = text.length,
          onBlur: (e) => handleEditedText(e, index2),
          className: "getgenie-outline-cards-input",
          defaultValue: text,
          onKeyDown: (e) => e.stopPropagation(),
          onKeyUp: (e) => handleEditedText(e, index2)
        }) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h5", {
          onDoubleClick: () => editOutline(text),
          className: "generated-content"
        }, text), /* @__PURE__ */ React.createElement(Dropdown, {
          overlay: menu(text),
          trigger: ["click"],
          zIndex: 9999
        }, /* @__PURE__ */ React.createElement(Button5, {
          type: "text",
          className: "getgenie-outline-cards-menuBtn"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-more-vertical"
        }))))));
      }, ["getInputs", "setInput", "sidebar"]);
    }
  });

  // node_modules/immutability-helper/index.js
  var require_immutability_helper = __commonJS({
    "node_modules/immutability-helper/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function stringifiable(obj) {
        return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
      }
      var isProduction4 = typeof process === "object" && false;
      function invariant3(condition, message) {
        if (!condition) {
          if (isProduction4) {
            throw new Error("Invariant failed");
          }
          throw new Error(message());
        }
      }
      exports.invariant = invariant3;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var splice = Array.prototype.splice;
      var toString2 = Object.prototype.toString;
      function type(obj) {
        return toString2.call(obj).slice(8, -1);
      }
      var assign = Object.assign || function(target, source) {
        getAllKeys(source).forEach(function(key) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        });
        return target;
      };
      var getAllKeys = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
        return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
      } : function(obj) {
        return Object.keys(obj);
      };
      function copy(object) {
        return Array.isArray(object) ? assign(object.constructor(object.length), object) : type(object) === "Map" ? new Map(object) : type(object) === "Set" ? new Set(object) : object && typeof object === "object" ? assign(Object.create(Object.getPrototypeOf(object)), object) : object;
      }
      var Context = function() {
        function Context2() {
          this.commands = assign({}, defaultCommands);
          this.update = this.update.bind(this);
          this.update.extend = this.extend = this.extend.bind(this);
          this.update.isEquals = function(x, y) {
            return x === y;
          };
          this.update.newContext = function() {
            return new Context2().update;
          };
        }
        Object.defineProperty(Context2.prototype, "isEquals", {
          get: function() {
            return this.update.isEquals;
          },
          set: function(value2) {
            this.update.isEquals = value2;
          },
          enumerable: true,
          configurable: true
        });
        Context2.prototype.extend = function(directive, fn) {
          this.commands[directive] = fn;
        };
        Context2.prototype.update = function(object, $spec) {
          var _this = this;
          var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
          if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant3(!Array.isArray(spec), function() {
              return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
            });
          }
          invariant3(typeof spec === "object" && spec !== null, function() {
            return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
          });
          var nextObject = object;
          getAllKeys(spec).forEach(function(key) {
            if (hasOwnProperty.call(_this.commands, key)) {
              var objectWasNextObject = object === nextObject;
              nextObject = _this.commands[key](spec[key], nextObject, spec, object);
              if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                nextObject = object;
              }
            } else {
              var nextValueForKey = type(object) === "Map" ? _this.update(object.get(key), spec[key]) : _this.update(object[key], spec[key]);
              var nextObjectValue = type(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
              if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty.call(object, key)) {
                if (nextObject === object) {
                  nextObject = copy(object);
                }
                if (type(nextObject) === "Map") {
                  nextObject.set(key, nextValueForKey);
                } else {
                  nextObject[key] = nextValueForKey;
                }
              }
            }
          });
          return nextObject;
        };
        return Context2;
      }();
      exports.Context = Context;
      var defaultCommands = {
        $push: function(value2, nextObject, spec) {
          invariantPushAndUnshift(nextObject, spec, "$push");
          return value2.length ? nextObject.concat(value2) : nextObject;
        },
        $unshift: function(value2, nextObject, spec) {
          invariantPushAndUnshift(nextObject, spec, "$unshift");
          return value2.length ? value2.concat(nextObject) : nextObject;
        },
        $splice: function(value2, nextObject, spec, originalObject) {
          invariantSplices(nextObject, spec);
          value2.forEach(function(args) {
            invariantSplice(args);
            if (nextObject === originalObject && args.length) {
              nextObject = copy(originalObject);
            }
            splice.apply(nextObject, args);
          });
          return nextObject;
        },
        $set: function(value2, _nextObject, spec) {
          invariantSet(spec);
          return value2;
        },
        $toggle: function(targets, nextObject) {
          invariantSpecArray(targets, "$toggle");
          var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
          targets.forEach(function(target) {
            nextObjectCopy[target] = !nextObject[target];
          });
          return nextObjectCopy;
        },
        $unset: function(value2, nextObject, _spec, originalObject) {
          invariantSpecArray(value2, "$unset");
          value2.forEach(function(key) {
            if (Object.hasOwnProperty.call(nextObject, key)) {
              if (nextObject === originalObject) {
                nextObject = copy(originalObject);
              }
              delete nextObject[key];
            }
          });
          return nextObject;
        },
        $add: function(values, nextObject, _spec, originalObject) {
          invariantMapOrSet(nextObject, "$add");
          invariantSpecArray(values, "$add");
          if (type(nextObject) === "Map") {
            values.forEach(function(_a) {
              var key = _a[0], value2 = _a[1];
              if (nextObject === originalObject && nextObject.get(key) !== value2) {
                nextObject = copy(originalObject);
              }
              nextObject.set(key, value2);
            });
          } else {
            values.forEach(function(value2) {
              if (nextObject === originalObject && !nextObject.has(value2)) {
                nextObject = copy(originalObject);
              }
              nextObject.add(value2);
            });
          }
          return nextObject;
        },
        $remove: function(value2, nextObject, _spec, originalObject) {
          invariantMapOrSet(nextObject, "$remove");
          invariantSpecArray(value2, "$remove");
          value2.forEach(function(key) {
            if (nextObject === originalObject && nextObject.has(key)) {
              nextObject = copy(originalObject);
            }
            nextObject.delete(key);
          });
          return nextObject;
        },
        $merge: function(value2, nextObject, _spec, originalObject) {
          invariantMerge(nextObject, value2);
          getAllKeys(value2).forEach(function(key) {
            if (value2[key] !== nextObject[key]) {
              if (nextObject === originalObject) {
                nextObject = copy(originalObject);
              }
              nextObject[key] = value2[key];
            }
          });
          return nextObject;
        },
        $apply: function(value2, original) {
          invariantApply(value2);
          return value2(original);
        }
      };
      var defaultContext = new Context();
      exports.isEquals = defaultContext.update.isEquals;
      exports.extend = defaultContext.extend;
      exports.default = defaultContext.update;
      exports.default.default = module.exports = assign(exports.default, exports);
      function invariantPushAndUnshift(value2, spec, command) {
        invariant3(Array.isArray(value2), function() {
          return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value2) + ".";
        });
        invariantSpecArray(spec[command], command);
      }
      function invariantSpecArray(spec, command) {
        invariant3(Array.isArray(spec), function() {
          return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
        });
      }
      function invariantSplices(value2, spec) {
        invariant3(Array.isArray(value2), function() {
          return "Expected $splice target to be an array; got " + stringifiable(value2);
        });
        invariantSplice(spec.$splice);
      }
      function invariantSplice(value2) {
        invariant3(Array.isArray(value2), function() {
          return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value2) + ". Did you forget to wrap your parameters in an array?";
        });
      }
      function invariantApply(fn) {
        invariant3(typeof fn === "function", function() {
          return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
        });
      }
      function invariantSet(spec) {
        invariant3(Object.keys(spec).length === 1, function() {
          return "Cannot have more than one key in an object with $set";
        });
      }
      function invariantMerge(target, specValue) {
        invariant3(specValue && typeof specValue === "object", function() {
          return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
        });
        invariant3(target && typeof target === "object", function() {
          return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
        });
      }
      function invariantMapOrSet(target, command) {
        var typeOfTarget = type(target);
        invariant3(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
          return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
        });
      }
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/SelectedOutlines.js
  var import_immutability_helper, useState10, useCallback2, useEffect15, ComposeComponents15, Button6, SelectedOutlines;
  var init_SelectedOutlines = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/SelectedOutlines.js"() {
      init_Outline();
      import_immutability_helper = __toESM(require_immutability_helper());
      ({ useState: useState10, useCallback: useCallback2, useEffect: useEffect15 } = window.React);
      ({ ComposeComponents: ComposeComponents15 } = window.getGenie.Components.Common.ReduxManager);
      ({ Button: Button6 } = window.antd);
      SelectedOutlines = ComposeComponents15(({ getInputs, setInput, sidebar: sidebar4 }) => {
        let selectedOutlines = getInputs["selectedOutlines"] ? [...new Set(getInputs["selectedOutlines"])] : [];
        const addOutline = () => {
          setOutlineArr((prevCards) => [...prevCards, { text: "", id: "" }]);
        };
        const [outlineArr, setOutlineArr] = useState10(selectedOutlines.map((item, index2) => ({ text: item, id: index2 + 1 })));
        useEffect15(() => {
          const updatedOutlines = outlineArr.map((item) => item.text);
          if (selectedOutlines.length >= outlineArr.length) {
            setInput("selectedOutlines", updatedOutlines);
          }
        }, [outlineArr]);
        useEffect15(() => {
          if (selectedOutlines.length !== outlineArr.length) {
            setOutlineArr(selectedOutlines.map((item, index2) => ({ text: item, id: index2 + 1 })));
          }
        }, [getInputs["selectedOutlines"]]);
        const swapOutlines = useCallback2((dragIndex, hoverIndex) => {
          setOutlineArr(
            (prevCards) => (0, import_immutability_helper.default)(prevCards, {
              $splice: [
                [dragIndex, 1],
                [hoverIndex, 0, prevCards[dragIndex]]
              ]
            })
          );
        }, []);
        const direction = sidebar4.languages.find((item) => item.value === sidebar4.currentLanguage)?.writingDirection;
        return /* @__PURE__ */ React.createElement("div", {
          className: `getgenie-card ${direction}`
        }, outlineArr.map((card, index2) => /* @__PURE__ */ React.createElement(Outline, {
          key: card.id,
          index: index2,
          id: card.id,
          text: card.text,
          swapOutlines,
          outlines: outlineArr,
          setOutlines: setOutlineArr
        })), /* @__PURE__ */ React.createElement(Button6, {
          onClick: addOutline,
          type: "primary",
          className: "add-outline-btn"
        }, sidebar4.__("Add Outline", "getgenie")));
      }, ["getInputs", "setInput", "sidebar"]);
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/index.js
  var Libs14, Utilities8, Alert, Form3, Modal2, Steps, Divider5, Step, ComposeComponents16, HandleFetch4, HandleResponse5, useEffect16, useState11, interval, OutlineScreen, OutlineScreen_default;
  var init_OutlineScreen = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/OutlineScreen/index.js"() {
      init_esm4();
      init_dist6();
      init_dist7();
      init_SidebarControllerOption();
      init_InsertHandler();
      init_GeneratedOutlines();
      init_SelectedOutlines();
      ({ Libs: Libs14, Utilities: Utilities8 } = window.getGenie.Components.Common);
      ({ Alert, Form: Form3, Modal: Modal2, Steps, Divider: Divider5 } = window.antd);
      ({ Step } = Steps);
      ({ ComposeComponents: ComposeComponents16 } = window.getGenie.Components.Common.ReduxManager);
      ({ HandleFetch: HandleFetch4, HandleResponse: HandleResponse5 } = window.getGenie.Components.Common.RequestManager);
      ({ useEffect: useEffect16, useState: useState11 } = window.React);
      OutlineScreen = ComposeComponents16(({ setSidebar, sidebar: sidebar4, getInputs, setInput }) => {
        const loading = sidebar4.generatedOutlines.loading;
        const selectedOutlines = getInputs["selectedOutlines"] ? [...new Set(getInputs["selectedOutlines"])] : [];
        const [visibleAlert, setVisibleAlert] = useState11(false);
        const [open, setOpen] = useState11(false);
        const [confirmLoading, setConfirmLoading] = useState11(false);
        const initialModalText = "Do you want to create the entire blog with just one click, or would you prefer to generate the content step-by-step?";
        const [modalText, setModalText] = useState11(initialModalText);
        const [step, setStep] = useState11(0);
        let insertHandler = new InsertHandler(window.getGenie.config.isBlockEditor);
        let isOneClickBlogSupported = sidebar4.languages.find((item) => item.value === sidebar4.currentLanguage)?.oneClick;
        const loadingText = [
          "Researching",
          "Getting data",
          "Adding keywords",
          "Cooking content"
        ];
        useEffect16(() => {
          Utilities8.GenieHelpers.callStoreApi("selectedTitle", getInputs["selectedTitle"]);
          Utilities8.GenieHelpers.callStoreApi("selectedIntro", getInputs["selectedIntro"]);
        }, []);
        useEffect16(() => {
          if (confirmLoading) {
            interval = setInterval(() => {
              setStep((prev2) => {
                if (prev2 === 3) {
                  clearInterval(interval);
                  return prev2;
                } else {
                  return prev2 + 1;
                }
              });
            }, 5e3);
          } else {
            if (interval) {
              clearInterval(interval);
            }
            setStep(0);
          }
        }, [confirmLoading]);
        const onFinish = () => {
          let data = {
            input: {
              title: getInputs["selectedTitle"],
              intro: getInputs["selectedIntro"],
              context: getInputs["inputContext"]
            },
            templateSlug: "blog-wizard-outline"
          };
          setInput("generatedOutlines", "");
          setSidebar({
            generatedOutlines: {
              open: true,
              loading: true
            }
          });
          HandleFetch4((res) => {
            setSidebar({
              generatedOutlines: {
                open: true,
                loading: false
              }
            });
            HandleResponse5(res, () => {
              setInput("generatedOutlines", res.data);
              setInput("seoEnabled", true);
              setVisibleAlert(true);
              Utilities8.GenieHelpers.callStoreApi("generatedOutlines", res.data);
            });
          }, "outlines", data);
        };
        function removeFirstLastBrTags(inputStr) {
          if (inputStr.startsWith("<br>") || inputStr.startsWith("<br/>") || inputStr.startsWith("<br />")) {
            inputStr = inputStr.substring(4);
          }
          if (inputStr.endsWith("<br>") || inputStr.endsWith("<br/>") || inputStr.endsWith("<br />")) {
            inputStr = inputStr.substring(0, inputStr.length - 4);
          }
          return inputStr;
        }
        function removePTags(expandedOutline) {
          expandedOutline = expandedOutline.replace(/<br\/?>/g, "\n");
          expandedOutline = expandedOutline.replace(/<\/?p>/g, "<br>");
          expandedOutline = expandedOutline.replace(/\n\s*\n/g, "\n");
          expandedOutline = expandedOutline.trim();
          expandedOutline = expandedOutline.replace(/\s\s+/g, "");
          return removeFirstLastBrTags(expandedOutline);
        }
        function formatStringWithOutlines(outlines2, str) {
          for (let i2 = 0; i2 < outlines2.length; i2++) {
            let item = outlines2[i2];
            if (i2 === 0) {
              str = str.replace(item, `<h2>${item}</h2><p>`);
            } else {
              str = str.replace(item, `</p><h2>${item}</h2><p>`);
            }
          }
          return str + "</p>";
        }
        useEffect16(() => {
          if (getInputs["generatedOutlines"]) {
            setSidebar({
              generatedOutlines: {
                ...sidebar4.generatedOutlines,
                open: true
              }
            });
            setInput("seoEnabled", true);
          }
        }, []);
        const handlePrev = () => {
          setInput("writingScreen", "introScreen");
          setSidebar({
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: false
            }
          });
        };
        useEffect16(() => {
          Utilities8.GenieHelpers.storeData("selectedIntro");
        }, [getInputs["selectedIntro"]]);
        let visibleTimeout;
        useEffect16(() => {
          if (selectedOutlines.length > 1 && visibleAlert) {
            visibleTimeout = setTimeout(() => {
              setVisibleAlert(false);
            }, 1e4);
          }
          Utilities8.GenieHelpers.storeData("selectedOutlines");
        }, [getInputs["selectedOutlines"]]);
        const generateOneClickBlog = () => {
          if (getInputs["selectedOutlines"].length <= 1) {
            setModalText(" Add at least two headings to generate the blog");
            return;
          }
          setConfirmLoading(true);
          const modifiedIntro = `<p>${getInputs["selectedIntro"]}</p>`;
          const modifiedOutlines = getInputs["selectedOutlines"].map((outline) => `<h2>${outline}</h2>`).join("");
          let connectionAttempts = 0;
          const socket = lookup2(window.getGenie.config?.parserApi, {
            query: {
              "Site-Token": window.getGenie.config?.siteToken,
              "Auth-Token": window.getGenie.config?.authToken,
              "Plugin-Version": window.getGenie.config?.version,
              "Plugin-Name": "getgenie"
            },
            transports: ["websocket"],
            reconnection: false
          });
          socket.on("connect", () => {
            socket.emit("ONE_CLICK_BLOG_PAYLOAD", {
              keyword: getInputs["keyword"],
              title: getInputs["selectedTitle"],
              context: getInputs["inputContext"],
              intro: modifiedIntro,
              outline: modifiedOutlines,
              selectedLanguage: sidebar4.currentLanguage
            });
            socket.on("ONE_CLICK_BLOG_RESPONSE", (res) => {
              HandleResponse5(res, () => {
                let htmlStr = res?.data?.[0];
                if (typeof htmlStr !== "string")
                  return;
                htmlStr = htmlStr.replace(/(<h(?!(>|\s))[^<]+?>)|(\s(?!(direction|text-align|)\b)[\w])/gm, "<h2>");
                let outline = htmlStr?.match(/<h2>([^\<]*?)<\/h2>/g) || [];
                const generatedParagraph = {};
                if (!outline?.length) {
                  htmlStr = formatStringWithOutlines(getInputs["selectedOutlines"], htmlStr);
                  outline = htmlStr.match(/<h2>([^\<]*?)<\/h2>/g);
                }
                for (let i2 = 0; i2 < outline.length; i2++) {
                  let expandedOutline = htmlStr.split(outline[i2])[1].split(outline[i2 + 1])[0].replace(/ *\[[^\]]*]/, "");
                  expandedOutline = removePTags(expandedOutline);
                  generatedParagraph[outline[i2].replace(/<\/?h2>/gi, "")] = {
                    paragraph: expandedOutline
                  };
                }
                const selectedOutlines2 = outline?.map((singleOutline) => singleOutline.replace(/<\/?h2>/gi, ""));
                setInput("generatedParagraphs", generatedParagraph);
                Utilities8.GenieHelpers.callStoreApi("generatedParagraphs", generatedParagraph);
                const selectedIntro = (getInputs["selectedIntro"] || "").replace(/<br\s*[\/]?>/g, "");
                const selectedTitle = getInputs["selectedTitle"] || "";
                if (sidebar4.currentPostContent?.trim().length > 0) {
                  Libs14.ConfirmModal(
                    "This page has some content",
                    "Do you want to replace that?",
                    () => {
                      insertHandler.insertContent(selectedTitle, selectedIntro, selectedOutlines2, generatedParagraph);
                    },
                    () => {
                      insertHandler.appendOutlines(selectedOutlines2, generatedParagraph);
                    }
                  );
                } else {
                  insertHandler.insertContent(selectedTitle, selectedIntro, selectedOutlines2, generatedParagraph);
                }
              });
            });
          });
          socket.on("disconnect", async (reason) => {
            setConfirmLoading(false);
            setOpen(false);
          });
          socket.on("connect_error", (err) => {
            connectionAttempts++;
            if (connectionAttempts > 2) {
              setConfirmLoading(false);
              setOpen(false);
            } else {
              setStep(0);
              setConfirmLoading(true);
              socket.connect();
            }
          });
        };
        const confirm = () => {
          if (!isOneClickBlogSupported) {
            setInput("writingScreen", "paragraphScreen");
            openAdvancedMode();
          } else {
            setOpen(true);
          }
        };
        const handleManually = (e) => {
          if (e.target.className.includes("getgenie-icon-close1")) {
            setOpen(false);
            return;
          }
          setModalText(initialModalText);
          setOpen(false);
          openAdvancedMode();
        };
        const openAdvancedMode = () => {
          setInput("writingScreen", "paragraphScreen");
          setSidebar({
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: false
            }
          });
        };
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-sidebar-outline getgenie-wrapper-screen"
        }, /* @__PURE__ */ React.createElement(Form3, {
          layout: "vertical",
          onFinish
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-screen-content intro"
        }, /* @__PURE__ */ React.createElement(Libs14.Collapse, {
          defaultActiveKey: ["Title-Intro"],
          className: "getgenie-collapse"
        }, /* @__PURE__ */ React.createElement(Libs14.Collapse.Panel, {
          header: /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-collapse-header"
          }, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-collapse-header-title"
          }, "Title & Intro"), /* @__PURE__ */ React.createElement(Libs14.Tooltip, {
            title: sidebar4.__("Edit or change the blog title & intro", "getgenie"),
            placement: "top"
          })),
          key: "Title-Intro"
        }, /* @__PURE__ */ React.createElement(Libs14.Textarea, {
          rows: 2,
          name: "selectedTitle",
          type: "text",
          placeholder: sidebar4.__("Enter blog post title here.", "getgenie")
        }), /* @__PURE__ */ React.createElement(Libs14.Textarea, {
          rows: 6,
          name: "selectedIntro",
          placeholder: sidebar4.__("Enter blog intro here.", "getgenie")
        }))), /* @__PURE__ */ React.createElement(Divider5, null), /* @__PURE__ */ React.createElement(SidebarControllerOption_default, {
          className: "getgenie-sidebar-controller-options"
        }), /* @__PURE__ */ React.createElement(Libs14.Button, {
          htmlType: "submit",
          type: "primary",
          className: "submit-btn",
          loading
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-edit"
        }), sidebar4.__("Generate Outline", "getgenie"))), /* @__PURE__ */ React.createElement(Libs14.TitleMsg, {
          list: selectedOutlines,
          loading,
          title: "outline"
        }), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-card-container getgenie-outline-cards"
        }, selectedOutlines.length === 0 && sidebar4.generatedOutlines.open && /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-outline-loading-text"
        }, sidebar4.__("Selected Outlines will Appear here", "getgenie")), /* @__PURE__ */ React.createElement(DndProvider, {
          backend: HTML5Backend,
          debugMode: true
        }, /* @__PURE__ */ React.createElement(SelectedOutlines, null)), selectedOutlines.length > 1 && visibleAlert && /* @__PURE__ */ React.createElement(Alert, {
          className: "getgenie-outline-cards-alert",
          message: sidebar4.__("You can also Edit, Delete & Rearrange these Selected Outlines", "getgenie"),
          closeText: sidebar4.__("Okay", "getgenie"),
          closable: true
        }))), /* @__PURE__ */ React.createElement(Modal2, {
          className: "getgenie-one-click-modal",
          title: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-alert"
          }), /* @__PURE__ */ React.createElement("span", {
            className: "title"
          }, " ", confirmLoading ? "Content in progress\u2026" : "Generate the entire blog with a single click")),
          visible: open,
          closeIcon: /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-close1"
          }),
          closable: !confirmLoading,
          maskClosable: false,
          zIndex: 9999,
          onOk: generateOneClickBlog,
          confirmLoading,
          onCancel: handleManually,
          okText: "One-click blog",
          cancelText: "Customized content",
          cancelButtonProps: { disabled: confirmLoading },
          getContainer: () => sidebar4.rootContainer
        }, !confirmLoading ? modalText : /* @__PURE__ */ React.createElement(Steps, {
          progressDot: (iconDot, { status }) => status === "process" ? /* @__PURE__ */ React.createElement("span", {
            className: "ant-steps-icon-dot border-spinner"
          }) : iconDot,
          current: step,
          direction: "vertical"
        }, loadingText.map((text, index2) => /* @__PURE__ */ React.createElement(Step, {
          key: index2,
          title: text
        })))), /* @__PURE__ */ React.createElement(Libs14.DrawerFooter, {
          handlePrev,
          handleNext: confirm,
          nextScreen: true,
          enableNextBtn: selectedOutlines.length > 0
        })));
      }, ["setSidebar", "sidebar", "getInputs", "setInput"]);
      OutlineScreen.GeneratedOutlines = GeneratedOutlines;
      OutlineScreen_default = OutlineScreen;
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/index.js
  var Libs15, Tooltip7, Button7, ComposeComponents17, useEffect17, ParagraphScreen, ParagraphScreen_default;
  var init_ParagraphScreen = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/index.js"() {
      init_InsertHandler();
      ({ Libs: Libs15 } = window.getGenie.Components.Common);
      ({ Tooltip: Tooltip7, Button: Button7 } = window.antd);
      ({ ComposeComponents: ComposeComponents17 } = window.getGenie.Components.Common.ReduxManager);
      ({ useEffect: useEffect17 } = window.React);
      ParagraphScreen = ComposeComponents17(({ sidebar: sidebar4, setSidebar, getInputs, setInput }) => {
        let insertHandler = new InsertHandler(window.getGenie.config.isBlockEditor);
        const paragraphs = getInputs["generatedParagraphs"] || {};
        const selectedOutlines = getInputs["selectedOutlines"] ? [...new Set(getInputs["selectedOutlines"])] : [];
        useEffect17(() => {
          setSidebar({
            paragraphEditorScreen: {
              ...sidebar4.paragraphEditorScreen,
              currentOutline: selectedOutlines[0],
              currentOutlineIndex: 0
            }
          });
        }, []);
        const handlePrev = () => {
          setInput("writingScreen", "outlineScreen");
          setSidebar({
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: true
            }
          });
        };
        const handleInsertData = () => {
          const selectedIntro = (getInputs["selectedIntro"] || "").replace(/<br\s*[\/]?>/g, "");
          const selectedTitle = getInputs["selectedTitle"] || "";
          if (sidebar4.currentPostContent?.trim().length > 0) {
            Libs15.ConfirmModal(
              "This page has some content",
              "Do you want to replace that?",
              () => {
                insertHandler.insertContent(selectedTitle, selectedIntro, selectedOutlines, paragraphs);
              },
              () => {
                insertHandler.appendOutlines(selectedOutlines, paragraphs);
              }
            );
          } else {
            insertHandler.insertContent(selectedTitle, selectedIntro, selectedOutlines, paragraphs);
          }
        };
        const insertBtn = /* @__PURE__ */ React.createElement(Tooltip7, {
          title: sidebar4.__("Insert all paragraphs", "getgenie"),
          placement: "topLeft"
        }, /* @__PURE__ */ React.createElement(Button7, {
          type: "primary",
          onClick: handleInsertData,
          size: "small",
          disabled: false,
          className: "insertBtn"
        }, sidebar4.__("Insert", "getgenie")));
        const handleSelectedOutline = (outline, index2) => {
          setSidebar({
            paragraphEditorScreen: {
              ...sidebar4.paragraphEditorScreen,
              currentOutline: outline,
              currentOutlineIndex: index2
            }
          });
        };
        let currentOutlineIndex = sidebar4.paragraphEditorScreen?.currentOutlineIndex || 0;
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-wrapper-screen"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-paragraph-screen-container"
        }, selectedOutlines.map((item, index2) => /* @__PURE__ */ React.createElement(Button7, {
          onClick: () => handleSelectedOutline(item, index2),
          key: index2,
          className: `paragraph-outline-header ${currentOutlineIndex === index2 ? "active-outline" : ""} ${paragraphs[selectedOutlines[index2]]?.paragraph ? "generated-outline" : ""}`
        }, item))), /* @__PURE__ */ React.createElement(Libs15.DrawerFooter, {
          nextScreen: false,
          insertData: handleInsertData,
          insertBtn,
          handlePrev
        }));
      }, ["setSidebar", "setInput", "getInputs", "sidebar"]);
      ParagraphScreen_default = ParagraphScreen;
    }
  });

  // assets/src/admin/js/AdminPages/KeywordResearchAdminPage/config/db.js
  var DB_NAME, STORE_NAME, DB_VERSION, openDB, getData;
  var init_db = __esm({
    "assets/src/admin/js/AdminPages/KeywordResearchAdminPage/config/db.js"() {
      DB_NAME = "keyword_research";
      STORE_NAME = "keywords_data_store";
      DB_VERSION = 2;
      openDB = () => {
        return new Promise((resolve2, reject) => {
          const request = window.indexedDB.open(DB_NAME, DB_VERSION);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME, { keyPath: "key" });
            }
          };
          request.onsuccess = (event) => {
            resolve2(event.target.result);
          };
          request.onerror = (event) => {
            reject(event.target.error);
          };
        });
      };
      getData = async (key) => {
        try {
          const db = await openDB();
          return new Promise((resolve2, reject) => {
            const transaction = db.transaction(STORE_NAME, "readonly");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(key);
            request.onsuccess = (event) => {
              resolve2(event.target.result);
            };
            request.onerror = (event) => {
              reject(event.target.error);
            };
          });
        } catch (error) {
          console.error("Error getting data:", error);
        }
      };
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/Wrapper/index.js
  var Libs16, Utilities9, ComposeComponents18, useState12, useEffect18, BlogScreen;
  var init_Wrapper = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/Wrapper/index.js"() {
      init_TitleScreen();
      init_IntroScreen();
      init_OutlineScreen();
      init_ParagraphScreen();
      init_SearchVolumeChart();
      init_db();
      ({ Libs: Libs16, Utilities: Utilities9 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents18 } = window.getGenie.Components.Common.ReduxManager);
      ({ useState: useState12, useEffect: useEffect18 } = window.React);
      BlogScreen = ComposeComponents18(({ setSidebar, sidebar: sidebar4, setInput, getInputs }) => {
        const titleList = getInputs["generatedTitles"] || [];
        const introList = getInputs["generatedIntros"] || [];
        const currentScreen = getInputs["writingScreen"] || "titleScreen";
        const keyword = new URLSearchParams(window.location.search).get("keyword");
        useEffect18(() => {
          if (currentScreen !== "outlineScreen") {
            setSidebar({
              generatedOutlines: {
                ...sidebar4.generatedOutlines,
                open: false
              }
            });
          } else {
            if (getInputs["generatedOutlines"]) {
              setSidebar({
                generatedOutlines: {
                  ...sidebar4.generatedOutlines,
                  open: true
                }
              });
              setInput("seoEnabled", true);
            }
          }
          setSidebar({
            currentScreen
          });
        }, [currentScreen]);
        useEffect18(() => {
          if (!keyword)
            return;
          const fetchData = async () => {
            const searchVolume = await getData("searchVolume") || {};
            const wizardRelatedKeywords = await getData("wizardRelatedKeywords") || [];
            setInput("keyword", keyword);
            setInput("relatedKeywords", wizardRelatedKeywords?.data);
            setInput("searchVolume", searchVolume?.data);
            setInput("overviewChartTab", "searchVolTrend");
          };
          fetchData();
        }, []);
        let isIntroScreenDisable = !titleList.find((item) => item.title === getInputs["selectedTitle"]);
        let isOutlineScreenDisable = !introList.find((item) => item.title === getInputs["selectedIntro"]);
        let isParagraphScreenDisable = (getInputs["selectedOutlines"] || []).length === 0;
        const tabPaneList = [
          {
            label: sidebar4.__("Title", "getgenie"),
            key: "titleScreen",
            children: /* @__PURE__ */ React.createElement(TitleScreen_default, null)
          },
          {
            label: sidebar4.__("Intro", "getgenie"),
            key: "introScreen",
            children: /* @__PURE__ */ React.createElement(IntroScreen_default, null),
            disabled: isIntroScreenDisable
          },
          {
            label: sidebar4.__("Outline", "getgenie"),
            key: "outlineScreen",
            children: /* @__PURE__ */ React.createElement(OutlineScreen_default, null),
            disabled: isIntroScreenDisable || isOutlineScreenDisable
          },
          {
            label: sidebar4.__("Content", "getgenie"),
            key: "paragraphScreen",
            children: /* @__PURE__ */ React.createElement(ParagraphScreen_default, null),
            disabled: isIntroScreenDisable || isOutlineScreenDisable || isParagraphScreenDisable
          }
        ];
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Libs16.DrawerHeader, {
          screenName: currentScreen
        }), /* @__PURE__ */ React.createElement(Libs16.Navbar, {
          tabPaneList,
          activeKey: currentScreen,
          destroyInactiveTabPane: false,
          handleActiveKey: (screen) => setInput("writingScreen", screen),
          className: "getgenie-blog-screen-navbar"
        }));
      }, ["setSidebar", "sidebar", "setInput", "getInputs"]);
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/InstructionTab.js
  var Libs17, ComposeComponents19, Select, Input, Form4, InstructionTab, InstructionTab_default;
  var init_InstructionTab = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/InstructionTab.js"() {
      ({ Libs: Libs17 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents19 } = window.getGenie.Components.Common.ReduxManager);
      ({ Select, Input, Form: Form4 } = window.antd);
      InstructionTab = ComposeComponents19(({ getInputs, sidebar: sidebar4, setInput }) => {
        let relatedKeywords2 = (getInputs["relatedKeywords"] || []).map((item) => item.keyword);
        let peopleAlsoSearched = (getInputs["peopleAlsoSearched"] || []).map((item) => item.title);
        const selectedOutlines = getInputs["selectedOutlines"] ? [...new Set(getInputs["selectedOutlines"])] : [];
        const paragraphs = getInputs["generatedParagraphs"] || {};
        const currentOutline = sidebar4.paragraphEditorScreen?.currentOutline || selectedOutlines[0];
        let allKeywords = [...relatedKeywords2, ...peopleAlsoSearched];
        allKeywords = [...new Set(allKeywords)];
        let options = allKeywords.map((item) => ({ label: item, value: item }));
        const updateParagraph = (data) => {
          let obj = getInputs["generatedParagraphs"] || {};
          obj[currentOutline] = {
            ...obj[currentOutline],
            ...data
          };
          setInput("generatedParagraphs", obj);
        };
        const handleInstructionChange = (e) => {
          updateParagraph({ paragraphInstruction: e.target.value });
        };
        const handleKeywordChange = (value2) => {
          updateParagraph({ headingKeywords: value2 });
        };
        return /* @__PURE__ */ React.createElement(Form4, {
          layout: "vertical",
          className: "getgenie-instruction-container"
        }, /* @__PURE__ */ React.createElement(Form4.Item, {
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Context (Optional)", "getgenie"), /* @__PURE__ */ React.createElement(Libs17.Tooltip, {
            title: sidebar4.__("Let the genie know the context of this outline", "getgenie"),
            zIndex: 999999,
            placement: "left"
          })),
          className: "genie-input paragraph-instruction-textarea"
        }, /* @__PURE__ */ React.createElement(Input.TextArea, {
          value: paragraphs?.[currentOutline]?.paragraphInstruction,
          placeholder: "Type instruction here.",
          onChange: handleInstructionChange
        })), /* @__PURE__ */ React.createElement(Form4.Item, {
          label: /* @__PURE__ */ React.createElement(React.Fragment, null, sidebar4.__("Keywords (Optional)", "getgenie"), /* @__PURE__ */ React.createElement(Libs17.Tooltip, {
            title: sidebar4.__("Select/Add keywords for better result.", "getgenie"),
            zIndex: 999999,
            placement: "left"
          }))
        }, /* @__PURE__ */ React.createElement(Select, {
          showSearch: true,
          suffixIcon: null,
          onChange: handleKeywordChange,
          value: paragraphs?.[currentOutline]?.headingKeywords || [],
          mode: "tags",
          style: { width: "100%" },
          placeholder: "Keywords...",
          options,
          getPopupContainer: () => sidebar4.rootContainer,
          placement: "bottomLeft"
        })));
      }, ["getInputs", "setInput", "sidebar"]);
      InstructionTab_default = InstructionTab;
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/ParagraphGenerator.js
  var Libs18, Utilities10, StaticData3, Popover, Tooltip8, Form5, Input2, Alert2, GenieHelpers7, ComposeComponents20, HandleFetch5, HandleResponse6, useState13, emptyContnet, scrollDown, GeneratedOutlines2;
  var init_ParagraphGenerator = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/ParagraphScreen/ParagraphGenerator.js"() {
      init_InstructionTab();
      ({ Libs: Libs18, Utilities: Utilities10, StaticData: StaticData3 } = window.getGenie.Components.Common);
      ({ Popover, Tooltip: Tooltip8, Form: Form5, Input: Input2, Alert: Alert2 } = window.antd);
      ({ GenieHelpers: GenieHelpers7 } = Utilities10);
      ({ ComposeComponents: ComposeComponents20 } = window.getGenie.Components.Common.ReduxManager);
      ({ HandleFetch: HandleFetch5, HandleResponse: HandleResponse6 } = window.getGenie.Components.Common.RequestManager);
      ({ useState: useState13 } = window.React);
      emptyContnet = `${window.getGenie.config.assetsUrl}dist/admin/images/empty-content.svg`;
      scrollDown = `${window.getGenie.config.assetsUrl}dist/admin/images/scroll-down.svg`;
      GeneratedOutlines2 = ComposeComponents20(({ setInput, getInputs, sidebar: sidebar4, setSidebar, getTemplateInputs, visible, width }) => {
        const selectedOutlines = getInputs["selectedOutlines"] ? [...new Set(getInputs["selectedOutlines"])] : [];
        const allParagraphs = getInputs["generatedParagraphs"] || {};
        let currentParagraphOutline = sidebar4.paragraphEditorScreen?.currentOutline || selectedOutlines[0];
        const currentOutlineIndex = sidebar4.paragraphEditorScreen?.currentOutlineIndex || 0;
        const [open, setOpen] = useState13(false);
        const [showTooltip, setShowTooltip] = useState13("");
        let outlineHeader = currentParagraphOutline;
        if (currentParagraphOutline?.length > 30) {
          outlineHeader = currentParagraphOutline.substring(0, 30).concat("...");
        }
        const controlParagraph = (outline, paragraphs, key, value2) => {
          let updatedValue = value2;
          if (key == "paragraph") {
            updatedValue = value2 || " ";
          }
          paragraphs[outline] = {
            ...paragraphs[outline],
            [key]: updatedValue
          };
          setInput("generatedParagraphs", paragraphs);
          if (key == "alert" && value2 == false) {
            GenieHelpers7.callStoreApi("generatedParagraphs", paragraphs);
          }
        };
        const expandOutline2 = (outline, paragraphs) => {
          let urlKey = "expandOutline";
          controlParagraph(outline, paragraphs, "loading", true);
          let input = {
            title: wp.data.select("core/editor")?.getCurrentPost()?.title || getTemplateInputs?.blogWizard?.selectedTitle || "",
            keyword: getTemplateInputs?.blogWizard?.keyword || "",
            context: paragraphs[outline]?.paragraphInstruction || "",
            instructionKeywords: paragraphs[outline]?.headingKeywords || "",
            textContent: outline
          };
          let data = {
            numberOfResult: 1,
            templateSlug: sidebar4.currentTemplate,
            outputSize: getInputs["outputSize"],
            input
          };
          HandleFetch5((res) => {
            controlParagraph(outline, paragraphs, "loading", false);
            HandleResponse6(res, () => {
              paragraphs[outline] = {
                paragraph: res.data?.[0],
                paragraphInstruction: paragraphs[outline]?.paragraphInstruction || "",
                headingKeywords: paragraphs[outline]?.headingKeywords || ""
              };
              setInput("generatedParagraphs", paragraphs);
              GenieHelpers7.callStoreApi("generatedParagraphs", paragraphs);
              controlParagraph(outline, paragraphs, "alert", true);
            });
          }, urlKey, data);
        };
        const handleNextOutlineTab = () => {
          const nextOutlineIndex = (sidebar4.paragraphEditorScreen?.currentOutlineIndex || 0) + 1;
          const nextOutline = selectedOutlines.find((_, index2) => index2 === nextOutlineIndex);
          setSidebar({
            paragraphEditorScreen: {
              ...sidebar4.paragraphEditorScreen,
              currentOutline: nextOutline,
              currentOutlineIndex: nextOutlineIndex
            }
          });
        };
        const copyContent = (e, paragraph) => {
          e.stopPropagation();
          GenieHelpers7.copyToClipboard(paragraph).then(() => {
            setShowTooltip(paragraph);
          }).catch(() => console.log("error"));
        };
        const currentParagraphValue = (allParagraphs?.[currentParagraphOutline]?.paragraph || "").replace(/(<([^>]+)>)/g, "\n");
        const isCurrentParagraph = allParagraphs?.[currentParagraphOutline]?.paragraph;
        const isCurrentParagraphLoading = allParagraphs?.[currentParagraphOutline]?.loading;
        const isCurrentParagrapAlert = allParagraphs?.[currentParagraphOutline]?.alert;
        return /* @__PURE__ */ React.createElement("div", {
          className: `getgenie-paragraph-editor ${visible ? "" : "d-none"}`,
          style: { width: `${width}px` }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-empty-tag"
        }), /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-generated-outlines-title"
        }, sidebar4.__(`${outlineHeader}`, "getgenie")), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-paragraph-result-container"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "paragraph-instruction-keyword-header"
        }, /* @__PURE__ */ React.createElement("p", {
          className: "paragraph-instruction-keyword-header-title"
        }, "Instructions or Keywords", /* @__PURE__ */ React.createElement("span", {
          className: "option-text"
        }, " (Optional)"), /* @__PURE__ */ React.createElement("span", {
          className: "option-title"
        }, " Add instruction or keywords to consider")), /* @__PURE__ */ React.createElement(Popover, {
          content: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-close1 popover-close",
            onClick: () => setOpen(false)
          }), /* @__PURE__ */ React.createElement(InstructionTab_default, null)),
          overlayClassName: "instruction-keyword-popover",
          overlayStyle: {
            width: "352px",
            position: "fixed",
            top: "20%",
            left: "40%"
          },
          placement: "left",
          trigger: "click",
          zIndex: 9999,
          visible: open,
          align: { offset: [-330, 50] },
          destroyTooltipOnHide: true,
          onVisibleChange: (open2) => setOpen(open2)
        }, /* @__PURE__ */ React.createElement("div", {
          style: { width: "2rem", height: "1rem", visibility: open ? "hidden" : "visible" }
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-edit1 edit-icon"
        })))), /* @__PURE__ */ React.createElement(Form5, {
          layout: "vertical",
          className: "paragraph-generate-form"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "instruction-keyword-selected-label"
        }, /* @__PURE__ */ React.createElement("label", {
          htmlFor: "instruction-label"
        }, "Length:", /* @__PURE__ */ React.createElement(Libs18.Tooltip, {
          title: "Set output length of your paragraph",
          placement: "top"
        })), /* @__PURE__ */ React.createElement(Libs18.Select, {
          name: "outputSize",
          handleOnChange: (val) => GenieHelpers7.saveSidebarControllerOption("getgenie-outputSize", val),
          className: "outputSize",
          options: StaticData3.outputSizes,
          defaultValue: sidebar4.outputSize,
          disableList: ["more"]
        })), isCurrentParagraphLoading && /* @__PURE__ */ React.createElement(Libs18.SkeletonCard, {
          count: 1
        }), !isCurrentParagraph && !isCurrentParagraphLoading && /* @__PURE__ */ React.createElement("div", {
          className: "paragraph-generate-icon"
        }, /* @__PURE__ */ React.createElement("img", {
          src: emptyContnet,
          alt: "empty-content"
        }), /* @__PURE__ */ React.createElement("p", {
          className: "generate-outline-content-text"
        }, "Click the ", /* @__PURE__ */ React.createElement("span", null, "Generate"), " button below to get content for this heading"), /* @__PURE__ */ React.createElement("img", {
          src: scrollDown,
          alt: "scroll-down"
        })), isCurrentParagraph && /* @__PURE__ */ React.createElement("div", {
          style: { display: isCurrentParagraphLoading ? "none" : "block" }
        }, /* @__PURE__ */ React.createElement(Form5.Item, {
          className: "genie-input paragraph-generate-textarea"
        }, /* @__PURE__ */ React.createElement(Input2.TextArea, {
          value: currentParagraphValue,
          placeholder: "Your Text",
          onChange: (e) => controlParagraph(currentParagraphOutline, allParagraphs, "paragraph", e.target.value),
          autoSize: true
        }), /* @__PURE__ */ React.createElement("div", {
          className: "copy-generate-paragraph"
        }, /* @__PURE__ */ React.createElement(Tooltip8, {
          placement: "bottom",
          zIndex: 9999,
          title: showTooltip === currentParagraphValue ? "Copied" : "Copy this content"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "copy-icon getgenie-icon-copy",
          onClick: (e) => copyContent(e, currentParagraphValue)
        })))), isCurrentParagrapAlert && /* @__PURE__ */ React.createElement(Alert2, {
          className: "outline-paragraph-output-alert",
          message: sidebar4.__("Looking for something different?", "getgenie"),
          description: sidebar4.__("You can regenerate the content by clicking the button below.", "getgenie"),
          type: "info",
          showIcon: true,
          closable: true,
          onClose: () => controlParagraph(currentParagraphOutline, allParagraphs, "alert", false)
        })))), /* @__PURE__ */ React.createElement("div", {
          className: `paragraph-generate-btnGrp ${isCurrentParagraph ? "generated-btnGrp" : ""}`
        }, isCurrentParagraph && currentOutlineIndex != selectedOutlines.length - 1 ? /* @__PURE__ */ React.createElement(Libs18.Button, {
          htmlType: "submit",
          className: "getgenie-continue-btn",
          type: "primary",
          onClick: handleNextOutlineTab
        }, "Continue") : "", /* @__PURE__ */ React.createElement(Libs18.Button, {
          htmlType: "submit",
          className: "getgenie-generate-btn",
          onClick: () => expandOutline2(currentParagraphOutline, allParagraphs),
          loading: isCurrentParagraphLoading,
          type: "primary"
        }, isCurrentParagraph ? "Regenerate" : "Generate")));
      }, ["setInput", "getInputs", "sidebar", "setSidebar", "getTemplateInputs"]);
    }
  });

  // assets/src/admin/js/BlogWizard/WritingScreens/index.js
  var init_WritingScreens = __esm({
    "assets/src/admin/js/BlogWizard/WritingScreens/index.js"() {
      init_Wrapper();
      init_OutlineScreen();
      init_ParagraphGenerator();
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/ScoreDetails.js
  var Libs19, Row4, Col4, ComposeComponents21, ScoreDetails, ScoreDetails_default;
  var init_ScoreDetails = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/ScoreDetails.js"() {
      init_BlogWizard();
      init_Utilities();
      ({ Libs: Libs19 } = window.getGenie.Components.Common);
      ({ Row: Row4, Col: Col4 } = window.antd);
      ({ ComposeComponents: ComposeComponents21 } = window.getGenie.Components.Common.ReduxManager);
      ScoreDetails = ComposeComponents21(({ sidebar: sidebar4 }) => {
        if (!sidebar4.analyzedContent?.statistics) {
          return "";
        }
        const { nlp, heading, image, imgAltText, word, internalLink } = sidebar4.analyzedContent?.statistics;
        const scoreDetailsStats = { word, heading, nlp, image, imgAltText, internalLink };
        const getNlpColor = (score) => {
          if (score >= 70) {
            return "#14A645";
          }
          if (score >= 40) {
            return "#F5B008";
          }
          return "#F02F54";
        };
        const getStatColor = (score, recommendation) => {
          let color2 = "#F5B008";
          if (score >= recommendation[0]) {
            color2 = "#14A645";
          }
          return color2;
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-details"
        }, /* @__PURE__ */ React.createElement(Row4, {
          gutter: [0, 38]
        }, Object.keys(scoreDetailsStats).map((stat, index2) => /* @__PURE__ */ React.createElement(Col4, {
          key: index2,
          span: 8
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-content"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "sc-container"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "item"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "output"
        }, /* @__PURE__ */ React.createElement("h6", {
          className: "title"
        }, scoreDetailsStats[stat]?.title), /* @__PURE__ */ React.createElement("h5", {
          className: "value",
          style: {
            color: stat === "nlp" ? getNlpColor(scoreDetailsStats[stat].count) : getStatColor(scoreDetailsStats[stat].count, scoreDetailsStats[stat].analyzedRecommendation)
          }
        }, scoreDetailsStats[stat].count, stat === "nlp" ? "%" : /* @__PURE__ */ React.createElement("span", {
          className: "icon"
        }, scoreDetailsStats[stat].analyzedRecommendation && scoreDetailsStats[stat].count >= scoreDetailsStats[stat].analyzedRecommendation[0] ? /* @__PURE__ */ React.createElement("i", {
          className: "getgenie-icon-check"
        }) : /* @__PURE__ */ React.createElement("i", {
          className: "getgenie-icon-arrow-right"
        }))))), scoreDetailsStats[stat].analyzedRecommendation && /* @__PURE__ */ React.createElement("div", {
          className: `label ${(stat || "").toLowerCase()}`
        }, /* @__PURE__ */ React.createElement("div", {
          className: "output"
        }, /* @__PURE__ */ React.createElement("h6", {
          className: "title"
        }, sidebar4.__("Recommended", "getgenie")), /* @__PURE__ */ React.createElement("span", {
          className: "value"
        }, stat === "nlp" ? scoreDetailsStats[stat]?.scoreRecommendation + "%" : GenieHelpers.joinArray(scoreDetailsStats[stat].analyzedRecommendation))))))))));
      }, ["sidebar"]);
      ScoreDetails_default = ScoreDetails;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/Feedback.js
  var Alert3, ComposeComponents22, Feedback, Feedback_default;
  var init_Feedback = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/Feedback.js"() {
      ({ Alert: Alert3 } = window.antd);
      ({ ComposeComponents: ComposeComponents22 } = window.getGenie.Components.Common.ReduxManager);
      Feedback = ComposeComponents22(({ sidebar: sidebar4 }) => {
        const { feedbacks } = sidebar4.analyzedContent;
        const alertType = (key) => {
          return key === "problems" ? "error" : key === "results" ? "success" : "warning";
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-analysis"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-analysis-heading"
        }, /* @__PURE__ */ React.createElement("h5", {
          className: "title"
        }, sidebar4.__("Score Analysis", "getgenie"))), Object.keys(feedbacks).map(
          (key, index2) => feedbacks[key].length !== 0 ? /* @__PURE__ */ React.createElement("div", {
            key: index2,
            className: `getgenie-statistics-score-analysis-info ${key}`
          }, /* @__PURE__ */ React.createElement("h5", {
            className: "title"
          }, key), /* @__PURE__ */ React.createElement("div", {
            className: "analyzed-list"
          }, feedbacks[key].map((item, childIndex) => /* @__PURE__ */ React.createElement(Alert3, {
            key: childIndex,
            description: item,
            type: alertType(key),
            showIcon: true
          })))) : ""
        ));
      }, ["sidebar"]);
      Feedback_default = Feedback;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/ScoreMeter.js
  var Typography8, Button8, Row5, Col5, useEffect19, useState14, Libs20, memo5, sidebar2, ScoreMeter, ScoreMeter_default;
  var init_ScoreMeter = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/ScoreMeter.js"() {
      init_chart();
      init_dist();
      ({ Typography: Typography8, Button: Button8, Row: Row5, Col: Col5 } = window.antd);
      ({ useEffect: useEffect19, useState: useState14 } = window.React);
      ({ Libs: Libs20 } = window.getGenie.Components.Common);
      ({ memo: memo5 } = window.React);
      sidebar2 = wp.data.select("getgenie").sidebar();
      Chart.register(ArcElement, plugin_legend);
      ScoreMeter = memo5(({ totalContentStats, competitorStat, handleShowAnalysis, showAnalysis }) => {
        let score = totalContentStats?.totalScore || 0;
        let yellow = "#F5B008";
        let green = "#14A645";
        let red = "#F02F54";
        const [redZone, setRedZone] = useState14(0);
        const [brownZone, setBrownZone] = useState14(0);
        const [yellowZone, setYellowZone] = useState14(0);
        const [greenZone, setGreenZone] = useState14(0);
        const [indicator, setIndicator] = useState14(0);
        useEffect19(() => {
          setIndicator(score);
          if (score <= 25) {
            setRedZone(score);
          }
          if (score > 25 && score <= 45) {
            setBrownZone(score - 25);
            setRedZone(25);
          }
          if (score > 45 && score <= 65) {
            setYellowZone(score - 45);
            setBrownZone(20);
            setRedZone(25);
          }
          if (score > 65) {
            setGreenZone(score - 65);
            setYellowZone(20);
            setBrownZone(20);
            setRedZone(25);
          }
        }, [score]);
        const chartData = {
          labels: ["Red", "Orange", "Green"],
          datasets: [
            {
              label: "# of Votes",
              data: [redZone, 25 - redZone, brownZone, 20 - brownZone, yellowZone, 20 - yellowZone, greenZone, 35 - greenZone],
              backgroundColor: [
                "rgba(201, 62, 39, 1)",
                "#EAECEF",
                "rgba(235, 107, 67, 1)",
                "#EAECEF",
                "rgba(248, 191, 28, 1)",
                "#EAECEF",
                "rgba(46, 204, 113, 1)",
                "#EAECEF"
              ],
              borderWidth: 2
            }
          ]
        };
        const chartOption = {
          rotation: 270,
          circumference: 180,
          plugins: {
            datalabels: {
              display: false
            },
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          },
          cutout: "80%"
        };
        const indicatorData = {
          labels: ["", "Purple", ""],
          datasets: [{
            data: [indicator, 0.2, 99.8 - indicator],
            backgroundColor: [
              "rgba(0,0,0,0)",
              "#000",
              "rgba(0,0,0,0)"
            ],
            borderColor: [
              "rgba(0, 0, 0 ,0)",
              "#000",
              "rgba(0, 0, 0 ,0)"
            ],
            borderWidth: 2
          }]
        };
        const indicatorOptions = {
          rotation: 270,
          circumference: 180,
          plugins: {
            datalabels: {
              display: false
            },
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          },
          cutout: "80%"
        };
        function conditionalColor(condition) {
          if (condition > 69) {
            return green;
          }
          if (condition < 70 && condition > 49) {
            return yellow;
          }
          if (condition < 50) {
            return red;
          }
        }
        const competitorTooltipContent = /* @__PURE__ */ React.createElement("div", {
          className: "competitor-tooltip"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "competitor-tooltip-item"
        }, /* @__PURE__ */ React.createElement("i", null, /* @__PURE__ */ React.createElement("svg", {
          width: "14",
          height: "14",
          viewBox: "0 0 14 14",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ React.createElement("path", {
          d: "M7.09033 9.73494V11",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M4.07837 13.0482H10.1025V12.4458C10.1025 11.7831 9.5603 11.241 8.89765 11.241H5.28319C4.62054 11.241 4.07837 11.7831 4.07837 12.4458V13.0482V13.0482Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeMiterlimit: "10"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M3.47607 13.0482H10.705",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M6.99983 9.43373C4.6685 9.43373 2.78296 7.54819 2.78296 5.21687V3.40964C2.78296 2.07831 3.86127 1 5.1926 1H8.80705C10.1384 1 11.2167 2.07831 11.2167 3.40964V5.21687C11.2167 7.54819 9.33115 9.43373 6.99983 9.43373Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M3.06626 6.81325C2.61446 6.66867 2.21687 6.40361 1.90361 6.09036C1.36145 5.48795 1 4.76505 1 3.92168C1 3.07831 1.66265 2.41566 2.50602 2.41566H2.89759C2.77711 2.69277 2.71687 2.99999 2.71687 3.31927V5.1265C2.71687 5.72891 2.84337 6.29517 3.06626 6.81325Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M10.9336 6.81325C11.3854 6.66867 11.783 6.40361 12.0962 6.09036C12.6384 5.48795 12.9999 4.76505 12.9999 3.92168C12.9999 3.07831 12.3372 2.41566 11.4938 2.41566H11.1023C11.2227 2.69277 11.283 2.99999 11.283 3.31927V5.1265C11.283 5.72891 11.1565 6.29517 10.9336 6.81325Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }))), /* @__PURE__ */ React.createElement("p", null, "Competitor's Highest Score: ", /* @__PURE__ */ React.createElement("span", null, competitorStat?.maxScore))), /* @__PURE__ */ React.createElement("div", {
          className: "competitor-tooltip-item"
        }, /* @__PURE__ */ React.createElement("i", null, /* @__PURE__ */ React.createElement("svg", {
          width: "12",
          height: "18",
          viewBox: "0 0 12 18",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ React.createElement("path", {
          d: "M6 11C8.76142 11 11 8.76142 11 6C11 3.23858 8.76142 1 6 1C3.23858 1 1 3.23858 1 6C1 8.76142 3.23858 11 6 11Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M3.293 10.2072L2.42871 16.7143L6.00014 14.5714L9.57157 16.7143L8.70728 10.2",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }))), /* @__PURE__ */ React.createElement("p", null, "Average score from SERP: ", /* @__PURE__ */ React.createElement("span", null, competitorStat?.avgScore))), /* @__PURE__ */ React.createElement("div", {
          className: "competitor-tooltip-item"
        }, /* @__PURE__ */ React.createElement("i", null, /* @__PURE__ */ React.createElement("svg", {
          width: "14",
          height: "14",
          viewBox: "0 0 14 14",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ React.createElement("path", {
          d: "M9.82906 11.1514H4.2143C3.96343 11.1514 3.68269 10.9543 3.59907 10.7153L1.12619 3.79842C0.773769 2.80688 1.18592 2.50225 2.0341 3.11151L4.36363 4.77802C4.75189 5.04681 5.1939 4.90943 5.36115 4.47339L6.41242 1.67198C6.74692 0.776007 7.30242 0.776007 7.63692 1.67198L8.68819 4.47339C8.85544 4.90943 9.29745 5.04681 9.67974 4.77802L11.8659 3.21903C12.7977 2.55003 13.2457 2.8905 12.8634 3.97164L10.4503 10.7273C10.3607 10.9543 10.0799 11.1514 9.82906 11.1514Z",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M3.73657 12.9553H10.307",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }), /* @__PURE__ */ React.createElement("path", {
          d: "M5.52832 8.17674H8.51489",
          stroke: "white",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }))), /* @__PURE__ */ React.createElement("p", null, "SERP's #1 Competitor's Score: ", /* @__PURE__ */ React.createElement("span", null, competitorStat?.firstCompetitorScore))));
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-meter"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "chart-label"
        }, /* @__PURE__ */ React.createElement(Doughnut, {
          data: chartData,
          options: chartOption
        }), /* @__PURE__ */ React.createElement(Doughnut, {
          data: indicatorData,
          options: indicatorOptions
        }), /* @__PURE__ */ React.createElement("div", {
          className: "meter-text"
        }, /* @__PURE__ */ React.createElement(Typography8.Text, null, score, "/"), /* @__PURE__ */ React.createElement(Typography8.Text, null, sidebar2.__("100", "getgenie"))), /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-heading"
        }, /* @__PURE__ */ React.createElement(Button8, {
          onClick: handleShowAnalysis,
          type: "link"
        }, showAnalysis ? sidebar2.__("Hide Analysis", "getgenie") : sidebar2.__("Details Analysis", "getgenie")))), /* @__PURE__ */ React.createElement("div", {
          className: "side-info"
        }, /* @__PURE__ */ React.createElement(Col5, null, /* @__PURE__ */ React.createElement("div", {
          className: "side-info-content"
        }, /* @__PURE__ */ React.createElement("p", {
          className: "readability-score"
        }, "Competitor's Best: ", /* @__PURE__ */ React.createElement("span", {
          className: "result",
          style: { color: conditionalColor(competitorStat?.maxScore) }
        }, competitorStat?.maxScore)), /* @__PURE__ */ React.createElement(Libs20.Tooltip, {
          className: "getgenie-statistics-score-tooltip",
          placement: "top",
          title: competitorTooltipContent,
          color: "#031233"
        }))), /* @__PURE__ */ React.createElement(Col5, null, /* @__PURE__ */ React.createElement("div", {
          className: "side-info-content"
        }, /* @__PURE__ */ React.createElement("p", null, "Readability Score:", /* @__PURE__ */ React.createElement("span", {
          className: "result",
          style: {
            color: conditionalColor(totalContentStats.readabilityScore)
          }
        }, " " + totalContentStats.readabilityScore)), /* @__PURE__ */ React.createElement(Libs20.Tooltip, {
          className: "getgenie-statistics-score-tooltip",
          placement: "top",
          title: sidebar2.__(`${totalContentStats.readabilityTooltipText}`),
          color: "#031233"
        })))));
      });
      ScoreMeter_default = ScoreMeter;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/Category.js
  var ComposeComponents23, Libs21, Utilities11, GenieHelpers8, useState15, useEffect20, Tooltip9, Category, Category_default;
  var init_Category = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/Category.js"() {
      ({ ComposeComponents: ComposeComponents23 } = window.getGenie.Components.Common.ReduxManager);
      ({ Libs: Libs21, Utilities: Utilities11 } = window.getGenie.Components.Common);
      ({ GenieHelpers: GenieHelpers8 } = Utilities11);
      ({ useState: useState15, useEffect: useEffect20 } = window.React);
      ({ Tooltip: Tooltip9 } = window.antd);
      Category = ComposeComponents23(({ category, keyword = [], screenName, tooltipText = "", sidebar: sidebar4, setSidebar, getInputs, setInput }) => {
        const [isUpdateData, setIsUpdateData] = useState15(false);
        const selectedKeywordList = getInputs["selectedKeywordList"] || [];
        const nlpKeywordList = getInputs["nlpKeywordList"] || [];
        const restStatisticsKeyword = getInputs["restStatisticsKeyword"] || {};
        let statisticsData = sidebar4.statisticsData;
        let statisticsKeyword = statisticsData.keywords;
        const checkNlpKeywordCategory = category === "NLP Keywords";
        useEffect20(() => {
          GenieHelpers8.callStoreApi("serpData", {
            statisticsData,
            restStatisticsKeyword,
            selectedKeywordList,
            nlpKeywordList
          });
        }, [isUpdateData]);
        if (keyword.length === 0) {
          return "";
        }
        let keywordList = [];
        if (!screenName || screenName === "all") {
          keywordList = keyword;
          if (checkNlpKeywordCategory) {
            keywordList = [...keyword, ...selectedKeywordList];
          }
        } else {
          keywordList = keyword.filter((item) => item.foundIn.includes(screenName));
          if (checkNlpKeywordCategory) {
            keywordList = [...keyword, ...selectedKeywordList].filter((item) => item.foundIn.includes(screenName));
          }
        }
        const defineColor = (item) => {
          if (item?.recommendation?.[screenName]) {
            const count = item.usage[screenName];
            const avg = item.recommendation[screenName][0];
            const max = item.recommendation[screenName][1];
            if (count < avg) {
              return "yellow";
            } else if (count > max) {
              return "red";
            } else {
              return "green";
            }
          } else {
            return "yellow";
          }
        };
        const handleNlpKeyword = (currentKeyword) => {
          setInput("nlpKeywordList", [...nlpKeywordList, currentKeyword]);
          const currentKeywordObj = statisticsKeyword[currentKeyword];
          setInput("restStatisticsKeyword", {
            ...restStatisticsKeyword,
            [currentKeyword]: currentKeywordObj
          });
          const findKeywordObj = keyword.find(({ keyword: keyword2 }) => keyword2 === currentKeyword);
          setInput("selectedKeywordList", [...selectedKeywordList, findKeywordObj]);
          delete statisticsKeyword[currentKeyword];
          let statisticsData2 = {
            ...sidebar4.statisticsData,
            keywords: { ...statisticsKeyword }
          };
          setSidebar({ statisticsData: statisticsData2 });
          setIsUpdateData((prevState) => !prevState);
        };
        const handleSelectedKeyword = (currentKeyword) => {
          setInput("nlpKeywordList", nlpKeywordList.filter((keyword2) => keyword2 !== currentKeyword));
          setInput("selectedKeywordList", selectedKeywordList.filter(({ keyword: keyword2 }) => keyword2 !== currentKeyword));
          const currentKeywordObj = restStatisticsKeyword[currentKeyword];
          let statisticsData2 = {
            ...sidebar4.statisticsData,
            keywords: {
              ...statisticsKeyword,
              [currentKeyword]: currentKeywordObj
            }
          };
          delete restStatisticsKeyword[currentKeyword];
          setSidebar({ statisticsData: statisticsData2 });
          setIsUpdateData((prevState) => !prevState);
        };
        const isSelectedEl = (currentKeyword) => {
          const activeCursor = checkNlpKeywordCategory ? "nlp-keywords" : "";
          if (nlpKeywordList.includes(currentKeyword) && checkNlpKeywordCategory) {
            return `inactive-el ${activeCursor}`;
          } else {
            return `active-el ${activeCursor}`;
          }
        };
        const manageKeyword = (currentKeyword) => {
          if (checkNlpKeywordCategory) {
            if (selectedKeywordList.find(({ keyword: keyword2 }) => keyword2 === currentKeyword)) {
              handleSelectedKeyword(currentKeyword);
            } else {
              handleNlpKeyword(currentKeyword);
            }
          }
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis-category-container"
        }, ["NLP Keywords", "Custom Keywords"].includes(category) ? /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-statistics-keyword-analysis-category-title"
        }, category, ":", /* @__PURE__ */ React.createElement(Libs21.Tooltip, {
          title: sidebar4.__(tooltipText, "getgenie"),
          placement: "top"
        })) : "", /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis-category-keywords"
        }, keywordList.map((item, index2) => {
          return /* @__PURE__ */ React.createElement("div", {
            key: index2,
            className: `getgenie-statistics-keyword-analysis-category-keyword ${defineColor(item)} ${isSelectedEl(item.keyword)} `
          }, /* @__PURE__ */ React.createElement("div", {
            className: `getgenie-statistics-keyword-analysis-category-keyword-title ${defineColor(item)}`
          }, item.keyword), /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-statistics-keyword-analysis-category-keyword-usage"
          }, typeof item?.usage === "object" ? item?.usage[screenName] : item?.usage, item?.recommendation?.[screenName] && " / " + item.recommendation[screenName][0] + " - " + item?.recommendation?.[screenName][1]), checkNlpKeywordCategory && /* @__PURE__ */ React.createElement("div", {
            onClick: () => manageKeyword(item.keyword),
            className: "select-deselect-btn"
          }, /* @__PURE__ */ React.createElement(Tooltip9, {
            placement: "top",
            zIndex: 9999,
            title: "Select/Deselect this keyword from analysis."
          }, /* @__PURE__ */ React.createElement("span", {
            className: `select-deselect-common ${selectedKeywordList.find(({ keyword: keyword2 }) => keyword2 === item.keyword) ? "getgenie-icon-plus add" : " getgenie-icon-minus remove"}`
          }))));
        })));
      }, ["sidebar", "setSidebar", "getInputs", "setInput"]);
      Category_default = Category;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/KeywordScreen.js
  var useState16, useEffect21, ComposeComponents24, KeywordScreen, KeywordScreen_default;
  var init_KeywordScreen = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/KeywordScreen.js"() {
      init_Category();
      ({ useState: useState16, useEffect: useEffect21 } = window.React);
      ({ ComposeComponents: ComposeComponents24 } = window.getGenie.Components.Common.ReduxManager);
      KeywordScreen = ComposeComponents24(({ sidebar: sidebar4, getInputs, screenName = "AllKeyword" }) => {
        const [keywordList, setKeywordList] = useState16({});
        const [customKeyword, setCustomKeyword] = useState16([]);
        const tooltipText = {
          "nlp": "The AI-filtered NLP keyword suggestions for further optimization.",
          "custom": "The keywords you inputted or selected manually for adding to your content."
        };
        let keywordLists;
        if (sidebar4.analyzedContent.statistics.keywords?.focus) {
          if (sidebar4.analyzedContent.statistics.keywords?.common) {
            keywordLists = {
              ...sidebar4.analyzedContent.statistics.keywords,
              common: [...sidebar4.analyzedContent.statistics.keywords.focus, ...sidebar4.analyzedContent.statistics.keywords.common]
            };
          } else {
            keywordLists = {
              ...sidebar4.analyzedContent.statistics.keywords,
              common: [...sidebar4.analyzedContent.statistics.keywords.focus]
            };
          }
        } else {
          keywordLists = sidebar4.analyzedContent.statistics.keywords;
        }
        const category = {
          "common": "Common Keywords",
          "nlp": "NLP Keywords",
          "focus": "Focus Keywords"
        };
        useEffect21(() => {
          if (sidebar4.analyzedContent.statistics.keywords?.focus) {
            if (sidebar4.analyzedContent.statistics.keywords?.common) {
              setKeywordList(
                {
                  ...sidebar4.analyzedContent.statistics.keywords,
                  common: [...sidebar4.analyzedContent.statistics.keywords.common, ...sidebar4.analyzedContent.statistics.keywords.focus]
                }
              );
            } else {
              setKeywordList(
                {
                  ...sidebar4.analyzedContent.statistics.keywords,
                  common: [...sidebar4.analyzedContent.statistics.keywords.focus]
                }
              );
            }
          } else {
            setKeywordList(sidebar4.analyzedContent.statistics.keywords);
          }
        }, [sidebar4.analyzedContent.statistics.keywords]);
        useEffect21(() => {
          if (sidebar4.contentScoreSearchKeyword !== "") {
            let data = {};
            for (const [key, value2] of Object.entries(keywordLists)) {
              data[key] = value2.filter((item) => item.keyword.toLowerCase().includes(sidebar4.contentScoreSearchKeyword.toLowerCase()));
            }
            setKeywordList(data);
            setCustomKeyword(getInputs["customKeywords"].filter((item) => item.keyword.toLowerCase().includes(sidebar4.contentScoreSearchKeyword.toLowerCase())));
          } else {
            setKeywordList(keywordLists);
            setCustomKeyword(getInputs["customKeywords"]);
          }
        }, [sidebar4.contentScoreSearchKeyword]);
        useEffect21(() => {
          setCustomKeyword(getInputs["customKeywords"] || []);
        }, [getInputs["customKeywords"]]);
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis"
        }, ["metaTitle", "metaDescription"].includes(screenName) ? /* @__PURE__ */ React.createElement(Category_default, {
          category: category["focus"],
          keyword: keywordList["focus"],
          screenName
        }) : /* @__PURE__ */ React.createElement(React.Fragment, null, Object.keys(category).map((item, index2) => {
          if (item !== "focus") {
            return /* @__PURE__ */ React.createElement(Category_default, {
              key: index2,
              category: category[item],
              keyword: keywordList[item],
              screenName,
              tooltipText: tooltipText[item]
            });
          }
        }), /* @__PURE__ */ React.createElement(Category_default, {
          category: "Custom Keywords",
          keyword: customKeyword,
          tooltipText: tooltipText["custom"]
        })));
      }, ["sidebar", "setSidebar", "getInputs"]);
      KeywordScreen_default = KeywordScreen;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/MetaKeywords.js
  var ComposeComponents25, MetaKeywords, MetaKeywords_default;
  var init_MetaKeywords = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/keywordScreen/MetaKeywords.js"() {
      init_KeywordScreen();
      ({ ComposeComponents: ComposeComponents25 } = window.getGenie.Components.Common.ReduxManager);
      MetaKeywords = ComposeComponents25(({ sidebar: sidebar4, setSidebar }) => {
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis-meta-keyword"
        }, /* @__PURE__ */ React.createElement("h4", {
          className: "getgenie-statistics-keyword-analysis-meta-title"
        }, "Meta Title:"), /* @__PURE__ */ React.createElement(KeywordScreen_default, {
          screenName: "metaTitle"
        }), /* @__PURE__ */ React.createElement("h4", {
          className: "getgenie-statistics-keyword-analysis-meta-description"
        }, "Meta Description:"), /* @__PURE__ */ React.createElement(KeywordScreen_default, {
          screenName: "metaDescription"
        }));
      }, ["sidebar", "setSidebar"]);
      MetaKeywords_default = MetaKeywords;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/SearchBar.js
  var ComposeComponents26, Utilities12, GenieHelpers9, useState17, useEffect22, Button9, Input3, keywordFinder4, SearchBar, SearchBar_default;
  var init_SearchBar = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/SearchBar.js"() {
      init_KeywordFinder();
      ({ ComposeComponents: ComposeComponents26 } = window.getGenie.Components.Common.ReduxManager);
      ({ Utilities: Utilities12 } = window.getGenie.Components.Common);
      ({ GenieHelpers: GenieHelpers9 } = Utilities12);
      ({ useState: useState17, useEffect: useEffect22 } = window.React);
      ({ Button: Button9, Input: Input3 } = window.antd);
      keywordFinder4 = new KeywordFinder();
      SearchBar = ComposeComponents26(({ sidebar: sidebar4, setSidebar, getInputs, setInput }) => {
        const [showTextArea, setShowTextArea] = useState17(false);
        const [customKeyword, setCustomKeyword] = useState17("");
        const [showSearchBox, setShowSearchBox] = useState17(false);
        const handleSearch = (e) => {
          setSidebar({
            ...sidebar4,
            contentScoreSearchKeyword: e.target.value
          });
        };
        const handleBlue = () => {
          setShowSearchBox(false);
          setSidebar({ ...sidebar4, contentScoreSearchKeyword: "" });
        };
        const handleEditedText = (e) => {
          if (e.type === "keyup" && (e.key !== "Shift" && e.key === "Enter" || e?.which === 13)) {
            setCustomKeyword("");
            const oldKeywords = getInputs["customKeywords"] || [];
            let usage = keywordFinder4.findSingleMatch(sidebar4.currentPostContent, customKeyword);
            const newKeywords = [...oldKeywords, { keyword: customKeyword, usage }];
            setInput("customKeywords", newKeywords);
            setShowTextArea(false);
          }
        };
        useEffect22(() => {
          GenieHelpers9.storeData("customKeywords");
        }, [getInputs["customKeywords"]]);
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis-category-custom-button"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-keyword-analysis-category-custom-button-container"
        }, !showSearchBox && /* @__PURE__ */ React.createElement(Button9, {
          className: "add-outline-btn",
          onMouseDown: (e) => {
            e.preventDefault();
            setShowTextArea(!showTextArea);
          }
        }, sidebar4.__("Add Custom Keyword", "getgenie")), showSearchBox && /* @__PURE__ */ React.createElement(Input3, {
          bordered: false,
          className: "getgenie-input-search-bar",
          placeholder: sidebar4.__("Search...", "getgenie"),
          autoFocus: true,
          onBlur: handleBlue,
          onChange: (e) => handleSearch(e),
          prefix: /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-search"
          })
        }), !showSearchBox && /* @__PURE__ */ React.createElement("div", {
          onClick: () => {
            setShowSearchBox(true);
          },
          className: "getgenie-search-icon"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-search"
        }))), showTextArea && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("textarea", {
          autoFocus: true,
          onChange: (e) => {
            setCustomKeyword(e.target.value.replace("\n", ""));
          },
          onBlur: () => setShowTextArea(false),
          className: "getgenie-outline-cards-input",
          value: customKeyword,
          style: { display: "block", marginTop: "4px" },
          placeholder: sidebar4.__("Please enter your custom keyword", "getgenie"),
          onKeyUp: (e) => handleEditedText(e)
        })));
      }, ["sidebar", "setSidebar", "setInput", "getInputs"]);
      SearchBar_default = SearchBar;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/index.js
  var Button10, Libs22, ComposeComponents27, useEffect23, useState18, BlogAnalysis, BlogAnalysis_default;
  var init_BlogAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/BlogAnalysis/index.js"() {
      init_ScoreDetails();
      init_Feedback();
      init_ScoreMeter();
      init_KeywordScreen();
      init_MetaKeywords();
      init_SearchBar();
      ({ Button: Button10 } = window.antd);
      ({ Libs: Libs22 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents27 } = window.getGenie.Components.Common.ReduxManager);
      ({ useEffect: useEffect23, useState: useState18 } = window.React);
      BlogAnalysis = ComposeComponents27(({ setSidebar, sidebar: sidebar4 }) => {
        const [screen, setScreen] = useState18({ currentScreen: "all", activeIndex: 0 });
        const { contentStats } = sidebar4?.analyzedContent;
        const { competitorStats } = sidebar4;
        const [showAnalysis, setShowAnalysis] = useState18(false);
        const { imageUrl } = sidebar4;
        useEffect23(() => {
          setSidebar({
            analyzeKeyword: {
              ...sidebar4.analyzeKeyword,
              open: false
            },
            generatedOutlines: {
              ...sidebar4.generatedOutlines,
              open: false
            }
          });
        }, []);
        const handleShowAnalysis = () => {
          setShowAnalysis(!showAnalysis);
        };
        const keywordTabList = [
          { keywordName: "All", screen: "all" },
          { keywordName: "Heading", screen: "heading" },
          { keywordName: "Content", screen: "content" },
          { keywordName: "Meta", screen: "meta" }
        ];
        const handleKeywordTab = (currentScreen, activeIndex) => {
          setScreen({ currentScreen, activeIndex });
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-container"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-container-data"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score"
        }, /* @__PURE__ */ React.createElement(ScoreMeter_default, {
          imageUrl,
          totalContentStats: contentStats,
          handleShowAnalysis,
          showAnalysis,
          competitorStat: competitorStats
        }), !showAnalysis && /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-statistics-score-detail-container"
        }, /* @__PURE__ */ React.createElement(ScoreDetails_default, null), /* @__PURE__ */ React.createElement(SearchBar_default, null), /* @__PURE__ */ React.createElement("div", {
          className: "keyword-tab-container"
        }, keywordTabList.map((keyword, index2) => /* @__PURE__ */ React.createElement(Button10, {
          key: index2,
          onClick: () => handleKeywordTab(keyword.screen, index2),
          className: `keyword-btn-tab ${screen.activeIndex === index2 ? "active-keyword-tab" : "in-active-keyword-tab"}`
        }, keyword.keywordName))), /* @__PURE__ */ React.createElement("h6", {
          className: "help-text-statistics-keyword"
        }, "Used / Average - Highest"), screen.currentScreen !== "meta" ? /* @__PURE__ */ React.createElement(KeywordScreen_default, {
          screenName: screen.currentScreen
        }) : /* @__PURE__ */ React.createElement(MetaKeywords_default, null)), showAnalysis && /* @__PURE__ */ React.createElement(Feedback_default, null)))));
      }, ["setSidebar", "sidebar"]);
      BlogAnalysis_default = BlogAnalysis;
    }
  });

  // node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js
  function getElements(state, event, options) {
    const mode = interaction.modes[options.mode] || interaction.modes.nearest;
    return mode(state, event, options);
  }
  function inRangeByAxis(element, event, axis) {
    if (axis !== "x" && axis !== "y") {
      return element.inRange(event.x, event.y, "x", true) || element.inRange(event.x, event.y, "y", true);
    }
    return element.inRange(event.x, event.y, axis, true);
  }
  function getPointByAxis(event, center, axis) {
    if (axis === "x") {
      return { x: event.x, y: center.y };
    } else if (axis === "y") {
      return { x: center.x, y: event.y };
    }
    return center;
  }
  function filterElements(state, event, options) {
    return state.visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));
  }
  function getNearestItem(state, event, options) {
    let minDistance = Number.POSITIVE_INFINITY;
    return filterElements(state, event, options).reduce((nearestItems, element) => {
      const center = element.getCenterPoint();
      const evenPoint = getPointByAxis(event, center, options.axis);
      const distance = distanceBetweenPoints(event, evenPoint);
      if (distance < minDistance) {
        nearestItems = [element];
        minDistance = distance;
      } else if (distance === minDistance) {
        nearestItems.push(element);
      }
      return nearestItems;
    }, []).sort((a, b) => a._index - b._index).slice(0, 1);
  }
  function updateListeners(chart, state, options) {
    state.listened = false;
    state.moveListened = false;
    state._getElements = getElements;
    hooks.forEach((hook) => {
      if (typeof options[hook] === "function") {
        state.listened = true;
        state.listeners[hook] = options[hook];
      } else if (defined(state.listeners[hook])) {
        delete state.listeners[hook];
      }
    });
    moveHooks.forEach((hook) => {
      if (typeof options[hook] === "function") {
        state.moveListened = true;
      }
    });
    if (!state.listened || !state.moveListened) {
      state.annotations.forEach((scope2) => {
        if (!state.listened && typeof scope2.click === "function") {
          state.listened = true;
        }
        if (!state.moveListened) {
          moveHooks.forEach((hook) => {
            if (typeof scope2[hook] === "function") {
              state.listened = true;
              state.moveListened = true;
            }
          });
        }
      });
    }
  }
  function handleEvent(state, event, options) {
    if (state.listened) {
      switch (event.type) {
        case "mousemove":
        case "mouseout":
          return handleMoveEvents2(state, event, options);
        case "click":
          return handleClickEvents2(state, event, options);
      }
    }
  }
  function handleMoveEvents2(state, event, options) {
    if (!state.moveListened) {
      return;
    }
    let elements;
    if (event.type === "mousemove") {
      elements = getElements(state, event, options.interaction);
    } else {
      elements = [];
    }
    const previous = state.hovered;
    state.hovered = elements;
    const context2 = { state, event };
    let changed = dispatchMoveEvents2(context2, "leave", previous, elements);
    return dispatchMoveEvents2(context2, "enter", elements, previous) || changed;
  }
  function dispatchMoveEvents2({ state, event }, hook, elements, checkElements) {
    let changed;
    for (const element of elements) {
      if (checkElements.indexOf(element) < 0) {
        changed = dispatchEvent2(element.options[hook] || state.listeners[hook], element, event) || changed;
      }
    }
    return changed;
  }
  function handleClickEvents2(state, event, options) {
    const listeners = state.listeners;
    const elements = getElements(state, event, options.interaction);
    let changed;
    for (const element of elements) {
      changed = dispatchEvent2(element.options.click || listeners.click, element, event) || changed;
    }
    return changed;
  }
  function dispatchEvent2(handler, element, event) {
    return callback(handler, [element.$context, event]) === true;
  }
  function clampAll(obj, from2, to2) {
    for (const key of Object.keys(obj)) {
      obj[key] = clamp(obj[key], from2, to2);
    }
    return obj;
  }
  function inPointRange(point, center, radius, borderWidth) {
    if (!point || !center || radius <= 0) {
      return false;
    }
    const hBorderWidth = borderWidth / 2;
    return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);
  }
  function inBoxRange(point, { x, y, x2, y2 }, axis, borderWidth) {
    const hBorderWidth = borderWidth / 2;
    const inRangeX = point.x >= x - hBorderWidth - EPSILON2 && point.x <= x2 + hBorderWidth + EPSILON2;
    const inRangeY = point.y >= y - hBorderWidth - EPSILON2 && point.y <= y2 + hBorderWidth + EPSILON2;
    if (axis === "x") {
      return inRangeX;
    } else if (axis === "y") {
      return inRangeY;
    }
    return inRangeX && inRangeY;
  }
  function getElementCenterPoint(element, useFinalPosition) {
    const { centerX, centerY } = element.getProps(["centerX", "centerY"], useFinalPosition);
    return { x: centerX, y: centerY };
  }
  function requireVersion(pkg, min, ver, strict = true) {
    const parts2 = ver.split(".");
    let i2 = 0;
    for (const req of min.split(".")) {
      const act = parts2[i2++];
      if (parseInt(req, 10) < parseInt(act, 10)) {
        break;
      }
      if (isOlderPart(act, req)) {
        if (strict) {
          throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);
        } else {
          return false;
        }
      }
    }
    return true;
  }
  function getRelativePosition2(size, position) {
    if (position === "start") {
      return 0;
    }
    if (position === "end") {
      return size;
    }
    if (isPercentString(position)) {
      return toPercent(position) * size;
    }
    return size / 2;
  }
  function getSize(size, value2) {
    if (typeof value2 === "number") {
      return value2;
    } else if (isPercentString(value2)) {
      return toPercent(value2) * size;
    }
    return size;
  }
  function calculateTextAlignment(size, options) {
    const { x, width } = size;
    const textAlign = options.textAlign;
    if (textAlign === "center") {
      return x + width / 2;
    } else if (textAlign === "end" || textAlign === "right") {
      return x + width;
    }
    return x;
  }
  function toPosition(value2) {
    if (isObject(value2)) {
      return {
        x: valueOrDefault(value2.x, "center"),
        y: valueOrDefault(value2.y, "center")
      };
    }
    value2 = valueOrDefault(value2, "center");
    return {
      x: value2,
      y: value2
    };
  }
  function isBoundToPoint(options) {
    return options && (defined(options.xValue) || defined(options.yValue));
  }
  function isImageOrCanvas(content) {
    if (content && typeof content === "object") {
      const type = content.toString();
      return type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]";
    }
  }
  function translate(ctx, { x, y }, rotation) {
    if (rotation) {
      ctx.translate(x, y);
      ctx.rotate(toRadians(rotation));
      ctx.translate(-x, -y);
    }
  }
  function setBorderStyle(ctx, options) {
    if (options && options.borderWidth) {
      ctx.lineCap = options.borderCapStyle;
      ctx.setLineDash(options.borderDash);
      ctx.lineDashOffset = options.borderDashOffset;
      ctx.lineJoin = options.borderJoinStyle;
      ctx.lineWidth = options.borderWidth;
      ctx.strokeStyle = options.borderColor;
      return true;
    }
  }
  function setShadowStyle(ctx, options) {
    ctx.shadowColor = options.backgroundShadowColor;
    ctx.shadowBlur = options.shadowBlur;
    ctx.shadowOffsetX = options.shadowOffsetX;
    ctx.shadowOffsetY = options.shadowOffsetY;
  }
  function measureLabelSize2(ctx, options) {
    const content = options.content;
    if (isImageOrCanvas(content)) {
      return {
        width: getSize(content.width, options.width),
        height: getSize(content.height, options.height)
      };
    }
    const font = toFont(options.font);
    const strokeWidth = options.textStrokeWidth;
    const lines = isArray(content) ? content : [content];
    const mapKey = lines.join() + font.string + strokeWidth + (ctx._measureText ? "-spriting" : "");
    if (!widthCache.has(mapKey)) {
      ctx.save();
      ctx.font = font.string;
      const count = lines.length;
      let width = 0;
      for (let i2 = 0; i2 < count; i2++) {
        const text = lines[i2];
        width = Math.max(width, ctx.measureText(text).width + strokeWidth);
      }
      ctx.restore();
      const height = count * font.lineHeight + strokeWidth;
      widthCache.set(mapKey, { width, height });
    }
    return widthCache.get(mapKey);
  }
  function drawBox(ctx, rect, options) {
    const { x, y, width, height } = rect;
    ctx.save();
    setShadowStyle(ctx, options);
    const stroke = setBorderStyle(ctx, options);
    ctx.fillStyle = options.backgroundColor;
    ctx.beginPath();
    addRoundedRectPath(ctx, {
      x,
      y,
      w: width,
      h: height,
      radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)
    });
    ctx.closePath();
    ctx.fill();
    if (stroke) {
      ctx.shadowColor = options.borderShadowColor;
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawLabel(ctx, rect, options) {
    const content = options.content;
    if (isImageOrCanvas(content)) {
      ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);
      return;
    }
    const labels = isArray(content) ? content : [content];
    const font = toFont(options.font);
    const lh = font.lineHeight;
    const x = calculateTextAlignment(rect, options);
    const y = rect.y + lh / 2 + options.textStrokeWidth / 2;
    ctx.save();
    ctx.font = font.string;
    ctx.textBaseline = "middle";
    ctx.textAlign = options.textAlign;
    if (setTextStrokeStyle(ctx, options)) {
      labels.forEach((l, i2) => ctx.strokeText(l, x, y + i2 * lh));
    }
    ctx.fillStyle = options.color;
    labels.forEach((l, i2) => ctx.fillText(l, x, y + i2 * lh));
    ctx.restore();
  }
  function setTextStrokeStyle(ctx, options) {
    if (options.textStrokeWidth > 0) {
      ctx.lineJoin = "round";
      ctx.miterLimit = 2;
      ctx.lineWidth = options.textStrokeWidth;
      ctx.strokeStyle = options.textStrokeColor;
      return true;
    }
  }
  function scaleValue(scale, value2, fallback) {
    value2 = typeof value2 === "number" ? value2 : scale.parse(value2);
    return isNumberFinite(value2) ? scale.getPixelForValue(value2) : fallback;
  }
  function retrieveScaleID(scales, options, key) {
    const scaleID = options[key];
    if (scaleID || key === "scaleID") {
      return scaleID;
    }
    const axis = key.charAt(0);
    const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);
    if (axes.length) {
      return axes[0].id;
    }
    return axis;
  }
  function getDimensionByScale(scale, options) {
    if (scale) {
      const reverse = scale.options.reverse;
      const start = scaleValue(scale, options.min, reverse ? options.end : options.start);
      const end = scaleValue(scale, options.max, reverse ? options.start : options.end);
      return {
        start,
        end
      };
    }
  }
  function getChartPoint(chart, options) {
    const { chartArea, scales } = chart;
    const xScale = scales[retrieveScaleID(scales, options, "xScaleID")];
    const yScale = scales[retrieveScaleID(scales, options, "yScaleID")];
    let x = chartArea.width / 2;
    let y = chartArea.height / 2;
    if (xScale) {
      x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);
    }
    if (yScale) {
      y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);
    }
    return { x, y };
  }
  function resolveBoxProperties(chart, options) {
    const scales = chart.scales;
    const xScale = scales[retrieveScaleID(scales, options, "xScaleID")];
    const yScale = scales[retrieveScaleID(scales, options, "yScaleID")];
    if (!xScale && !yScale) {
      return {};
    }
    let { left: x, right: x2 } = xScale || chart.chartArea;
    let { top: y, bottom: y2 } = yScale || chart.chartArea;
    const xDim = getChartDimensionByScale(xScale, { min: options.xMin, max: options.xMax, start: x, end: x2 });
    x = xDim.start;
    x2 = xDim.end;
    const yDim = getChartDimensionByScale(yScale, { min: options.yMin, max: options.yMax, start: y2, end: y });
    y = yDim.start;
    y2 = yDim.end;
    return {
      x,
      y,
      x2,
      y2,
      width: x2 - x,
      height: y2 - y,
      centerX: x + (x2 - x) / 2,
      centerY: y + (y2 - y) / 2
    };
  }
  function resolvePointProperties(chart, options) {
    if (!isBoundToPoint(options)) {
      const box = resolveBoxProperties(chart, options);
      let radius = options.radius;
      if (!radius || isNaN(radius)) {
        radius = Math.min(box.width, box.height) / 2;
        options.radius = radius;
      }
      const size = radius * 2;
      return {
        x: box.x + options.xAdjust,
        y: box.y + options.yAdjust,
        x2: box.x + size + options.xAdjust,
        y2: box.y + size + options.yAdjust,
        centerX: box.centerX + options.xAdjust,
        centerY: box.centerY + options.yAdjust,
        width: size,
        height: size
      };
    }
    return getChartCircle(chart, options);
  }
  function resolveBoxAndLabelProperties(chart, options) {
    const properties = resolveBoxProperties(chart, options);
    const { x, y } = properties;
    properties.elements = [{
      type: "label",
      optionScope: "label",
      properties: resolveLabelElementProperties$1(chart, properties, options)
    }];
    properties.initProperties = { x, y };
    return properties;
  }
  function getChartCircle(chart, options) {
    const point = getChartPoint(chart, options);
    const size = options.radius * 2;
    return {
      x: point.x - options.radius + options.xAdjust,
      y: point.y - options.radius + options.yAdjust,
      x2: point.x + options.radius + options.xAdjust,
      y2: point.y + options.radius + options.yAdjust,
      centerX: point.x + options.xAdjust,
      centerY: point.y + options.yAdjust,
      width: size,
      height: size
    };
  }
  function getChartDimensionByScale(scale, options) {
    const result = getDimensionByScale(scale, options) || options;
    return {
      start: Math.min(result.start, result.end),
      end: Math.max(result.start, result.end)
    };
  }
  function calculateX({ properties, options }, labelSize, position, padding) {
    const { x: start, x2: end, width: size } = properties;
    return calculatePosition$1({ start, end, size, borderWidth: options.borderWidth }, {
      position: position.x,
      padding: { start: padding.left, end: padding.right },
      adjust: options.label.xAdjust,
      size: labelSize.width
    });
  }
  function calculateY({ properties, options }, labelSize, position, padding) {
    const { y: start, y2: end, height: size } = properties;
    return calculatePosition$1({ start, end, size, borderWidth: options.borderWidth }, {
      position: position.y,
      padding: { start: padding.top, end: padding.bottom },
      adjust: options.label.yAdjust,
      size: labelSize.height
    });
  }
  function calculatePosition$1(boxOpts, labelOpts) {
    const { start, end, borderWidth } = boxOpts;
    const { position, padding: { start: padStart, end: padEnd }, adjust } = labelOpts;
    const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;
    return start + borderWidth / 2 + adjust + getRelativePosition2(availableSize, position);
  }
  function resolveLabelElementProperties$1(chart, properties, options) {
    const label = options.label;
    label.backgroundColor = "transparent";
    label.callout.display = false;
    const position = toPosition(label.position);
    const padding = toPadding(label.padding);
    const labelSize = measureLabelSize2(chart.ctx, label);
    const x = calculateX({ properties, options }, labelSize, position, padding);
    const y = calculateY({ properties, options }, labelSize, position, padding);
    const width = labelSize.width + padding.width;
    const height = labelSize.height + padding.height;
    return {
      x,
      y,
      x2: x + width,
      y2: y + height,
      width,
      height,
      centerX: x + width / 2,
      centerY: y + height / 2,
      rotation: label.rotation
    };
  }
  function rotated2(point, center, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const cx = center.x;
    const cy = center.y;
    return {
      x: cx + cos * (point.x - cx) - sin * (point.y - cy),
      y: cy + sin * (point.x - cx) + cos * (point.y - cy)
    };
  }
  function adjustScaleRange(chart, scale, annotations) {
    const range = getScaleLimits(chart.scales, scale, annotations);
    let changed = changeScaleLimit(scale, range, "min", "suggestedMin");
    changed = changeScaleLimit(scale, range, "max", "suggestedMax") || changed;
    if (changed && typeof scale.handleTickRangeOptions === "function") {
      scale.handleTickRangeOptions();
    }
  }
  function verifyScaleOptions(annotations, scales) {
    for (const annotation2 of annotations) {
      verifyScaleIDs(annotation2, scales);
    }
  }
  function changeScaleLimit(scale, range, limit, suggestedLimit) {
    if (isNumberFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {
      const changed = scale[limit] !== range[limit];
      scale[limit] = range[limit];
      return changed;
    }
  }
  function scaleLimitDefined(scaleOptions, limit, suggestedLimit) {
    return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);
  }
  function verifyScaleIDs(annotation2, scales) {
    for (const key of ["scaleID", "xScaleID", "yScaleID"]) {
      const scaleID = retrieveScaleID(scales, annotation2, key);
      if (scaleID && !scales[scaleID] && verifyProperties(annotation2, key)) {
        console.warn(`No scale found with id '${scaleID}' for annotation '${annotation2.id}'`);
      }
    }
  }
  function verifyProperties(annotation2, key) {
    if (key === "scaleID") {
      return true;
    }
    const axis = key.charAt(0);
    for (const prop of ["Min", "Max", "Value"]) {
      if (defined(annotation2[axis + prop])) {
        return true;
      }
    }
    return false;
  }
  function getScaleLimits(scales, scale, annotations) {
    const axis = scale.axis;
    const scaleID = scale.id;
    const scaleIDOption = axis + "ScaleID";
    const limits = {
      min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),
      max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)
    };
    for (const annotation2 of annotations) {
      if (annotation2.scaleID === scaleID) {
        updateLimits2(annotation2, scale, ["value", "endValue"], limits);
      } else if (retrieveScaleID(scales, annotation2, scaleIDOption) === scaleID) {
        updateLimits2(annotation2, scale, [axis + "Min", axis + "Max", axis + "Value"], limits);
      }
    }
    return limits;
  }
  function updateLimits2(annotation2, scale, props, limits) {
    for (const prop of props) {
      const raw = annotation2[prop];
      if (defined(raw)) {
        const value2 = scale.parse(raw);
        limits.min = Math.min(limits.min, value2);
        limits.max = Math.max(limits.max, value2);
      }
    }
  }
  function measureRect(point, size, options, padding) {
    const width = size.width + padding.width + options.borderWidth;
    const height = size.height + padding.height + options.borderWidth;
    const position = toPosition(options.position);
    const x = calculatePosition(point.x, width, options.xAdjust, position.x);
    const y = calculatePosition(point.y, height, options.yAdjust, position.y);
    return {
      x,
      y,
      x2: x + width,
      y2: y + height,
      width,
      height,
      centerX: x + width / 2,
      centerY: y + height / 2
    };
  }
  function calculatePosition(start, size, adjust = 0, position) {
    return start - getRelativePosition2(size, position) + adjust;
  }
  function drawCallout(ctx, element) {
    const { pointX, pointY, options } = element;
    const callout = options.callout;
    const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);
    if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {
      return;
    }
    ctx.save();
    ctx.beginPath();
    const stroke = setBorderStyle(ctx, callout);
    if (!stroke) {
      return ctx.restore();
    }
    const { separatorStart, separatorEnd } = getCalloutSeparatorCoord(element, calloutPosition);
    const { sideStart, sideEnd } = getCalloutSideCoord(element, calloutPosition, separatorStart);
    if (callout.margin > 0 || options.borderWidth === 0) {
      ctx.moveTo(separatorStart.x, separatorStart.y);
      ctx.lineTo(separatorEnd.x, separatorEnd.y);
    }
    ctx.moveTo(sideStart.x, sideStart.y);
    ctx.lineTo(sideEnd.x, sideEnd.y);
    const rotatedPoint = rotated2({ x: pointX, y: pointY }, element.getCenterPoint(), toRadians(-element.rotation));
    ctx.lineTo(rotatedPoint.x, rotatedPoint.y);
    ctx.stroke();
    ctx.restore();
  }
  function getCalloutSeparatorCoord(element, position) {
    const { x, y, x2, y2 } = element;
    const adjust = getCalloutSeparatorAdjust(element, position);
    let separatorStart, separatorEnd;
    if (position === "left" || position === "right") {
      separatorStart = { x: x + adjust, y };
      separatorEnd = { x: separatorStart.x, y: y2 };
    } else {
      separatorStart = { x, y: y + adjust };
      separatorEnd = { x: x2, y: separatorStart.y };
    }
    return { separatorStart, separatorEnd };
  }
  function getCalloutSeparatorAdjust(element, position) {
    const { width, height, options } = element;
    const adjust = options.callout.margin + options.borderWidth / 2;
    if (position === "right") {
      return width + adjust;
    } else if (position === "bottom") {
      return height + adjust;
    }
    return -adjust;
  }
  function getCalloutSideCoord(element, position, separatorStart) {
    const { y, width, height, options } = element;
    const start = options.callout.start;
    const side = getCalloutSideAdjust(position, options.callout);
    let sideStart, sideEnd;
    if (position === "left" || position === "right") {
      sideStart = { x: separatorStart.x, y: y + getSize(height, start) };
      sideEnd = { x: sideStart.x + side, y: sideStart.y };
    } else {
      sideStart = { x: separatorStart.x + getSize(width, start), y: separatorStart.y };
      sideEnd = { x: sideStart.x, y: sideStart.y + side };
    }
    return { sideStart, sideEnd };
  }
  function getCalloutSideAdjust(position, options) {
    const side = options.side;
    if (position === "left" || position === "top") {
      return -side;
    }
    return side;
  }
  function resolveCalloutPosition(element, options) {
    const position = options.position;
    if (positions2.includes(position)) {
      return position;
    }
    return resolveCalloutAutoPosition(element, options);
  }
  function resolveCalloutAutoPosition(element, options) {
    const { x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation } = element;
    const center = { x: centerX, y: centerY };
    const start = options.start;
    const xAdjust = getSize(width, start);
    const yAdjust = getSize(height, start);
    const xPoints = [x, x + xAdjust, x + xAdjust, x2];
    const yPoints = [y + yAdjust, y2, y, y2];
    const result = [];
    for (let index2 = 0; index2 < 4; index2++) {
      const rotatedPoint = rotated2({ x: xPoints[index2], y: yPoints[index2] }, center, toRadians(rotation));
      result.push({
        position: positions2[index2],
        distance: distanceBetweenPoints(rotatedPoint, { x: pointX, y: pointY })
      });
    }
    return result.sort((a, b) => a.distance - b.distance)[0].position;
  }
  function getLabelSize({ x, y, width, height, options }) {
    const hBorderWidth = options.borderWidth / 2;
    const padding = toPadding(options.padding);
    return {
      x: x + padding.left + hBorderWidth,
      y: y + padding.top + hBorderWidth,
      width: width - padding.left - padding.right - options.borderWidth,
      height: height - padding.top - padding.bottom - options.borderWidth
    };
  }
  function isPointInRange(element, callout, position) {
    const { pointX, pointY } = element;
    const margin = callout.margin;
    let x = pointX;
    let y = pointY;
    if (position === "left") {
      x += margin;
    } else if (position === "right") {
      x -= margin;
    } else if (position === "top") {
      y += margin;
    } else if (position === "bottom") {
      y -= margin;
    }
    return element.inRange(x, y);
  }
  function isLineInArea({ x, y, x2, y2 }, { top, right, bottom, left }) {
    return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);
  }
  function limitPointToArea({ x, y }, p2, { top, right, bottom, left }) {
    if (x < left) {
      y = interpolateY(left, { x, y }, p2);
      x = left;
    }
    if (x > right) {
      y = interpolateY(right, { x, y }, p2);
      x = right;
    }
    if (y < top) {
      x = interpolateX(top, { x, y }, p2);
      y = top;
    }
    if (y > bottom) {
      x = interpolateX(bottom, { x, y }, p2);
      y = bottom;
    }
    return { x, y };
  }
  function limitLineToArea(p1, p2, area) {
    const { x, y } = limitPointToArea(p1, p2, area);
    const { x: x2, y: y2 } = limitPointToArea(p2, p1, area);
    return { x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y) };
  }
  function intersects(element, { mouseX, mouseY }, epsilon = EPSILON2, useFinalPosition) {
    const { x: x1, y: y1, x2, y2 } = element.getProps(["x", "y", "x2", "y2"], useFinalPosition);
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lenSq = sqr(dx) + sqr(dy);
    const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;
    let xx, yy;
    if (t < 0) {
      xx = x1;
      yy = y1;
    } else if (t > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + t * dx;
      yy = y1 + t * dy;
    }
    return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;
  }
  function isOnLabel(element, { mouseX, mouseY }, useFinalPosition, axis) {
    const label = element.label;
    return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);
  }
  function applyScaleValueToDimension(area, scale, options) {
    const dim = getDimensionByScale(scale, options);
    area[options.startProp] = dim.start;
    area[options.endProp] = dim.end;
  }
  function resolveLabelElementProperties(chart, properties, options) {
    const borderWidth = options.borderWidth;
    const padding = toPadding(options.padding);
    const textSize = measureLabelSize2(chart.ctx, options);
    const width = textSize.width + padding.width + borderWidth;
    const height = textSize.height + padding.height + borderWidth;
    return calculateLabelPosition(properties, options, { width, height, padding }, chart.chartArea);
  }
  function calculateAutoRotation(properties) {
    const { x, y, x2, y2 } = properties;
    const rotation = Math.atan2(y2 - y, x2 - x);
    return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;
  }
  function calculateLabelPosition(properties, label, sizes, chartArea) {
    const { width, height, padding } = sizes;
    const { xAdjust, yAdjust } = label;
    const p1 = { x: properties.x, y: properties.y };
    const p2 = { x: properties.x2, y: properties.y2 };
    const rotation = label.rotation === "auto" ? calculateAutoRotation(properties) : toRadians(label.rotation);
    const size = rotatedSize(width, height, rotation);
    const t = calculateT(properties, label, { labelSize: size, padding }, chartArea);
    const pt = pointInLine(p1, p2, t);
    const xCoordinateSizes = { size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left };
    const yCoordinateSizes = { size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top };
    const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;
    const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;
    return {
      x: centerX - width / 2,
      y: centerY - height / 2,
      x2: centerX + width / 2,
      y2: centerY + height / 2,
      centerX,
      centerY,
      pointX: pt.x,
      pointY: pt.y,
      width,
      height,
      rotation: toDegrees(rotation)
    };
  }
  function rotatedSize(width, height, rotation) {
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    return {
      w: Math.abs(width * cos) + Math.abs(height * sin),
      h: Math.abs(width * sin) + Math.abs(height * cos)
    };
  }
  function calculateT(properties, label, sizes, chartArea) {
    let t;
    const space = spaceAround(properties, chartArea);
    if (label.position === "start") {
      t = calculateTAdjust({ w: properties.x2 - properties.x, h: properties.y2 - properties.y }, sizes, label, space);
    } else if (label.position === "end") {
      t = 1 - calculateTAdjust({ w: properties.x - properties.x2, h: properties.y - properties.y2 }, sizes, label, space);
    } else {
      t = getRelativePosition2(1, label.position);
    }
    return t;
  }
  function calculateTAdjust(lineSize, sizes, label, space) {
    const { labelSize, padding } = sizes;
    const lineW = lineSize.w * space.dx;
    const lineH = lineSize.h * space.dy;
    const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;
    const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;
    return clamp(Math.max(x, y), 0, 0.25);
  }
  function spaceAround(properties, chartArea) {
    const { x, x2, y, y2 } = properties;
    const t = Math.min(y, y2) - chartArea.top;
    const l = Math.min(x, x2) - chartArea.left;
    const b = chartArea.bottom - Math.max(y, y2);
    const r = chartArea.right - Math.max(x, x2);
    return {
      x: Math.min(l, r),
      y: Math.min(t, b),
      dx: l <= r ? 1 : -1,
      dy: t <= b ? 1 : -1
    };
  }
  function adjustLabelCoordinate(coordinate, labelSizes) {
    const { size, min, max, padding } = labelSizes;
    const halfSize = size / 2;
    if (size > max - min) {
      return (max + min) / 2;
    }
    if (min >= coordinate - padding - halfSize) {
      coordinate = min + padding + halfSize;
    }
    if (max <= coordinate + padding + halfSize) {
      coordinate = max - padding - halfSize;
    }
    return coordinate;
  }
  function getArrowHeads(line) {
    const options = line.options;
    const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;
    const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;
    return {
      startOpts: arrowStartOpts,
      endOpts: arrowEndOpts,
      startAdjust: getLineAdjust(line, arrowStartOpts),
      endAdjust: getLineAdjust(line, arrowEndOpts)
    };
  }
  function getLineAdjust(line, arrowOpts) {
    if (!arrowOpts || !arrowOpts.display) {
      return 0;
    }
    const { length: length2, width } = arrowOpts;
    const adjust = line.options.borderWidth / 2;
    const p1 = { x: length2, y: width + adjust };
    const p2 = { x: 0, y: adjust };
    return Math.abs(interpolateX(0, p1, p2));
  }
  function drawArrowHead(ctx, offset, adjust, arrowOpts) {
    if (!arrowOpts || !arrowOpts.display) {
      return;
    }
    const { length: length2, width, fill, backgroundColor, borderColor } = arrowOpts;
    const arrowOffsetX = Math.abs(offset - length2) + adjust;
    ctx.beginPath();
    setShadowStyle(ctx, arrowOpts);
    setBorderStyle(ctx, arrowOpts);
    ctx.moveTo(arrowOffsetX, -width);
    ctx.lineTo(offset + adjust, 0);
    ctx.lineTo(arrowOffsetX, width);
    if (fill === true) {
      ctx.fillStyle = backgroundColor || borderColor;
      ctx.closePath();
      ctx.fill();
      ctx.shadowColor = "transparent";
    } else {
      ctx.shadowColor = arrowOpts.borderShadowColor;
    }
    ctx.stroke();
  }
  function pointInEllipse(p, ellipse, rotation, borderWidth) {
    const { width, height, centerX, centerY } = ellipse;
    const xRadius = width / 2;
    const yRadius = height / 2;
    if (xRadius <= 0 || yRadius <= 0) {
      return false;
    }
    const angle = toRadians(rotation || 0);
    const hBorderWidth = borderWidth / 2 || 0;
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);
    const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);
    return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;
  }
  function buildPointElement({ centerX, centerY }, { radius, borderWidth }, rad) {
    const halfBorder = borderWidth / 2;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const point = { x: centerX + sin * radius, y: centerY - cos * radius };
    return {
      type: "point",
      optionScope: "point",
      properties: {
        x: point.x,
        y: point.y,
        centerX: point.x,
        centerY: point.y,
        bX: centerX + sin * (radius + halfBorder),
        bY: centerY - cos * (radius + halfBorder)
      }
    };
  }
  function pointIsInPolygon(points, x, y, useFinalPosition) {
    let isInside = false;
    let A = points[points.length - 1].getProps(["bX", "bY"], useFinalPosition);
    for (const point of points) {
      const B = point.getProps(["bX", "bY"], useFinalPosition);
      if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {
        isInside = !isInside;
      }
      A = B;
    }
    return isInside;
  }
  function resolveType(type = "line") {
    if (annotationTypes[type]) {
      return type;
    }
    console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);
    return "line";
  }
  function updateElements(chart, state, options, mode) {
    const animations = resolveAnimations(chart, options.animations, mode);
    const annotations = state.annotations;
    const elements = resyncElements(state.elements, annotations);
    for (let i2 = 0; i2 < annotations.length; i2++) {
      const annotationOptions = annotations[i2];
      const element = getOrCreateElement(elements, i2, annotationOptions.type);
      const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));
      const properties = element.resolveElementProperties(chart, resolver);
      properties.skip = toSkip(properties);
      if ("elements" in properties) {
        updateSubElements(element, properties, resolver, animations);
        delete properties.elements;
      }
      if (!defined(element.x)) {
        Object.assign(element, properties);
      }
      properties.options = resolveAnnotationOptions(resolver);
      animations.update(element, properties);
    }
  }
  function toSkip(properties) {
    return isNaN(properties.x) || isNaN(properties.y);
  }
  function resolveAnimations(chart, animOpts, mode) {
    if (mode === "reset" || mode === "none" || mode === "resize") {
      return directUpdater;
    }
    return new Animations(chart, animOpts);
  }
  function updateSubElements(mainElement, { elements, initProperties }, resolver, animations) {
    const subElements = mainElement.elements || (mainElement.elements = []);
    subElements.length = elements.length;
    for (let i2 = 0; i2 < elements.length; i2++) {
      const definition = elements[i2];
      const properties = definition.properties;
      const subElement = getOrCreateElement(subElements, i2, definition.type, initProperties);
      const subResolver = resolver[definition.optionScope].override(definition);
      properties.options = resolveAnnotationOptions(subResolver);
      animations.update(subElement, properties);
    }
  }
  function getOrCreateElement(elements, index2, type, initProperties) {
    const elementClass = annotationTypes[resolveType(type)];
    let element = elements[index2];
    if (!element || !(element instanceof elementClass)) {
      element = elements[index2] = new elementClass();
      if (isObject(initProperties)) {
        Object.assign(element, initProperties);
      }
    }
    return element;
  }
  function resolveAnnotationOptions(resolver) {
    const elementClass = annotationTypes[resolveType(resolver.type)];
    const result = {};
    result.id = resolver.id;
    result.type = resolver.type;
    result.drawTime = resolver.drawTime;
    Object.assign(
      result,
      resolveObj(resolver, elementClass.defaults),
      resolveObj(resolver, elementClass.defaultRoutes)
    );
    for (const hook of hooks) {
      result[hook] = resolver[hook];
    }
    return result;
  }
  function resolveObj(resolver, defs) {
    const result = {};
    for (const prop of Object.keys(defs)) {
      const optDefs = defs[prop];
      const value2 = resolver[prop];
      result[prop] = isObject(optDefs) ? resolveObj(value2, optDefs) : value2;
    }
    return result;
  }
  function getContext(chart, element, annotation2) {
    return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {
      element,
      id: annotation2.id,
      type: "annotation"
    }));
  }
  function resyncElements(elements, annotations) {
    const count = annotations.length;
    const start = elements.length;
    if (start < count) {
      const add2 = count - start;
      elements.splice(start, 0, ...new Array(add2));
    } else if (start > count) {
      elements.splice(count, start - count);
    }
    return elements;
  }
  function draw2(chart, caller, clip) {
    const { ctx, chartArea } = chart;
    const { visibleElements } = chartStates.get(chart);
    if (clip) {
      clipArea(ctx, chartArea);
    }
    const drawableElements = getDrawableElements(visibleElements, caller).sort((a, b) => a.options.z - b.options.z);
    for (const element of drawableElements) {
      element.draw(chart.ctx, chartArea);
    }
    if (clip) {
      unclipArea(ctx);
    }
  }
  function getDrawableElements(elements, caller) {
    const drawableElements = [];
    for (const el of elements) {
      if (el.options.drawTime === caller) {
        drawableElements.push(el);
      }
      if (el.elements && el.elements.length) {
        for (const sub of el.elements) {
          if (sub.options.display && sub.options.drawTime === caller) {
            drawableElements.push(sub);
          }
        }
      }
    }
    return drawableElements;
  }
  var interaction, moveHooks, hooks, isOlderPart, EPSILON2, clamp, isPercentString, toPercent, widthCache, BoxAnnotation, positions2, LabelAnnotation, pointInLine, interpolateX, interpolateY, sqr, rangeLimit, LineAnnotation, arrowHeadsDefaults, EllipseAnnotation, PointAnnotation, PolygonAnnotation, annotationTypes, directUpdater, version2, chartStates, annotation;
  var init_chartjs_plugin_annotation_esm = __esm({
    "node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"() {
      init_chart();
      init_helpers2();
      interaction = {
        modes: {
          point(state, event) {
            return filterElements(state, event, { intersect: true });
          },
          nearest(state, event, options) {
            return getNearestItem(state, event, options);
          },
          x(state, event, options) {
            return filterElements(state, event, { intersect: options.intersect, axis: "x" });
          },
          y(state, event, options) {
            return filterElements(state, event, { intersect: options.intersect, axis: "y" });
          }
        }
      };
      moveHooks = ["enter", "leave"];
      hooks = moveHooks.concat("click");
      isOlderPart = (act, req) => req > act || act.length > req.length && act.slice(0, req.length) === req;
      EPSILON2 = 1e-3;
      clamp = (x, from2, to2) => Math.min(to2, Math.max(from2, x));
      isPercentString = (s) => typeof s === "string" && s.endsWith("%");
      toPercent = (s) => clamp(parseFloat(s) / 100, 0, 1);
      widthCache = /* @__PURE__ */ new Map();
      BoxAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          const { x, y } = rotated2({ x: mouseX, y: mouseY }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));
          return inBoxRange({ x, y }, this.getProps(["x", "y", "x2", "y2"], useFinalPosition), axis, this.options.borderWidth);
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          ctx.save();
          translate(ctx, this.getCenterPoint(), this.options.rotation);
          drawBox(ctx, this, this.options);
          ctx.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(chart, options) {
          return resolveBoxAndLabelProperties(chart, options);
        }
      };
      BoxAnnotation.id = "boxAnnotation";
      BoxAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderRadius: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        label: {
          backgroundColor: "transparent",
          borderWidth: 0,
          callout: {
            display: false
          },
          color: "black",
          content: null,
          display: false,
          drawTime: void 0,
          font: {
            family: void 0,
            lineHeight: void 0,
            size: void 0,
            style: void 0,
            weight: "bold"
          },
          height: void 0,
          padding: 6,
          position: "center",
          rotation: void 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          width: void 0,
          xAdjust: 0,
          yAdjust: 0,
          z: void 0
        },
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      BoxAnnotation.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      BoxAnnotation.descriptors = {
        label: {
          _fallback: true
        }
      };
      positions2 = ["left", "bottom", "top", "right"];
      LabelAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          const { x, y } = rotated2({ x: mouseX, y: mouseY }, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));
          return inBoxRange({ x, y }, this.getProps(["x", "y", "x2", "y2"], useFinalPosition), axis, this.options.borderWidth);
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          const options = this.options;
          const visible = !defined(this._visible) || this._visible;
          if (!options.display || !options.content || !visible) {
            return;
          }
          ctx.save();
          translate(ctx, this.getCenterPoint(), this.rotation);
          drawCallout(ctx, this);
          drawBox(ctx, this, options);
          drawLabel(ctx, getLabelSize(this), options);
          ctx.restore();
        }
        resolveElementProperties(chart, options) {
          let point;
          if (!isBoundToPoint(options)) {
            const { centerX, centerY } = resolveBoxProperties(chart, options);
            point = { x: centerX, y: centerY };
          } else {
            point = getChartPoint(chart, options);
          }
          const padding = toPadding(options.padding);
          const labelSize = measureLabelSize2(chart.ctx, options);
          const boxSize = measureRect(point, labelSize, options, padding);
          return {
            pointX: point.x,
            pointY: point.y,
            ...boxSize,
            rotation: options.rotation
          };
        }
      };
      LabelAnnotation.id = "labelAnnotation";
      LabelAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundColor: "transparent",
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderRadius: 0,
        borderShadowColor: "transparent",
        borderWidth: 0,
        callout: {
          borderCapStyle: "butt",
          borderColor: void 0,
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 1,
          display: false,
          margin: 5,
          position: "auto",
          side: 5,
          start: "50%"
        },
        color: "black",
        content: null,
        display: true,
        font: {
          family: void 0,
          lineHeight: void 0,
          size: void 0,
          style: void 0,
          weight: void 0
        },
        height: void 0,
        padding: 6,
        position: "center",
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        textAlign: "center",
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        width: void 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      LabelAnnotation.defaultRoutes = {
        borderColor: "color"
      };
      pointInLine = (p1, p2, t) => ({ x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) });
      interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;
      interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;
      sqr = (v) => v * v;
      rangeLimit = (mouseX, mouseY, { x, y, x2, y2 }, axis) => axis === "y" ? { start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY } : { start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX };
      LineAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          const hBorderWidth = this.options.borderWidth / 2;
          if (axis !== "x" && axis !== "y") {
            const epsilon = sqr(hBorderWidth);
            const point = { mouseX, mouseY };
            return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);
          }
          const limit = rangeLimit(mouseX, mouseY, this.getProps(["x", "y", "x2", "y2"], useFinalPosition), axis);
          return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth || isOnLabel(this, { mouseX, mouseY }, useFinalPosition, axis);
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          const { x, y, x2, y2, options } = this;
          ctx.save();
          if (!setBorderStyle(ctx, options)) {
            return ctx.restore();
          }
          setShadowStyle(ctx, options);
          const angle = Math.atan2(y2 - y, x2 - x);
          const length2 = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
          const { startOpts, endOpts, startAdjust, endAdjust } = getArrowHeads(this);
          ctx.translate(x, y);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(0 + startAdjust, 0);
          ctx.lineTo(length2 - endAdjust, 0);
          ctx.shadowColor = options.borderShadowColor;
          ctx.stroke();
          drawArrowHead(ctx, 0, startAdjust, startOpts);
          drawArrowHead(ctx, length2, -endAdjust, endOpts);
          ctx.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(chart, options) {
          const { scales, chartArea } = chart;
          const scale = scales[options.scaleID];
          const area = { x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom };
          let min, max;
          if (scale) {
            min = scaleValue(scale, options.value, NaN);
            max = scaleValue(scale, options.endValue, min);
            if (scale.isHorizontal()) {
              area.x = min;
              area.x2 = max;
            } else {
              area.y = min;
              area.y2 = max;
            }
          } else {
            const xScale = scales[retrieveScaleID(scales, options, "xScaleID")];
            const yScale = scales[retrieveScaleID(scales, options, "yScaleID")];
            if (xScale) {
              applyScaleValueToDimension(area, xScale, { min: options.xMin, max: options.xMax, start: xScale.left, end: xScale.right, startProp: "x", endProp: "x2" });
            }
            if (yScale) {
              applyScaleValueToDimension(area, yScale, { min: options.yMin, max: options.yMax, start: yScale.bottom, end: yScale.top, startProp: "y", endProp: "y2" });
            }
          }
          const { x, y, x2, y2 } = area;
          const inside = isLineInArea(area, chart.chartArea);
          const properties = inside ? limitLineToArea({ x, y }, { x: x2, y: y2 }, chart.chartArea) : { x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y) };
          properties.centerX = (x2 + x) / 2;
          properties.centerY = (y2 + y) / 2;
          const labelProperties = resolveLabelElementProperties(chart, properties, options.label);
          labelProperties._visible = inside;
          properties.elements = [{
            type: "label",
            optionScope: "label",
            properties: labelProperties
          }];
          return properties;
        }
      };
      LineAnnotation.id = "lineAnnotation";
      arrowHeadsDefaults = {
        backgroundColor: void 0,
        backgroundShadowColor: void 0,
        borderColor: void 0,
        borderDash: void 0,
        borderDashOffset: void 0,
        borderShadowColor: void 0,
        borderWidth: void 0,
        display: void 0,
        fill: void 0,
        length: void 0,
        shadowBlur: void 0,
        shadowOffsetX: void 0,
        shadowOffsetY: void 0,
        width: void 0
      };
      LineAnnotation.defaults = {
        adjustScaleRange: true,
        arrowHeads: {
          display: false,
          end: Object.assign({}, arrowHeadsDefaults),
          fill: false,
          length: 12,
          start: Object.assign({}, arrowHeadsDefaults),
          width: 6
        },
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 2,
        display: true,
        endValue: void 0,
        label: {
          backgroundColor: "rgba(0,0,0,0.8)",
          backgroundShadowColor: "transparent",
          borderCapStyle: "butt",
          borderColor: "black",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderRadius: 6,
          borderShadowColor: "transparent",
          borderWidth: 0,
          callout: Object.assign({}, LabelAnnotation.defaults.callout),
          color: "#fff",
          content: null,
          display: false,
          drawTime: void 0,
          font: {
            family: void 0,
            lineHeight: void 0,
            size: void 0,
            style: void 0,
            weight: "bold"
          },
          height: void 0,
          padding: 6,
          position: "center",
          rotation: 0,
          shadowBlur: 0,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          textAlign: "center",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          width: void 0,
          xAdjust: 0,
          yAdjust: 0,
          z: void 0
        },
        scaleID: void 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        value: void 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      LineAnnotation.descriptors = {
        arrowHeads: {
          start: {
            _fallback: true
          },
          end: {
            _fallback: true
          },
          _fallback: true
        }
      };
      LineAnnotation.defaultRoutes = {
        borderColor: "color"
      };
      EllipseAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          const rotation = this.options.rotation;
          const borderWidth = this.options.borderWidth;
          if (axis !== "x" && axis !== "y") {
            return pointInEllipse({ x: mouseX, y: mouseY }, this.getProps(["width", "height", "centerX", "centerY"], useFinalPosition), rotation, borderWidth);
          }
          const { x, y, x2, y2 } = this.getProps(["x", "y", "x2", "y2"], useFinalPosition);
          const hBorderWidth = borderWidth / 2;
          const limit = axis === "y" ? { start: y, end: y2 } : { start: x, end: x2 };
          const rotatedPoint = rotated2({ x: mouseX, y: mouseY }, this.getCenterPoint(useFinalPosition), toRadians(-rotation));
          return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON2 && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON2;
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          const { width, height, centerX, centerY, options } = this;
          ctx.save();
          translate(ctx, this.getCenterPoint(), options.rotation);
          setShadowStyle(ctx, this.options);
          ctx.beginPath();
          ctx.fillStyle = options.backgroundColor;
          const stroke = setBorderStyle(ctx, options);
          ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);
          ctx.fill();
          if (stroke) {
            ctx.shadowColor = options.borderShadowColor;
            ctx.stroke();
          }
          ctx.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(chart, options) {
          return resolveBoxAndLabelProperties(chart, options);
        }
      };
      EllipseAnnotation.id = "ellipseAnnotation";
      EllipseAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        label: Object.assign({}, BoxAnnotation.defaults.label),
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      EllipseAnnotation.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      EllipseAnnotation.descriptors = {
        label: {
          _fallback: true
        }
      };
      PointAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          const { x, y, x2, y2, width } = this.getProps(["x", "y", "x2", "y2", "width"], useFinalPosition);
          const borderWidth = this.options.borderWidth;
          if (axis !== "x" && axis !== "y") {
            return inPointRange({ x: mouseX, y: mouseY }, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);
          }
          const hBorderWidth = borderWidth / 2;
          const limit = axis === "y" ? { start: y, end: y2, value: mouseY } : { start: x, end: x2, value: mouseX };
          return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          const options = this.options;
          const borderWidth = options.borderWidth;
          if (options.radius < 0.1) {
            return;
          }
          ctx.save();
          ctx.fillStyle = options.backgroundColor;
          setShadowStyle(ctx, options);
          const stroke = setBorderStyle(ctx, options);
          options.borderWidth = 0;
          drawPoint(ctx, options, this.centerX, this.centerY);
          if (stroke && !isImageOrCanvas(options.pointStyle)) {
            ctx.shadowColor = options.borderShadowColor;
            ctx.stroke();
          }
          ctx.restore();
          options.borderWidth = borderWidth;
        }
        resolveElementProperties(chart, options) {
          return resolvePointProperties(chart, options);
        }
      };
      PointAnnotation.id = "pointAnnotation";
      PointAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        pointStyle: "circle",
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      PointAnnotation.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      PolygonAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
          if (axis !== "x" && axis !== "y") {
            return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);
          }
          const rotatedPoint = rotated2({ x: mouseX, y: mouseY }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));
          const axisPoints = this.elements.map((point) => axis === "y" ? point.bY : point.bX);
          const start = Math.min(...axisPoints);
          const end = Math.max(...axisPoints);
          return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;
        }
        getCenterPoint(useFinalPosition) {
          return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
          const { elements, options } = this;
          ctx.save();
          ctx.beginPath();
          ctx.fillStyle = options.backgroundColor;
          setShadowStyle(ctx, options);
          const stroke = setBorderStyle(ctx, options);
          let first = true;
          for (const el of elements) {
            if (first) {
              ctx.moveTo(el.x, el.y);
              first = false;
            } else {
              ctx.lineTo(el.x, el.y);
            }
          }
          ctx.closePath();
          ctx.fill();
          if (stroke) {
            ctx.shadowColor = options.borderShadowColor;
            ctx.stroke();
          }
          ctx.restore();
        }
        resolveElementProperties(chart, options) {
          const properties = resolvePointProperties(chart, options);
          const { x, y } = properties;
          const { sides, rotation } = options;
          const elements = [];
          const angle = 2 * PI / sides;
          let rad = rotation * RAD_PER_DEG;
          for (let i2 = 0; i2 < sides; i2++, rad += angle) {
            elements.push(buildPointElement(properties, options, rad));
          }
          properties.elements = elements;
          properties.initProperties = { x, y };
          return properties;
        }
      };
      PolygonAnnotation.id = "polygonAnnotation";
      PolygonAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        point: {
          radius: 0
        },
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        sides: 3,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      PolygonAnnotation.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      annotationTypes = {
        box: BoxAnnotation,
        ellipse: EllipseAnnotation,
        label: LabelAnnotation,
        line: LineAnnotation,
        point: PointAnnotation,
        polygon: PolygonAnnotation
      };
      Object.keys(annotationTypes).forEach((key) => {
        defaults.describe(`elements.${annotationTypes[key].id}`, {
          _fallback: "plugins.annotation.common"
        });
      });
      directUpdater = {
        update: Object.assign
      };
      version2 = "2.1.1";
      chartStates = /* @__PURE__ */ new Map();
      annotation = {
        id: "annotation",
        version: version2,
        beforeRegister() {
          requireVersion("chart.js", "3.7", Chart.version);
        },
        afterRegister() {
          Chart.register(annotationTypes);
        },
        afterUnregister() {
          Chart.unregister(annotationTypes);
        },
        beforeInit(chart) {
          chartStates.set(chart, {
            annotations: [],
            elements: [],
            visibleElements: [],
            listeners: {},
            listened: false,
            moveListened: false,
            hovered: []
          });
        },
        beforeUpdate(chart, args, options) {
          const state = chartStates.get(chart);
          const annotations = state.annotations = [];
          let annotationOptions = options.annotations;
          if (isObject(annotationOptions)) {
            Object.keys(annotationOptions).forEach((key) => {
              const value2 = annotationOptions[key];
              if (isObject(value2)) {
                value2.id = key;
                annotations.push(value2);
              }
            });
          } else if (isArray(annotationOptions)) {
            annotations.push(...annotationOptions);
          }
          verifyScaleOptions(annotations, chart.scales);
        },
        afterDataLimits(chart, args) {
          const state = chartStates.get(chart);
          adjustScaleRange(chart, args.scale, state.annotations.filter((a) => a.display && a.adjustScaleRange));
        },
        afterUpdate(chart, args, options) {
          const state = chartStates.get(chart);
          updateListeners(chart, state, options);
          updateElements(chart, state, options, args.mode);
          state.visibleElements = state.elements.filter((el) => !el.skip && el.options.display);
        },
        beforeDatasetsDraw(chart, _args, options) {
          draw2(chart, "beforeDatasetsDraw", options.clip);
        },
        afterDatasetsDraw(chart, _args, options) {
          draw2(chart, "afterDatasetsDraw", options.clip);
        },
        beforeDraw(chart, _args, options) {
          draw2(chart, "beforeDraw", options.clip);
        },
        afterDraw(chart, _args, options) {
          draw2(chart, "afterDraw", options.clip);
        },
        beforeEvent(chart, args, options) {
          const state = chartStates.get(chart);
          if (handleEvent(state, args.event, options)) {
            args.changed = true;
          }
        },
        afterDestroy(chart) {
          chartStates.delete(chart);
        },
        _getState(chart) {
          return chartStates.get(chart);
        },
        defaults: {
          animations: {
            numbers: {
              properties: ["x", "y", "x2", "y2", "width", "height", "centerX", "centerY", "pointX", "pointY", "radius"],
              type: "number"
            }
          },
          clip: true,
          interaction: {
            mode: void 0,
            axis: void 0,
            intersect: void 0
          },
          common: {
            drawTime: "afterDatasetsDraw",
            label: {}
          }
        },
        descriptors: {
          _indexable: false,
          _scriptable: (prop) => !hooks.includes(prop),
          annotations: {
            _allKeys: false,
            _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`
          },
          interaction: {
            _fallback: true
          },
          common: {
            label: {
              _fallback: true
            }
          }
        },
        additionalOptionScopes: [""]
      };
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/SerpVisualizer/index.js
  var useEffect24, useState19, HandleFetch6, HandleResponse7, Libs23, Utilities13, ComposeComponents28, Empty2, Popover2, isExistDomain, SerpVisualizer, SerpVisualizer_default;
  var init_SerpVisualizer = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/SerpVisualizer/index.js"() {
      init_chart();
      init_chartjs_plugin_datalabels_esm();
      init_dist();
      init_chartjs_plugin_annotation_esm();
      ({ useEffect: useEffect24, useState: useState19 } = window.React);
      ({ HandleFetch: HandleFetch6, HandleResponse: HandleResponse7 } = window.getGenie.Components.Common.RequestManager);
      ({ Libs: Libs23, Utilities: Utilities13 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents28 } = window.getGenie.Components.Common.ReduxManager);
      ({ Empty: Empty2, Popover: Popover2 } = window.antd);
      ({ isExistDomain } = Utilities13.GenieHelpers);
      Chart.register(
        CategoryScale,
        LinearScale,
        BarElement,
        plugin_title,
        plugin_tooltip,
        plugin_legend,
        plugin,
        annotation
      );
      SerpVisualizer = ComposeComponents28(({ setSidebar, sidebar: sidebar4, getInputs }) => {
        const [currentTab, setCurrentTab] = useState19({ name: "Word count", dataName: "words", activeTabIndex: 0 });
        const competitorData2 = (getInputs["competitorData"] || []).filter((data2) => !isExistDomain(data2?.url)).slice(0, 10);
        const visible = getInputs["serpVisualize"];
        const allStat = {
          words: [],
          headings: [],
          images: [],
          internalLinks: [],
          externalLinks: []
        };
        for (const data2 of competitorData2) {
          for (const [key, value2] of Object.entries(data2?.stat || {})) {
            if (!allStat[key]) {
              continue;
            }
            allStat[key].push(value2);
          }
        }
        const [data, setData] = useState19([]);
        useEffect24(() => {
          const newData = allStat[currentTab.dataName];
          setData(newData);
        }, [currentTab]);
        let averageNum = 0, minimumValue = 0, maximumValue = 0;
        if (data.length > 0) {
          averageNum = data?.reduce((prev2, acu) => prev2 + acu, 0);
          averageNum = Math.ceil(averageNum / data?.length);
          minimumValue = data?.reduce((prev2, acu) => Math.min(prev2, acu));
          maximumValue = data?.reduce((prev2, acu) => Math.max(prev2, acu), 0);
        }
        const getAverageNum = (ctx) => {
          const values = ctx.chart.data.datasets[0].data;
          const averageValue = values.reduce((a, b) => a + b, 0) / values.length;
          return averageValue;
        };
        const serpTabs = [
          { name: "word count", dataName: "words" },
          { name: "headings", dataName: "headings" },
          { name: "images", dataName: "images" },
          { name: "internal links", dataName: "internalLinks" },
          { name: "external links", dataName: "externalLinks" }
        ];
        const handleTabChange = (currentTab2, activeTabIndex) => {
          setCurrentTab({ ...currentTab2, activeTabIndex });
        };
        const options = {
          responsive: true,
          layout: {
            padding: {
              top: 25,
              right: 0,
              left: 0,
              bottom: 0
            }
          },
          plugins: {
            datalabels: {
              display: false,
              color: "#97ACFF",
              align: "end",
              rotation: 270,
              anchor: "end",
              font: { size: "10" },
              formatter: function(value2) {
                if (value2 < 1e3)
                  return value2;
                if (value2 >= 1e3 && value2 < 1e6)
                  return +(value2 / 1e3).toFixed(1) + "K";
                if (value2 >= 1e6 && value2 < 1e9)
                  return +(value2 / 1e6).toFixed(1) + "M";
                if (value2 >= 1e9 && value2 < 1e12)
                  return +(value2 / 1e9).toFixed(1) + "B";
                if (value2 >= 1e12)
                  return +(value2 / 1e12).toFixed(1) + "T";
              }
            },
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              rtl: false,
              backgroundColor: "#031233",
              callback: {}
            },
            annotation: {
              annotations: {
                line1: {
                  type: "line",
                  borderColor: "#14A645",
                  borderDash: [4, 4],
                  borderDashOffset: 0,
                  borderWidth: 1,
                  scaleID: "y",
                  value: (ctx) => getAverageNum(ctx)
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                display: true
              },
              ticks: {
                callback: function(value2, index2, ticks) {
                  return (competitorData2[index2]?.keySlug || "").replace(/www.|\.[^.]+$/gm, "");
                }
              }
            },
            y: {
              grid: {
                borderWidth: 0
              },
              ticks: {
                callback: function(value2) {
                  if (value2 < 1e3)
                    return value2;
                  if (value2 >= 1e3 && value2 < 1e6)
                    return +(value2 / 1e3).toFixed(1) + "K";
                  if (value2 >= 1e6 && value2 < 1e9)
                    return +(value2 / 1e6).toFixed(1) + "M";
                  if (value2 >= 1e9 && value2 < 1e12)
                    return +(value2 / 1e9).toFixed(1) + "B";
                  if (value2 >= 1e12)
                    return +(value2 / 1e12).toFixed(1) + "T";
                }
              }
            }
          }
        };
        const labels = data.map((item) => item);
        const chartData = {
          labels,
          datasets: [
            {
              label: sidebar4.__("Content", "getgenie"),
              data: data.map((item) => item),
              backgroundColor: "#97ACFF",
              barPercentage: 0.2,
              borderRadius: 10
            }
          ]
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-serp-visualization"
        }, /* @__PURE__ */ React.createElement(Popover2, {
          content: /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-serpVisualization-container"
          }, /* @__PURE__ */ React.createElement("h5", {
            className: "serpVisualization-header"
          }, "SERP Visualizer"), /* @__PURE__ */ React.createElement("h6", {
            className: "serpVisualization-sub-header"
          }, "Metrics"), /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-serpVisualization-tab-container"
          }, serpTabs.map((tab, index2) => /* @__PURE__ */ React.createElement("p", {
            key: index2,
            className: `tab-name ${currentTab.activeTabIndex === index2 ? "active-tab" : ""}`,
            onClick: () => handleTabChange(tab, index2)
          }, tab.name))), data?.length === 0 || data?.every((item) => item == 0) ? /* @__PURE__ */ React.createElement(Empty2, {
            description: sidebar4.__(`No data found.`, "getgenie"),
            className: "getgenie-chart empty"
          }) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
            className: "visualization-data-highlights"
          }, /* @__PURE__ */ React.createElement("p", null, " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-name average-data"
          }, "Average : "), " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-count"
          }, averageNum), " "), /* @__PURE__ */ React.createElement("p", null, " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-name"
          }, "Min : "), " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-count"
          }, minimumValue), " "), /* @__PURE__ */ React.createElement("p", null, " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-name"
          }, "Max : "), " ", /* @__PURE__ */ React.createElement("span", {
            className: "data-count"
          }, maximumValue), " ")), /* @__PURE__ */ React.createElement(Bar, {
            options,
            data: chartData
          }))),
          overlayClassName: "getgenie-serpVisualization-popover",
          overlayStyle: {
            width: "700px",
            height: "494px"
          },
          placement: "left",
          visible,
          zIndex: 9999
        }));
      }, ["setSidebar", "sidebar", "getInputs"]);
      SerpVisualizer_default = SerpVisualizer;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/Competitor/index.js
  var Libs24, Col6, Divider6, Row6, ComposeComponents29, useEffect25, ScoreAnalysisCompetitor, Competitor_default;
  var init_Competitor2 = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/Competitor/index.js"() {
      init_Competitor();
      init_SerpVisualizer();
      ({ Libs: Libs24 } = window.getGenie.Components.Common);
      ({ Col: Col6, Divider: Divider6, Row: Row6 } = window.antd);
      ({ ComposeComponents: ComposeComponents29 } = window.getGenie.Components.Common.ReduxManager);
      ({ useEffect: useEffect25 } = window.React);
      ScoreAnalysisCompetitor = ComposeComponents29(
        ({ getInputs, setInput, setSidebar, sidebar: sidebar4 }) => {
          const headToHead = getInputs["headTohead"] || false;
          const serpVisualize = getInputs["serpVisualize"] || false;
          useEffect25(() => {
            if (getInputs["serpVisualize"]) {
              setInput("headTohead", false);
            }
          }, [getInputs["serpVisualize"]]);
          useEffect25(() => {
            if (getInputs["headTohead"]) {
              setInput("serpVisualize", false);
            }
          }, [getInputs["headTohead"]]);
          return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-scoreanalysis-competitor-screen"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-headtohead"
          }, /* @__PURE__ */ React.createElement(Row6, {
            justify: "space-between",
            align: "middle"
          }, /* @__PURE__ */ React.createElement(Col6, {
            order: 2,
            span: 10,
            className: "comparison-switch"
          }, /* @__PURE__ */ React.createElement(Libs24.Switch, {
            label: "SERP Visualizer",
            defaultChecked: serpVisualize,
            name: "serpVisualize"
          })), /* @__PURE__ */ React.createElement(Col6, {
            order: 1,
            span: 10,
            className: "comparison-switch"
          }, /* @__PURE__ */ React.createElement(Libs24.Switch, {
            className: "h2h-comparison",
            label: "H2H Comparison",
            defaultChecked: headToHead,
            name: "headTohead"
          })))), /* @__PURE__ */ React.createElement(SerpVisualizer_default, null), /* @__PURE__ */ React.createElement(Divider6, {
            className: "genie-divider"
          }), /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-statistics-container"
          }, /* @__PURE__ */ React.createElement(Competitor, {
            data: getInputs["competitorData"]
          }))));
        },
        ["sidebar", "getInputs", "setInput", "setSidebar"]
      );
      Competitor_default = ScoreAnalysisCompetitor;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/KeywordHeatMap/index.js
  var ComposeComponents30, Libs25, useState20, useEffect26, KeywordHeatMap;
  var init_KeywordHeatMap = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/KeywordHeatMap/index.js"() {
      init_Utilities();
      ({ ComposeComponents: ComposeComponents30 } = window.getGenie.Components.Common.ReduxManager);
      ({ Libs: Libs25 } = window.getGenie.Components.Common);
      ({ useState: useState20, useEffect: useEffect26 } = window.React);
      KeywordHeatMap = ComposeComponents30(
        ({ sidebar: sidebar4, visible, width, limitUsage: limitUsage2 }) => {
          const [headToHeadData, setHeadToHeadData] = useState20({});
          useEffect26(() => {
            setHeadToHeadData(sidebar4.competitorStats?.headToHeadData || {});
          }, [sidebar4.competitorStats]);
          const getKeywordUsageInfo = (usage, rec) => {
            if (usage == 0 || !rec || rec?.length < 2) {
              return "";
            }
            if (usage >= rec[0] && usage <= parseInt(rec[1])) {
              return "heatmap-green";
            }
            if (usage >= parseInt(rec[1])) {
              return "heatmap-red";
            }
            if (usage < rec[0]) {
              return "heatmap-yellow";
            }
          };
          const isValidUrl = (urlString) => {
            var regex = /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/;
            if (regex.test(urlString)) {
              return true;
            }
            return false;
          };
          let header = "";
          let body = "";
          if (Object.keys(headToHeadData).length > 0) {
            var keyPhraseColumn = "";
            var keyPhraseColumnPrinted = false;
            header += `<div class="header-statistic">
        <div><p>Google Rank:</p></div></div>`;
            for (const [domainKey, domainData] of Object.entries(headToHeadData.serpDomains)) {
              header += `<div class="domain-content statistic statistic-url domain-content-url ${domainKey == "myContent_0" ? "my_content_el" : ``}">
      <div class="url-text">
      `;
              header += `<span class='text-content'>
        ${domainData?.rank !== 0 ? isValidUrl(domainData?.favicon) ? `<img class="favicon" src="${domainData?.favicon}" />` : `<span class="getgenie-icon-earth favicon"></span>` : ""}
        ${domainData?.rank == 0 ? "My Content" : (domainData?.url || "").replace(/http(s)?(:)?(\/\/)?|(\/\/)?(www\.)?/g, "")}
        </span></div>${domainData?.rank == 0 ? `<span class="google-rank"> 
              <img src="${window.getGenie.config.assetsUrl}dist/admin/images/myContent.svg" />
            </span>` : `<span class="google-rank">${domainData?.rank}</span>`}
        </div>`;
              if (domainData.rank < 4) {
                var statisticColumn = '<div  class="statistic statistic-heatmap-col">';
              } else {
                var statisticColumn = '<div class="statistic statistic-heatmap-col blur-element">';
              }
              for (const [key, statistic] of Object.entries(headToHeadData.statistics)) {
                if (keyPhraseColumnPrinted === false) {
                  keyPhraseColumn += '<div style="display: flex;">';
                  keyPhraseColumn += `<div class="keyPhrase"> <span class="getgenie-icon-copy"></span> 
          <p class="keyPhrase-keyword">${statistic?.keyPhrase}</p> 
          <p class="getgenie-custom-tooltip"></p> 
          <p class="getgenie-hover-tooltip"></p>
          </div>`;
                  keyPhraseColumn += '<div class="keyword-recommendation">' + (statistic?.recommendation || []).join("-") + '<span class="getgenie-hover-tooltip">Ideal range of keyword count</span></div> </div>';
                }
                statisticColumn += `<div class="statisticData ${getKeywordUsageInfo(
                  statistic?.heatMap[domainKey]?.matchedKeyPhrase || 0,
                  statistic?.recommendation
                )}">${statistic?.heatMap[domainKey]?.matchedKeyPhrase || 0}</div>`;
              }
              statisticColumn += "</div>";
              if (keyPhraseColumnPrinted === false) {
                body += '<div class="statistic">' + keyPhraseColumn + "</div>";
                keyPhraseColumnPrinted = true;
              }
              body += statisticColumn;
            }
          }
          const handleClickToCopy = (keyPhraseContainer, keyword, tooltip, hoverTooltip) => {
            keyPhraseContainer.forEach((container, index2) => {
              let hoverTooltipElement = hoverTooltip[index2];
              const element = keyword[index2];
              if (element) {
                const isOverflowed = element.scrollWidth > element.clientWidth;
                if (isOverflowed) {
                  hoverTooltipElement = hoverTooltip[index2];
                } else {
                  hoverTooltip[index2].classList.add("d-none");
                }
              }
              let val = element?.innerText;
              let copyAbleText = "";
              if (typeof val === "string") {
                copyAbleText = val.replace(/<br\s*[\/]?>/g, "\n");
              } else if (Array.isArray(val)) {
                let newVal = val.join(",");
                copyAbleText = newVal.replace(/<br\s*[\/]?>/g, "\n");
              }
              hoverTooltipElement.innerText = copyAbleText;
              container.addEventListener("click", () => {
                const tooltipElement = tooltip[index2];
                tooltipElement.style.display = "block";
                tooltipElement.innerText = "Copied";
                setTimeout(() => {
                  tooltipElement.style.display = "none";
                  tooltipElement.innerText = "";
                }, 1500);
                GenieHelpers.copyToClipboard(copyAbleText).then(() => {
                }).catch(() => console.log("error"));
              });
            });
          };
          useEffect26(() => {
            const appRoot = document.getElementById("getgenie-container");
            const rect = appRoot.shadowRoot?.querySelector(".keyword-heatmap-wrapper");
            var observer = new MutationObserver(function(mutations, observer2) {
              for (let mutation of mutations) {
                if (mutation.target.className.includes("keyword-heatmap-wrapper") === true) {
                  const keyPhraseContainer = appRoot.shadowRoot.querySelectorAll(".keyPhrase");
                  const keyPhrase = appRoot.shadowRoot.querySelectorAll(".keyPhrase .keyPhrase-keyword");
                  const tooltip = appRoot.shadowRoot.querySelectorAll(".keyPhrase .getgenie-custom-tooltip");
                  const hoverTooltip = appRoot.shadowRoot.querySelectorAll(".keyPhrase .getgenie-hover-tooltip");
                  {
                  }
                  handleClickToCopy(keyPhraseContainer, keyPhrase, tooltip, hoverTooltip);
                }
              }
            });
            observer.observe(rect, {
              subtree: true,
              attributes: true,
              childList: true
            });
          }, [headToHeadData]);
          return /* @__PURE__ */ React.createElement("div", {
            className: `keyword-heatmap-wrapper ${visible ? "" : "d-none"}`,
            style: { width: `${width}px` }
          }, /* @__PURE__ */ React.createElement(Libs25.BlurElement, {
            top: 730,
            show: limitUsage2.subscription_type !== "pro",
            text: "Reveal NLP keywords, optimize, and rank better.",
            btnText: "Upgrade and optimize now",
            href: "https://getgenie.ai/pricing/",
            textMargin: 0
          }, /* @__PURE__ */ React.createElement("div", {
            id: "header",
            dangerouslySetInnerHTML: { __html: header }
          }), /* @__PURE__ */ React.createElement("div", {
            id: "body",
            dangerouslySetInnerHTML: { __html: body }
          })));
        },
        ["sidebar", "limitUsage"]
      );
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/Plagiarism/index.js
  var useEffect27, useState21, HandleFetch7, HandleResponse8, Libs26, Utilities14, ComposeComponents31, Collapse, Button11, Panel, Plagiarism, Plagiarism_default;
  var init_Plagiarism = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/Plagiarism/index.js"() {
      ({ useEffect: useEffect27, useState: useState21 } = window.React);
      ({ HandleFetch: HandleFetch7, HandleResponse: HandleResponse8 } = window.getGenie.Components.Common.RequestManager);
      ({ Libs: Libs26, Utilities: Utilities14 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents31 } = window.getGenie.Components.Common.ReduxManager);
      ({ Collapse, Button: Button11 } = window.antd);
      ({ Panel } = Collapse);
      Plagiarism = ComposeComponents31(({ setSidebar, sidebar: sidebar4 }) => {
        let PlagiarismCheckData = window.getGenie.blogWizardData.plagiarismStat?.plagiarismData;
        const [plagiarismData2, setPlagiarismData] = useState21(PlagiarismCheckData || []);
        const [isLoading, setIsLoading] = useState21(false);
        const [check, setCheck] = useState21(false);
        useEffect27(() => {
          window.getGenie.blogWizardData.PlagiarismStat = { plagiarismData: plagiarismData2 };
          Utilities14.GenieHelpers.callStoreApi("plagiarismStat", {
            plagiarismData: plagiarismData2
          });
        }, [plagiarismData2]);
        const fetchPlagiarismData = () => {
          let textContent = sidebar4.currentPostContent;
          textContent = textContent.replace(/<\/?[^>]+(>|$)/g, "");
          textContent = textContent.split(/\r?\n/).filter((line) => line.trim() !== "").join("\n");
          setIsLoading(true);
          setCheck(false);
          HandleFetch7((res) => {
            setIsLoading(false);
            HandleResponse8(res, () => {
              const response = res.data?.result || [];
              setPlagiarismData(response);
              if (response.length === 0) {
                setCheck(true);
                return;
              }
            });
          }, "plagiarismData", { input: { textContent } });
        };
        return /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-Plagiarism"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-Plagiarism-container"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-Plagiarism-container-child"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-Plagiarism-data-fetchBtn"
        }, isLoading ? /* @__PURE__ */ React.createElement("h5", {
          className: "getgenie-loading-state"
        }, /* @__PURE__ */ React.createElement("span", null, "Scanning your content"), /* @__PURE__ */ React.createElement(Libs26.Loading, {
          size: 25
        }), " ") : /* @__PURE__ */ React.createElement(Button11, {
          className: "getgenie-fetch-competitor-btn",
          onClick: fetchPlagiarismData
        }, sidebar4.__("Check Plagiarism", "getgenie"))), isLoading && [...Array(5).keys()].map((_, index2) => /* @__PURE__ */ React.createElement(Libs26.SkeletonCard, {
          count: 1,
          key: index2
        })), plagiarismData2.length > 0 && /* @__PURE__ */ React.createElement(Collapse, {
          expandIconPosition: "right",
          accordion: true,
          expandIcon: () => /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-arrow_down"
          })
        }, plagiarismData2.map((content, index2) => /* @__PURE__ */ React.createElement(Panel, {
          header: /* @__PURE__ */ React.createElement("h5", {
            className: "getgenie-Plagiarism-accordian-heading"
          }, content.title),
          key: index2
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-Plagiarism-link-container"
        }, /* @__PURE__ */ React.createElement("p", null, /* @__PURE__ */ React.createElement("span", null, `${content.minwordsmatched}+`), " Words Matched"), /* @__PURE__ */ React.createElement("a", {
          href: content.viewurl,
          className: "getgenie-Plagiarism-link",
          target: "_blank"
        }, /* @__PURE__ */ React.createElement("span", null, "See Details"), /* @__PURE__ */ React.createElement("img", {
          src: sidebar4.imageUrl + "/new_tab.png",
          alt: ""
        }))), /* @__PURE__ */ React.createElement("p", {
          className: "getgenie-content-container"
        }, content.textsnippet)))), check && /* @__PURE__ */ React.createElement("p", {
          className: "getgenie-Plagiarism-notfound"
        }, "No match found!"))));
      }, ["setSidebar", "sidebar"]);
      Plagiarism_default = Plagiarism;
    }
  });

  // assets/src/admin/js/BlogWizard/ScoreAnalysis/index.js
  var Libs27, Utilities15, ComposeComponents32, Tabs, TabPane, useState22, useEffect28, ScoreAnalysis;
  var init_ScoreAnalysis = __esm({
    "assets/src/admin/js/BlogWizard/ScoreAnalysis/index.js"() {
      init_BlogAnalysis();
      init_Competitor2();
      init_KeywordHeatMap();
      init_Plagiarism();
      ({ Libs: Libs27, Utilities: Utilities15 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents32 } = window.getGenie.Components.Common.ReduxManager);
      ({ Tabs } = window.antd);
      ({ TabPane } = Tabs);
      ({ useState: useState22, useEffect: useEffect28 } = window.React);
      ScoreAnalysis = ComposeComponents32(({ setSidebar, sidebar: sidebar4, setInput }) => {
        const [activeKey, setActiveKey] = useState22("blogAnalysis");
        useEffect28(() => {
          setInput("headTohead", false);
          setInput("serpVisualize", false);
        }, [activeKey, sidebar4.open]);
        const handleActiveKey = (key) => {
          setActiveKey(key);
        };
        const tabPaneList = [
          {
            label: "Content Score",
            key: "blogAnalysis",
            children: /* @__PURE__ */ React.createElement(BlogAnalysis_default, null)
          },
          {
            label: "Competitor",
            key: "competitor",
            children: /* @__PURE__ */ React.createElement(Competitor_default, null)
          },
          {
            label: "Plagiarism",
            key: "plagiarism",
            children: /* @__PURE__ */ React.createElement(Plagiarism_default, null)
          }
        ];
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Libs27.DrawerHeader, null), /* @__PURE__ */ React.createElement(Libs27.Navbar, {
          tabPaneList,
          activeKey,
          handleActiveKey,
          className: "getgenie-statistics-navbar"
        }));
      }, ["setSidebar", "sidebar", "setInput"]);
    }
  });

  // assets/src/admin/js/BlogWizard/index.js
  var init_BlogWizard = __esm({
    "assets/src/admin/js/BlogWizard/index.js"() {
      init_AnalyzeKeywordScreen();
      init_SeoData();
      init_SidebarNav();
      init_WritingScreens();
      init_ScoreAnalysis();
      init_Utilities2();
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/WPEditorTopButtons.js
  var Button12, Tooltip10, Modal3, useEffect29, useState23, Libs28, ComposeComponents33, blogScreens, statScreens, chatScreens, historyScreens, WPEditorTopButtons, WPEditorTopButtons_default;
  var init_WPEditorTopButtons = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/WPEditorTopButtons.js"() {
      init_BlogWizard();
      ({ Button: Button12, Tooltip: Tooltip10, Modal: Modal3 } = window.antd);
      ({ useEffect: useEffect29, useState: useState23 } = window.React);
      ({ Libs: Libs28 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents33 } = window.getGenie.Components.Common.ReduxManager);
      blogScreens = ["BlogScreen"];
      statScreens = ["ScoreAnalysis"];
      chatScreens = ["GenieChat"];
      historyScreens = ["UserHistory", "UserHistoryDetails"];
      WPEditorTopButtons = ComposeComponents33(({ setSidebar, sidebar: sidebar4, getInputs, setInput, getTemplateInputs, setContextMenu }) => {
        const score = sidebar4.currentPostContent ? sidebar4.analyzedContent?.contentStats?.totalScore || 0 : 0;
        const [prevBlogScreen, setPrevBlogScreen] = useState23({});
        const [prevStatScreen, setPrevStatScreen] = useState23("");
        const [showTooltip, setShowTooltip] = useState23(false);
        let { component, currentTemplate } = sidebar4;
        useEffect29(() => {
          if (sidebar4.toolbarWriting) {
            return;
          }
          if ([...blogScreens, "WriteTemplatesScreen"].includes(component)) {
            let template = blogScreens.includes(component) ? "blogWizard" : sidebar4.currentTemplate;
            setPrevBlogScreen({
              component,
              template
            });
          } else if (statScreens.includes(component)) {
            setPrevStatScreen(component);
          }
        }, [sidebar4.component, sidebar4.currentTemplate]);
        useEffect29(() => {
          if (window.location.hash === "#getgenie-open-blogwizard") {
            handleClickWrite();
            setSidebar({
              component: "BlogScreen",
              currentTemplate: "blogWizard"
            });
          }
        }, []);
        const reFetchCompetitor = () => {
          setInput("competitorData", null);
          setInput("seoDataTab", "competitor");
          setSidebar({
            open: true,
            component: "BlogScreen",
            analyzeKeyword: {
              ...sidebar4.analyzeKeyword,
              open: true
            },
            statisticsScreen: {
              ...sidebar4.statisticsScreen,
              triggered: true
            }
          });
        };
        const handleClickWrite = () => {
          let open = !sidebar4.open;
          setInput("headTohead", false);
          setInput("serpVisualize", false);
          if ([...statScreens, ...historyScreens, ...chatScreens, "WriteTemplatesScreen"].includes(component)) {
            setSidebar({
              open: true,
              component: prevBlogScreen?.component || "TemplateListScreen",
              currentTemplate: prevBlogScreen?.template || sidebar4.currentTemplate
            });
            return;
          }
          setSidebar({
            open,
            component: component || "TemplateListScreen"
          });
          return;
        };
        const handleAnalyzeKeyword = () => {
          setSidebar({
            open: true,
            component: "BlogScreen",
            analyzeKeyword: {
              open: true,
              triggered: true
            }
          });
        };
        const handleClickStat = (updatedSidebar, allTemplateInputs) => {
          const { competitorData: competitorData2, keyword, searchVolume } = allTemplateInputs?.blogWizard || {};
          const isRequiredKeywordCompetitorData = !keyword && !competitorData2 && !searchVolume || keyword && !competitorData2 && !searchVolume;
          if (isRequiredKeywordCompetitorData) {
            Modal3.warning({
              title: "Score not generated",
              content: "Please Fetch keyword and competitor data for content score.",
              className: "getgenie-confirm-modal",
              getContainer: () => updatedSidebar.rootContainer,
              zIndex: 99999,
              maskClosable: true,
              ...keyword ? {
                okText: /* @__PURE__ */ React.createElement("div", null, "Analyze Keyword ", /* @__PURE__ */ React.createElement("span", {
                  className: "getgenie-icon-arrow-right fetch"
                })),
                onOk: handleAnalyzeKeyword
              } : {}
            });
            return;
          }
          if (updatedSidebar.analyzingCompetitors) {
            Modal3.warning({
              title: "Fetching competitors data to provide the updated content score.",
              className: "getgenie-confirm-modal",
              getContainer: () => updatedSidebar.rootContainer,
              zIndex: 99999,
              maskClosable: true
            });
            return;
          }
          if (Array.isArray(updatedSidebar.statisticsData?.keywords) || !competitorData2 && !updatedSidebar.analyzingCompetitors) {
            Modal3.warning({
              title: "The score will need some updating!",
              onOk: reFetchCompetitor,
              content: "Please click the button below and re- fetch the SERP competitor data to get updated content score for your content.",
              okText: /* @__PURE__ */ React.createElement("div", null, "Fetch ", /* @__PURE__ */ React.createElement("span", {
                className: "getgenie-icon-arrow-right fetch"
              })),
              className: "getgenie-confirm-modal",
              getContainer: () => updatedSidebar.rootContainer,
              zIndex: 99999,
              maskClosable: true
            });
            return;
          }
          if (window.rankMathEditor || window.YoastSEO) {
            let currentPostTitle;
            let currentPostDescription;
            if (window.rankMathEditor) {
              const rankMath = window.rankMathEditor?.assessor?.analyzer?.researcher?.paper?.args || {};
              currentPostTitle = rankMath.title;
              currentPostDescription = rankMath.description;
            } else {
              const yoastSEO = window.YoastSEO?.app?.callbacks?.getData() || {};
              currentPostTitle = yoastSEO.metaTitle;
              currentPostDescription = yoastSEO.snippetMeta;
            }
            setSidebar({
              currentPostTitle: currentPostTitle || "",
              currentPostDescription: currentPostDescription || "",
              currentPostContent: updatedSidebar.currentPostContent + " "
            });
          }
          let title = wp.data.select("core/editor")?.getEditedPostAttribute("title");
          if (title && !updatedSidebar.currentPostContent.includes(title)) {
            let currentPostContent = `<h1>${title}</h1>` + updatedSidebar.currentPostContent;
            setSidebar({
              currentPostContent
            });
          }
          if (!updatedSidebar.currentPostContent && competitorData2) {
            setShowTooltip(true);
            setTimeout(() => {
              setShowTooltip(false);
            }, 2e3);
          }
          if (Object.keys(updatedSidebar.statisticsData).length === 0 || !updatedSidebar.currentPostContent) {
            return false;
          }
          let sidebarOpen = !updatedSidebar.open;
          if (!statScreens.includes(component)) {
            sidebarOpen = true;
          }
          setSidebar({
            open: sidebarOpen,
            component: prevStatScreen || "ScoreAnalysis",
            currentTemplate: "blogWizard",
            analyzeKeyword: {
              ...updatedSidebar.analyzeKeyword,
              open: false
            },
            generatedOutlines: {
              ...updatedSidebar.generatedOutlines,
              open: false
            }
          });
        };
        const showGenieChat = (updatedSidebar) => {
          let open = component == "GenieChat" ? !updatedSidebar.open : true;
          setSidebar({
            open,
            component: "GenieChat",
            currentTemplate: "genieChat",
            analyzeKeyword: {
              ...updatedSidebar.analyzeKeyword,
              open: false
            },
            generatedOutlines: {
              ...updatedSidebar.generatedOutlines,
              open: false
            }
          });
        };
        const genieChat2 = `${window.getGenie.config.assetsUrl}dist/admin/images/genie-chat.svg`;
        return /* @__PURE__ */ React.createElement(React.Fragment, null, window.getGenie?.config?.isBlockEditor ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Button12, {
          onClick: handleClickWrite,
          type: "primary",
          icon: /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-edit ant-btn-icon"
          })
        }, sidebar4.__("Write for me", "getgenie")), /* @__PURE__ */ React.createElement(Button12, {
          onClick: () => showGenieChat(sidebar4),
          className: "genie-chat-opener-btn"
        }, /* @__PURE__ */ React.createElement("img", {
          src: genieChat2,
          alt: "genie-chat",
          width: "25"
        }), sidebar4.__("Chat", "getgenie"))) : "", /* @__PURE__ */ React.createElement(Tooltip10, {
          placement: "bottom",
          trigger: "click",
          getPopupContainer: (node) => window.getGenie.shadow || document.body,
          title: "No post content found!",
          visible: showTooltip
        }, /* @__PURE__ */ React.createElement(Button12, {
          onClick: () => handleClickStat(sidebar4, getTemplateInputs),
          style: { backgroundColor: Utilities_exports.ColorByStatScore(score || 0) },
          loading: sidebar4.statisticsScreen.loading,
          type: "primary",
          className: "getgenie-toolbar-write-btn stat"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "getgenie-icon-meter score ant-btn-icon"
        }), score, "/100")));
      }, ["setSidebar", "setInput", "sidebar", "getInputs", "getTemplateInputs", "setContextMenu"]);
      WPEditorTopButtons_default = WPEditorTopButtons;
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/ColorByStatScore.js
  var ColorByStatScore, ColorByStatScore_default;
  var init_ColorByStatScore = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/ColorByStatScore.js"() {
      ColorByStatScore = (score, recommendation = [], threshold = false, maxThreshold = false) => {
        let color2 = "#FF4131";
        if (threshold) {
          if (score < recommendation[0]) {
            color2 = "#F5B008";
          } else if (!maxThreshold && score >= recommendation[0]) {
            color2 = "#14A645";
          } else if (maxThreshold && score > recommendation[0] && score < recommendation[1]) {
            color2 = "#14A645";
          } else if (maxThreshold && score >= recommendation[1]) {
            color2 = "#F02F54";
          }
        } else {
          if (score > 25 && score <= 50) {
            color2 = "#FDC500";
          } else if (score > 50 && score < 80) {
            color2 = "#f5b008";
          } else if (score >= 80) {
            color2 = "#00B81D";
          }
        }
        return color2;
      };
      ColorByStatScore_default = ColorByStatScore;
    }
  });

  // assets/src/admin/js/BlogWizard/Utilities/index.js
  var Utilities_exports = {};
  __export(Utilities_exports, {
    ColorByStatScore: () => ColorByStatScore_default,
    ContentAnalysis: () => ContentAnalysis,
    KeywordFinder: () => KeywordFinder,
    WPEditorTopButtons: () => WPEditorTopButtons_default,
    WebSourceAnalysis: () => WebSourceAnalysis
  });
  var init_Utilities2 = __esm({
    "assets/src/admin/js/BlogWizard/Utilities/index.js"() {
      init_ContentAnalysis();
      init_WebSourceAnalysis();
      init_WPEditorTopButtons();
      init_ColorByStatScore();
      init_KeywordFinder();
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      (function() {
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function useSyncExternalStore$2(subscribe2, getSnapshot) {
          didWarnOld18Alpha || void 0 === React6.startTransition || (didWarnOld18Alpha = true, console.error(
            "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
          ));
          var value2 = getSnapshot();
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs2(value2, cachedValue) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          cachedValue = useState26({
            inst: { value: value2, getSnapshot }
          });
          var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
          useLayoutEffect2(
            function() {
              inst.value = value2;
              inst.getSnapshot = getSnapshot;
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            },
            [subscribe2, value2, getSnapshot]
          );
          useEffect34(
            function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              return subscribe2(function() {
                checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              });
            },
            [subscribe2]
          );
          useDebugValue(value2);
          return value2;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs2(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe2, getSnapshot) {
          return getSnapshot();
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React6 = require_react(), objectIs2 = "function" === typeof Object.is ? Object.is : is, useState26 = React6.useState, useEffect34 = React6.useEffect, useLayoutEffect2 = React6.useLayoutEffect, useDebugValue = React6.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
        exports.useSyncExternalStore = void 0 !== React6.useSyncExternalStore ? React6.useSyncExternalStore : shim;
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // assets/src/admin/js/Common/ToolbarIntegration/index.js
  var import_shim, ComposeComponents34, RenderElement, useRef3, useEffect30, subscribe, useToolbarElement, ToolbarIntegration, ToolbarIntegration_default;
  var init_ToolbarIntegration = __esm({
    "assets/src/admin/js/Common/ToolbarIntegration/index.js"() {
      import_shim = __toESM(require_shim());
      init_Utilities2();
      ({ ComposeComponents: ComposeComponents34 } = window.getGenie.Components.Common.ReduxManager);
      ({ RenderElement } = window.getGenie.Components.Common);
      ({ useRef: useRef3, useEffect: useEffect30 } = window.React);
      ({ subscribe } = wp.data);
      useToolbarElement = () => {
        return (0, import_shim.useSyncExternalStore)(
          (callback2) => {
            const unsubscribe = subscribe(callback2);
            return () => unsubscribe();
          },
          () => document.querySelector(".edit-post-header__toolbar, .editor-header__toolbar, .edit-site-header-edit-mode__start")
        );
      };
      ToolbarIntegration = ComposeComponents34(() => {
        const rootRef = useRef3(null);
        const topToolbarHeader = useToolbarElement();
        useEffect30(() => {
          if (!topToolbarHeader)
            return;
          let writingToolbarWrapper = document.getElementById("getgenie-editor-custom-toolbar");
          if (!writingToolbarWrapper) {
            writingToolbarWrapper = document.createElement("div");
            writingToolbarWrapper.id = "getgenie-editor-custom-toolbar";
            writingToolbarWrapper.className = "getgenie";
            topToolbarHeader.appendChild(writingToolbarWrapper);
          }
          if (!rootRef.current) {
            rootRef.current = writingToolbarWrapper;
            RenderElement(/* @__PURE__ */ React.createElement(WPEditorTopButtons_default, null), writingToolbarWrapper);
          }
          return () => rootRef.current = null;
        }, [topToolbarHeader]);
        return null;
      }, []);
      ToolbarIntegration_default = ToolbarIntegration;
    }
  });

  // assets/src/admin/js/Integrations/index.js
  var Integrations_exports = {};
  var RenderElement2, doAction, registerPlugin;
  var init_Integrations = __esm({
    "assets/src/admin/js/Integrations/index.js"() {
      init_Utilities2();
      init_ToolbarIntegration();
      ({ RenderElement: RenderElement2 } = window.getGenie.Components.Common);
      ({ doAction } = wp.hooks);
      ({ registerPlugin } = wp.plugins);
      registerPlugin("getgenie", {
        render: ToolbarIntegration_default
      });
      (function(window2) {
        window2.addEventListener("load", function() {
          let toolbar = document.querySelector("#getgenie-editor-custom-toolbar.classic");
          if (toolbar && window2.getGenie?.config?.wizardScreen === "post") {
            RenderElement2(/* @__PURE__ */ React.createElement(WPEditorTopButtons_default, null), toolbar);
          } else {
            console.warn("No toolbar is found.");
          }
          let adminbarInterval = 0;
          let adminbarLoadedInterval = setInterval(function() {
            adminbarInterval++;
            if (jQuery("#wp-admin-bar-getgenie-template-list").length === 1) {
              doAction("getgenie_adminbar_menu", "getgenie_hooks");
              doAction("getgenie_adminbar_chat", "getgenie_hooks");
              clearInterval(adminbarLoadedInterval);
            }
            if (adminbarInterval >= 30) {
              clearInterval(adminbarLoadedInterval);
            }
          }, 500);
          let woocommerceInterval = 0;
          let woocommerceLoadedInterval = setInterval(function() {
            woocommerceInterval++;
            if (jQuery(".woocommerce-layout__header-wrapper").length === 1 && window2.getGenie?.config?.wizardScreen) {
              jQuery('<div id="getgenie-editor-custom-toolbar" class="getgenie">').insertAfter(".woocommerce-layout__header-wrapper .woocommerce-layout__header-heading");
              doAction("getgenie_woocommerce_menu", "getgenie_hooks");
              clearInterval(woocommerceLoadedInterval);
            }
            if (woocommerceInterval >= 30) {
              clearInterval(woocommerceLoadedInterval);
            }
          }, 500);
          if (!jQuery("#getgenie-container").length) {
            jQuery("body").append('<div id="getgenie-container" class="getgenie getgenie-main-container"></div>');
          }
          ;
          doAction("getgenie-render-app", "getgenie_hooks");
          jQuery.fn.menu_current = function() {
            this.addClass("current").siblings().removeClass("current");
          };
          let $toplevel_page = jQuery(".toplevel_page_getgenie.wp-menu-open");
          $toplevel_page.addClass("wp-has-current-submenu wp-menu-open").removeClass("wp-not-current-submenu").find("a.menu-top").addClass("wp-has-current-submenu wp-menu-open").removeClass("wp-not-current-submenu").next().find("li").each(function(key, val) {
            const { hash, search } = window2.location;
            let menu_link = jQuery(val).children("a").attr("href");
            if (hash === "" && search.includes("?page=getgenie")) {
              $toplevel_page.find("ul > li.wp-first-item").menu_current();
              return false;
            } else if (menu_link && menu_link.includes(hash)) {
              jQuery(val).menu_current();
            }
          }).on("click", function() {
            jQuery(this).menu_current();
          });
        });
      })(window);
    }
  });

  // assets/src/admin/js/Common/MainContentSidebar/index.js
  var Libs29, Utilities16, ComposeComponents35, Sidebar, BlogWizardUtils, OutlineScreen2, ParagraphGenerator, AnalyzeKeywordScreen, KeywordHeatMap2, Col7, useEffect31, MainContentSidebar, MainContentSidebar_default;
  var init_MainContentSidebar = __esm({
    "assets/src/admin/js/Common/MainContentSidebar/index.js"() {
      init_KeywordFinder();
      init_CompetitorAnalyzer();
      init_Utilities();
      ({ Libs: Libs29, Utilities: Utilities16 } = window.getGenie.Components.Common);
      ({ ComposeComponents: ComposeComponents35 } = window.getGenie.Components.Common.ReduxManager);
      ({ Sidebar, BlogWizardUtils } = window.getGenie.Components);
      ({ OutlineScreen: OutlineScreen2, ParagraphGenerator, AnalyzeKeywordScreen, KeywordHeatMap: KeywordHeatMap2 } = Sidebar || {});
      ({ Col: Col7 } = window.antd);
      ({ useEffect: useEffect31 } = window.React);
      MainContentSidebar = ComposeComponents35(({ sidebar: sidebar4, setSidebar, setInput, getInputs }) => {
        let storage = window.getGenie.blogWizardData;
        const isPostEditor = window.getGenie.config.isBlockEditor || window.getGenie.config.wizardScreen === "post";
        const { open, generatedOutlines, analyzeKeyword, paragraphEditorScreen } = sidebar4;
        useEffect31(() => {
          if (sidebar4.open) {
            document.body.classList.add("genie-sidebar-open");
          } else {
            if (document.body.classList.contains("genie-sidebar-open")) {
              document.body.classList.remove("genie-sidebar-open");
            }
          }
          if (navigator?.platform === "Win32") {
            document.body.classList.add("genie-scrollbar-windows");
          }
        }, [sidebar4.open]);
        useEffect31(() => {
          if (!isPostEditor) {
            return;
          }
          let value2 = getInputs["seoEnabled"];
          if (value2) {
            if (getInputs["searchVolume"] && "BlogScreen" == sidebar4.component) {
              setSidebar({
                analyzeKeyword: {
                  ...sidebar4.analyzeKeyword,
                  open: true
                }
              });
            }
          } else {
            setSidebar({
              analyzeKeyword: {
                ...sidebar4.analyzeKeyword,
                open: false,
                loading: false
              }
            });
          }
        }, [getInputs["searchVolume"], getInputs["seoEnabled"], sidebar4.component]);
        useEffect31(() => {
          if (!isPostEditor) {
            return;
          }
          let currentPost = wp.data.select("core/editor")?.getEditedPostContent();
          if (currentPost) {
            const title = wp.data.select("core/editor")?.getEditedPostAttribute("title");
            if (title && !currentPost.includes(title)) {
              currentPost = `<h1>${title}</h1>` + currentPost;
            }
            setSidebar({
              currentPostContent: currentPost
            });
          }
          if (!storage || Object.values(storage).filter(Boolean).length < 2) {
            return;
          }
          setSidebar({
            component: "BlogScreen",
            currentTemplate: "blogWizard"
          });
          for (const [key, value2] of Object.entries(storage)) {
            if (!value2 || key == "post_id") {
              continue;
            }
            if (key === "keywordData") {
              if (value2 && Object.values(value2).length > 0) {
                for (const [childKey, childValue] of Object.entries(value2)) {
                  setInput(childKey, childValue);
                }
              }
            } else if (key === "serpData") {
              if (value2 && Object.values(value2).length > 0) {
                for (const [childKey, childValue] of Object.entries(value2)) {
                  if (childKey === "statisticsData") {
                    setSidebar({
                      statisticsData: childValue
                    });
                  } else {
                    setInput(childKey, childValue);
                  }
                }
              }
            } else {
              if (!JSON.parse(localStorage.getItem("getgenie-" + key))) {
                setInput(key, value2);
              }
            }
          }
          ;
        }, []);
        useEffect31(() => {
          if (!isPostEditor) {
            return;
          }
          const statisticsData = sidebar4.statisticsData, content = sidebar4.currentPostContent;
          if (Array.isArray(statisticsData?.keywords)) {
            return;
          }
          if (BlogWizardUtils && statisticsData) {
            let title = "", description = "";
            if (document.getElementsByClassName("block-editor__container")?.length > 0) {
              title = wp.data.select("core/editor")?.getEditedPostAttribute("title");
              description = wp.data.select("core/editor")?.getEditedPostAttribute("excerpt");
            } else if (document.getElementById("wp-content-editor-container")) {
              title = document.getElementById("title")?.value;
              description = document.getElementById("excerpt")?.value;
            }
            if (sidebar4.currentPostTitle) {
              title = sidebar4.currentPostTitle;
            }
            if (sidebar4.currentPostDescription) {
              description = sidebar4.currentPostDescription;
            }
            let contentObj = {
              content,
              url: location.origin,
              title,
              description
            };
            const analyzedContent = new BlogWizardUtils.ContentAnalysis(contentObj, statisticsData);
            let competitorStats = sidebar4.competitorStats;
            if (competitorStats?.headToHeadData?.statistics) {
              let finder = new KeywordFinder();
              for (const keyword of Object.keys(competitorStats?.headToHeadData?.statistics)) {
                let count = finder.findSingleMatch(content, keyword);
                if (!competitorStats.headToHeadData.statistics[keyword]?.heatMap?.["myContent_0"]) {
                  competitorStats.headToHeadData.statistics[keyword].heatMap["myContent_0"] = {
                    matchedKeyPhrase: 0
                  };
                }
                competitorStats.headToHeadData.statistics[keyword].heatMap["myContent_0"].matchedKeyPhrase = count;
              }
            }
            setSidebar({
              analyzedContent: analyzedContent.getStat(),
              competitorStats
            });
          }
        }, [sidebar4.statisticsData, sidebar4.currentPostContent]);
        useEffect31(() => {
          let open2 = sidebar4.component === "BlogScreen" && sidebar4.currentScreen === "paragraphScreen";
          setSidebar({
            paragraphEditorScreen: {
              ...sidebar4.paragraphEditorScreen,
              open: open2
            }
          });
        }, [sidebar4.component, sidebar4.currentScreen]);
        useEffect31(() => {
          (async () => {
            let competitorData2 = getInputs["competitorData"];
            if (!competitorData2 || !sidebar4.statisticsData || Object.values(sidebar4.statisticsData).length === 0) {
              return;
            }
            let mySite = {
              source: sidebar4.currentPostContent,
              url: location.hostname || "myContent.com",
              title: "myContent",
              keySlug: "myContent_0",
              rank: 0,
              favicon: "default"
            };
            let competitorAnalyzer = new CompetitorAnalyzer(BlogWizardUtils.ContentAnalysis, KeywordFinder);
            const filterCompetitorData = (competitorData2 || []).filter((data) => !GenieHelpers.isExistDomain(data?.url)).slice(0, 10);
            let competitorStats = await competitorAnalyzer.analyze([mySite, ...filterCompetitorData], sidebar4.statisticsData);
            setSidebar({
              competitorStats
            });
          })();
        }, [sidebar4.statisticsData, getInputs["competitorData"]]);
        let SidebarContent = Sidebar[sidebar4.component] || (() => "");
        const headToHead = getInputs["headTohead"] || false;
        const getWidth = (drawerWidth, width) => {
          const mainScreenWidth = drawerWidth - (analyzeKeyword.open ? width.analyzeKeywordScreen : 0) - (generatedOutlines.open ? width.generatedOutlines : 0) - (headToHead ? width.keywordHeatMap : 0) - (paragraphEditorScreen.open ? width.paragraphEditorScreen : 0);
          return mainScreenWidth >= width.main ? mainScreenWidth : width.main;
        };
        return /* @__PURE__ */ React.createElement(Libs29.DrawerWrapper, null, (drawerWidth, width) => /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-sidebar-content"
        }, /* @__PURE__ */ React.createElement(Col7, {
          className: "extended-panel"
        }, AnalyzeKeywordScreen && /* @__PURE__ */ React.createElement(AnalyzeKeywordScreen, {
          visible: sidebar4.open && analyzeKeyword.open,
          width: width.analyzeKeywordScreen
        }), OutlineScreen2 && /* @__PURE__ */ React.createElement(OutlineScreen2.GeneratedOutlines, {
          visible: sidebar4.open && generatedOutlines.open,
          width: width.generatedOutlines
        }), ParagraphGenerator && /* @__PURE__ */ React.createElement(ParagraphGenerator, {
          visible: sidebar4.open && paragraphEditorScreen.open,
          width: width.paragraphEditorScreen
        }), KeywordHeatMap2 && /* @__PURE__ */ React.createElement(KeywordHeatMap2, {
          visible: sidebar4.open && headToHead,
          width: width.keywordHeatMap
        })), /* @__PURE__ */ React.createElement(Col7, {
          className: "wizard-screen",
          style: { width: `${getWidth(drawerWidth, width)}px` }
        }, /* @__PURE__ */ React.createElement(SidebarContent, null))));
      }, ["sidebar", "setSidebar", "setInput", "getInputs"]);
      MainContentSidebar_default = MainContentSidebar;
    }
  });

  // assets/src/admin/js/AdvanceWriting/Callbacks.js
  var Callbacks, Callbacks_default;
  var init_Callbacks = __esm({
    "assets/src/admin/js/AdvanceWriting/Callbacks.js"() {
      Callbacks = {
        calculateEventPosition: (e, dependency) => {
          if (dependency === "viewport") {
            return e.target.getBoundingClientRect();
          }
          if (dependency === "body") {
            let getOffset = function(elem, type) {
              var offset = 0;
              do {
                if (!isNaN(elem?.["offset" + type])) {
                  offset += elem?.["offset" + type];
                }
              } while (elem = elem?.offsetParent);
              return offset;
            };
            let eventPosition = {
              "top": getOffset(e.target, "Top"),
              "left": getOffset(e.target, "Left"),
              "right": getOffset(e.target, "Right"),
              "bottom": getOffset(e.target, "Bottom"),
              "width": e.target.getBoundingClientRect().width,
              "height": e.target.getBoundingClientRect().height
            };
            return eventPosition;
          }
        },
        insertContextMenu: (buttonEvent) => {
          let open = !wp.data.select("getgenie").contextMenu().open;
          wp.data.dispatch("getgenie").setContextMenu({
            open,
            buttonEvent
          });
        },
        showSidebar: (template) => {
          let context2 = wp.data.select("getgenie").sidebar().existingInputValue || "";
          let component = "WriteTemplatesScreen";
          let currentTemplate = template.slug;
          if (currentTemplate === "list") {
            component = "TemplateListScreen";
          }
          wp.data.dispatch("getgenie").setContextMenu({
            open: false
          });
          wp.data.dispatch("getgenie").setSidebar({
            open: true,
            currentWritingMode: template?.mode,
            component,
            currentTemplate,
            existingInputValue: context2.replace(/<br\s*[\/]?>/g, "")
          });
        }
      };
      Callbacks_default = Callbacks;
    }
  });

  // assets/src/admin/js/AdvanceWriting/ContextMenu/index.js
  var Row7, Col8, List, ComposeComponents36, hamburger, closeBtn, GenieLogo, useState24, useEffect32, additionalMenuItems, ContextMenu, ContextMenu_default;
  var init_ContextMenu = __esm({
    "assets/src/admin/js/AdvanceWriting/ContextMenu/index.js"() {
      init_Callbacks();
      ({ Row: Row7, Col: Col8, List } = window.antd);
      ({ ComposeComponents: ComposeComponents36 } = window.getGenie.Components.Common.ReduxManager);
      hamburger = `${window.getGenie.config.assetsUrl}dist/admin/images/hamburger.svg`;
      closeBtn = `${window.getGenie.config.assetsUrl}dist/admin/images/close.svg`;
      GenieLogo = `${window.getGenie.config.assetsUrl}dist/admin/images/Genie_logo_black.svg`;
      ({ useState: useState24, useEffect: useEffect32 } = window.React);
      additionalMenuItems = [
        "Writing History",
        "Statistics"
      ];
      ContextMenu = ComposeComponents36(
        ({ contextMenu, setContextMenu, sidebar: sidebar4, setSidebar }) => {
          const [additionalMenu, setAdditionalMenu] = useState24(false);
          const [menu, setMenu] = useState24({});
          let { open, buttonEvent, inputContent } = contextMenu;
          const { selectedText } = inputContent;
          let menuItems = [
            { title: "Write Using Templates", mode: "template", slug: "list", disable: false },
            { title: "Expand Outline", mode: "advance", slug: "expandOutline", disable: !selectedText || contextMenu?.isDisable?.expandOutline },
            { title: "Continue Writing", mode: "advance", slug: "continueWriting", disable: false },
            { title: "Re-write Texts", mode: "advance", slug: "content-rewriter", disable: !selectedText },
            { title: "Write Using Genie Mode", mode: "advance", slug: "genieMode" }
          ];
          const showMoreOption = (e) => {
            setAdditionalMenu(!additionalMenu);
          };
          useEffect32(() => {
            const appRoot = document.getElementById("getgenie-container");
            const rect = appRoot.shadowRoot?.querySelector(".getgenie-advance-writing-context-menu")?.getBoundingClientRect();
            if (!rect || !open) {
              return;
            }
            setMenu({
              "menuWidth": rect?.width,
              "menuHeight": rect?.height
            });
          }, [open]);
          let top, left;
          let availableBottomSpace = window.innerHeight - buttonEvent.bottom;
          let availableRightSpace = window.innerWidth - buttonEvent.right;
          top = buttonEvent.top;
          left = buttonEvent.left;
          if (availableBottomSpace < menu.menuHeight) {
            top = buttonEvent.bottom - menu.menuHeight;
          }
          if (availableRightSpace < menu.menuWidth) {
            left = left - menu.menuWidth;
          }
          if (window.innerWidth < 760) {
            left = 0;
          }
          const position = {
            position: "fixed",
            left: `${left}px`,
            top: `${top}px`,
            zIndex: 999999
          };
          const handleMoreOption = (item) => {
            if (item == "Statistics") {
              setSidebar({ isUsageModalOpen: true });
            } else if (item == "Writing History") {
              setSidebar({
                open: true,
                component: "UserHistory",
                analyzeKeyword: {
                  ...sidebar4.analyzeKeyword,
                  open: false
                },
                generatedOutlines: {
                  ...sidebar4.generatedOutlines,
                  open: false
                }
              });
            }
            setContextMenu({
              open: false
            });
          };
          return open ? /* @__PURE__ */ React.createElement("div", {
            style: position,
            className: "getgenie-advance-writing-context-menu"
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-advance-writing-context-menu-header"
          }, /* @__PURE__ */ React.createElement(Row7, {
            justify: "space-between",
            align: "middle",
            className: "getgenie-advance-writing-context-menu-header-row"
          }, /* @__PURE__ */ React.createElement(Col8, {
            span: 12
          }, /* @__PURE__ */ React.createElement("img", {
            style: { width: "84px" },
            src: GenieLogo,
            alt: ""
          })), /* @__PURE__ */ React.createElement(Col8, {
            span: 12
          }, /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-advance-writing-hamburger-wrapper"
          }, /* @__PURE__ */ React.createElement("img", {
            onClick: (e) => showMoreOption(e),
            className: "getgenie-advance-writing-hamburger-icon",
            src: additionalMenu ? closeBtn : hamburger,
            alt: ""
          }))))), /* @__PURE__ */ React.createElement("div", {
            className: "getgenie-advance-writing-context-menu-content"
          }, additionalMenu ? /* @__PURE__ */ React.createElement(List, {
            size: "large",
            dataSource: additionalMenuItems,
            renderItem: (item) => /* @__PURE__ */ React.createElement(List.Item, {
              onClick: () => handleMoreOption(item)
            }, item)
          }) : /* @__PURE__ */ React.createElement(List, {
            className: "getgenie-advance-writing-main-list",
            size: "large",
            dataSource: menuItems,
            renderItem: (item) => /* @__PURE__ */ React.createElement(List.Item, {
              onClick: () => Callbacks_default.showSidebar(item),
              className: item.disable ? "disable" : ""
            }, item.title)
          }))) : "";
        },
        ["contextMenu", "setContextMenu", "sidebar", "setSidebar"]
      );
      ContextMenu_default = ContextMenu;
    }
  });

  // assets/src/admin/js/Common/LimitUsage/StatsTable.js
  var Typography9, Spin, sidebar3, StatsTable, StatsTable_default;
  var init_StatsTable = __esm({
    "assets/src/admin/js/Common/LimitUsage/StatsTable.js"() {
      ({ Typography: Typography9, Spin } = window.antd);
      sidebar3 = wp.data.select("getgenie").sidebar();
      StatsTable = ({ data, loading, title, currentSubscriptions = [] }) => {
        return /* @__PURE__ */ React.createElement(Spin, {
          tip: "Loading...",
          spinning: loading
        }, /* @__PURE__ */ React.createElement(Typography9.Title, {
          level: 4
        }, title, ":"), /* @__PURE__ */ React.createElement("div", null, currentSubscriptions.map(
          (item, key) => item?.package_name && item?.expires_at ? /* @__PURE__ */ React.createElement("h5", {
            key,
            className: "limit-usage-package-name"
          }, item?.package_name, /* @__PURE__ */ React.createElement("span", {
            className: "limit-usage-expiration"
          }, "Expires at: ", item?.expires_at)) : ""
        )), /* @__PURE__ */ React.createElement("table", {
          className: "user-stats-table"
        }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", null, sidebar3.__("Feature Type", "getgenie")), /* @__PURE__ */ React.createElement("th", null, sidebar3.__("Limit", "getgenie")), /* @__PURE__ */ React.createElement("th", null, sidebar3.__("Usage", "getgenie")), /* @__PURE__ */ React.createElement("th", null, sidebar3.__("Remaining Usage", "getgenie")))), /* @__PURE__ */ React.createElement("tbody", null, loading ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("td", null, sidebar3.__("Word Generate", "getgenie"), ":"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---")), /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("td", null, sidebar3.__("Serp Analysis", "getgenie"), ":"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---")), /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("td", null, sidebar3.__("Keyword Lookup", "getgenie"), ":"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---")), /* @__PURE__ */ React.createElement("tr", {
          className: "Domain Limit"
        }, /* @__PURE__ */ React.createElement("td", null, sidebar3.__("Domain Limit", "getgenie"), ":"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---"), /* @__PURE__ */ React.createElement("td", null, "---"))) : data?.map((item, index2) => /* @__PURE__ */ React.createElement("tr", {
          key: index2,
          className: item?.[0]
        }, item?.map((cellValue, key) => /* @__PURE__ */ React.createElement("td", {
          key
        }, cellValue)))))));
      };
      StatsTable_default = StatsTable;
    }
  });

  // assets/src/admin/js/Common/Utilities/limitUsagesKeys.js
  var limitUsageKeys, limitUsagesKeys_default;
  var init_limitUsagesKeys = __esm({
    "assets/src/admin/js/Common/Utilities/limitUsagesKeys.js"() {
      limitUsageKeys = [
        "pages_per_site",
        "keywords_per_site",
        "data_fetch_count_per_week",
        "keywords_latest_overview",
        "top_pages_insights",
        "competing_pages_insights",
        "device_country_insights",
        "lost_keyword_insights",
        "new_keyword_insights",
        "improved_declined_keywords",
        "keywords_top3_top10_outside10",
        "low_hanging_fruits",
        "pages_needed_attention",
        "export_topical_map_image",
        "export_topical_map_csv",
        "related_keyword_details",
        "nlp_keyword_details",
        "semantic_keyword_details",
        "nlp_semantic_one_click_blog"
      ];
      limitUsagesKeys_default = limitUsageKeys;
    }
  });

  // assets/src/admin/js/Common/LimitUsage/index.js
  var useState25, useEffect33, ComposeComponents37, Libs30, LicenseNotice, HandleFetch8, HandleResponse9, LimitUses, LimitUsage_default;
  var init_LimitUsage = __esm({
    "assets/src/admin/js/Common/LimitUsage/index.js"() {
      init_StatsTable();
      init_limitUsagesKeys();
      ({ useState: useState25, useEffect: useEffect33 } = window.React);
      ({ ComposeComponents: ComposeComponents37 } = window.getGenie.Components.Common.ReduxManager);
      ({ Libs: Libs30, LicenseNotice } = window.getGenie.Components.Common);
      ({ HandleFetch: HandleFetch8, HandleResponse: HandleResponse9 } = window.getGenie.Components.Common.RequestManager);
      LimitUses = ComposeComponents37(({ sidebar: sidebar4, setSidebar, limitUsage: limitUsage2, setLimitUsage }) => {
        const [status, setStatus] = useState25(!!window.getGenie.config.siteToken);
        const [isModalVisible, setIsModalVisible] = useState25(sidebar4.isUsageModalOpen);
        const [loadingTable, setLoadingTable] = useState25(false);
        const [siteData, setSiteData] = useState25(Object.keys(limitUsage2.siteUsagesLimit));
        const [subscriptionData, setSubscriptionData] = useState25(Object.keys(limitUsage2.subscriptionUsagesLimit));
        const [currentSite, setCurrentSite] = useState25("Current site");
        useEffect33(() => {
          setIsModalVisible(sidebar4.isUsageModalOpen);
        }, [sidebar4.isUsageModalOpen]);
        useEffect33(() => {
          if (status && (siteData.length === 0 && subscriptionData.length === 0)) {
            setLoadingTable(true);
            HandleFetch8((res) => {
              HandleResponse9(res, () => {
                setLimitUsage({
                  ...res?.data
                });
              });
              setLoadingTable(false);
            }, "limitUsage");
          }
        }, []);
        const closeModal = () => {
          setSidebar({
            isUsageModalOpen: false
          });
        };
        const titleCase = (str) => {
          let initial = str.replace(/^[_]*(.)/, (_, char) => char.toUpperCase());
          let result = initial.replace(/[_]+(.)/g, (_, char) => " " + char.toUpperCase());
          return result;
        };
        const prepareUsageData = (result) => {
          let values = Object.values(result);
          if (values.length === 0) {
            return;
          }
          let limit = result?.limits;
          let usage = result?.usages;
          let data = [];
          if (Array.isArray(limit)) {
            const updatedLimitUsagesArr = limitUsagesKeys_default.filter((item) => limit.includes(item));
            const updatedUniqueLimit = limit.filter((item) => !updatedLimitUsagesArr.includes(item));
            data = updatedUniqueLimit.map((item) => {
              let arr = [];
              let limitValue = item.value || "~";
              let usageValue = usage.find((obj) => obj.key === item.key).value || 0;
              arr.push(item.title);
              arr.push(limitValue);
              arr.push(usageValue);
              arr.push(`${isNaN(limitValue) ? "~" : Math.max(0, parseInt(limitValue) - parseInt(usageValue)) || 0}`);
              return arr;
            });
          } else if (typeof limit === "object") {
            const updatedLimitUsagesArr = limitUsagesKeys_default.filter((item) => limit.hasOwnProperty(item));
            const updatedUniqueLimitObj = Object.keys(limit).reduce((acc, key) => {
              if (!updatedLimitUsagesArr.includes(key)) {
                acc[key] = limit[key];
              }
              return acc;
            }, {});
            data = Object.keys(updatedUniqueLimitObj).map((key) => {
              let arr = [];
              let limitValue = updatedUniqueLimitObj?.[key] || "~";
              let usageValue = usage?.[key] || 0;
              arr.push(titleCase(key));
              arr.push(limitValue);
              arr.push(usageValue);
              arr.push(`${isNaN(limitValue) ? "~" : Math.max(0, parseInt(limitValue) - parseInt(usageValue)) || 0}`);
              return arr;
            });
          }
          return data;
        };
        useEffect33(() => {
          if (Object.values(limitUsage2?.subscriptionUsagesLimit).length === 0) {
            return;
          }
          const packageInfo = {
            limits: {},
            usages: {}
          };
          const packages = [];
          for (const obj of Object.values(limitUsage2?.subscriptionUsagesLimit || {})) {
            packages.push({
              package_name: obj?.package_name,
              expires_at: obj?.expires_at,
              isFree: obj?.isFree
            });
            for (const key in obj) {
              if (Object.keys(packageInfo).includes(key)) {
                const featureObj = obj[key];
                for (const feature in featureObj) {
                  const featureVal = featureObj[feature];
                  if (packageInfo?.[key]?.[feature] == void 0) {
                    packageInfo[key][feature] = featureVal;
                  } else {
                    packageInfo[key][feature] = parseInt(packageInfo?.[key]?.[feature]) + parseInt(featureVal);
                  }
                }
              }
            }
          }
          let subscriptionResult = prepareUsageData(packageInfo);
          let domainResult = prepareUsageData(Object.values(limitUsage2?.siteUsagesLimit || {})?.[0] || {});
          setCurrentSite(Object.keys(limitUsage2?.siteUsagesLimit || {})?.[0] || "Current site");
          setSubscriptionData(subscriptionResult);
          setSiteData(domainResult);
          const usagePercentage = {};
          for (const key in packageInfo.limits) {
            usagePercentage[key] = Math.floor((packageInfo.usages?.[key] || 0) / (packageInfo.limits?.[key] || 0) * 100);
          }
          wp.data.dispatch("getgenie").setSidebar({ subscriptionStatistics: { usagePercentage: { ...usagePercentage } } });
        }, [limitUsage2]);
        return /* @__PURE__ */ React.createElement(Libs30.Modal, {
          closeIcon: /* @__PURE__ */ React.createElement("span", {
            className: "getgenie-icon-close1"
          }),
          isModalVisible,
          setIsModalVisible,
          onClose: closeModal,
          className: "getgenie-limit-usage-modal",
          centered: true,
          footer: null
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-info-wrapper-modal"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "getgenie-license-form",
          layout: "vertical"
        }, status ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatsTable_default, {
          title: `${currentSite} usage details`,
          loading: loadingTable,
          data: siteData
        })) : /* @__PURE__ */ React.createElement(LicenseNotice, null))));
      }, ["sidebar", "setSidebar", "limitUsage", "setLimitUsage"]);
      LimitUsage_default = LimitUses;
    }
  });

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var init_setPrototypeOf = __esm({
    "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  var init_inheritsLoose = __esm({
    "node_modules/@babel/runtime/helpers/esm/inheritsLoose.js"() {
      init_setPrototypeOf();
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType2(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType2;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location2 + " type: " + error.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement2, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location2, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location2, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i2 = 0; i2 < propValue.length; i2++) {
              var error = typeChecker(propValue, i2, componentName, location2, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!isValidElement2(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            for (var i2 = 0; i2 < expectedValues.length; i2++) {
              if (is(propValue, expectedValues[i2])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value2) {
              var type = getPreciseType(value2);
              if (type === "symbol") {
                return String(value2);
              }
              return value2;
            });
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker = arrayOfTypeCheckers[i2];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var expectedTypes = [];
            for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
              var checker2 = arrayOfTypeCheckers[i3];
              var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location2, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement2(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value2) {
          var type = getPreciseType(value2);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var init_extends = __esm({
    "node_modules/@babel/runtime/helpers/esm/extends.js"() {
    }
  });

  // node_modules/resolve-pathname/esm/resolve-pathname.js
  function isAbsolute(pathname) {
    return pathname.charAt(0) === "/";
  }
  function spliceOne(list, index2) {
    for (var i2 = index2, k = i2 + 1, n = list.length; k < n; i2 += 1, k += 1) {
      list[i2] = list[k];
    }
    list.pop();
  }
  function resolvePathname(to2, from2) {
    if (from2 === void 0)
      from2 = "";
    var toParts = to2 && to2.split("/") || [];
    var fromParts = from2 && from2.split("/") || [];
    var isToAbs = to2 && isAbsolute(to2);
    var isFromAbs = from2 && isAbsolute(from2);
    var mustEndAbs = isToAbs || isFromAbs;
    if (to2 && isAbsolute(to2)) {
      fromParts = toParts;
    } else if (toParts.length) {
      fromParts.pop();
      fromParts = fromParts.concat(toParts);
    }
    if (!fromParts.length)
      return "/";
    var hasTrailingSlash;
    if (fromParts.length) {
      var last = fromParts[fromParts.length - 1];
      hasTrailingSlash = last === "." || last === ".." || last === "";
    } else {
      hasTrailingSlash = false;
    }
    var up = 0;
    for (var i2 = fromParts.length; i2 >= 0; i2--) {
      var part = fromParts[i2];
      if (part === ".") {
        spliceOne(fromParts, i2);
      } else if (part === "..") {
        spliceOne(fromParts, i2);
        up++;
      } else if (up) {
        spliceOne(fromParts, i2);
        up--;
      }
    }
    if (!mustEndAbs)
      for (; up--; up)
        fromParts.unshift("..");
    if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
      fromParts.unshift("");
    var result = fromParts.join("/");
    if (hasTrailingSlash && result.substr(-1) !== "/")
      result += "/";
    return result;
  }
  var resolve_pathname_default;
  var init_resolve_pathname = __esm({
    "node_modules/resolve-pathname/esm/resolve-pathname.js"() {
      resolve_pathname_default = resolvePathname;
    }
  });

  // node_modules/value-equal/esm/value-equal.js
  function valueOf(obj) {
    return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
  }
  function valueEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function(item, index2) {
        return valueEqual(item, b[index2]);
      });
    }
    if (typeof a === "object" || typeof b === "object") {
      var aValue = valueOf(a);
      var bValue = valueOf(b);
      if (aValue !== a || bValue !== b)
        return valueEqual(aValue, bValue);
      return Object.keys(Object.assign({}, a, b)).every(function(key) {
        return valueEqual(a[key], b[key]);
      });
    }
    return false;
  }
  var value_equal_default;
  var init_value_equal = __esm({
    "node_modules/value-equal/esm/value-equal.js"() {
      value_equal_default = valueEqual;
    }
  });

  // node_modules/tiny-warning/dist/tiny-warning.esm.js
  function warning2(condition, message) {
    if (!isProduction2) {
      if (condition) {
        return;
      }
      var text = "Warning: " + message;
      if (typeof console !== "undefined") {
        console.warn(text);
      }
      try {
        throw Error(text);
      } catch (x) {
      }
    }
  }
  var isProduction2, tiny_warning_esm_default;
  var init_tiny_warning_esm = __esm({
    "node_modules/tiny-warning/dist/tiny-warning.esm.js"() {
      isProduction2 = false;
      tiny_warning_esm_default = warning2;
    }
  });

  // node_modules/tiny-invariant/dist/tiny-invariant.esm.js
  function invariant2(condition, message) {
    if (condition) {
      return;
    }
    if (isProduction3) {
      throw new Error(prefix);
    }
    var provided = typeof message === "function" ? message() : message;
    var value2 = provided ? prefix + ": " + provided : prefix;
    throw new Error(value2);
  }
  var isProduction3, prefix;
  var init_tiny_invariant_esm = __esm({
    "node_modules/tiny-invariant/dist/tiny-invariant.esm.js"() {
      isProduction3 = false;
      prefix = "Invariant failed";
    }
  });

  // node_modules/history/esm/history.js
  function addLeadingSlash(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
  }
  function stripLeadingSlash(path) {
    return path.charAt(0) === "/" ? path.substr(1) : path;
  }
  function hasBasename(path, prefix2) {
    return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
  }
  function stripBasename(path, prefix2) {
    return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
  }
  function stripTrailingSlash(path) {
    return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
  }
  function parsePath(path) {
    var pathname = path || "/";
    var search = "";
    var hash = "";
    var hashIndex = pathname.indexOf("#");
    if (hashIndex !== -1) {
      hash = pathname.substr(hashIndex);
      pathname = pathname.substr(0, hashIndex);
    }
    var searchIndex = pathname.indexOf("?");
    if (searchIndex !== -1) {
      search = pathname.substr(searchIndex);
      pathname = pathname.substr(0, searchIndex);
    }
    return {
      pathname,
      search: search === "?" ? "" : search,
      hash: hash === "#" ? "" : hash
    };
  }
  function createPath(location2) {
    var pathname = location2.pathname, search = location2.search, hash = location2.hash;
    var path = pathname || "/";
    if (search && search !== "?")
      path += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#")
      path += hash.charAt(0) === "#" ? hash : "#" + hash;
    return path;
  }
  function createLocation(path, state, key, currentLocation) {
    var location2;
    if (typeof path === "string") {
      location2 = parsePath(path);
      location2.state = state;
    } else {
      location2 = _extends({}, path);
      if (location2.pathname === void 0)
        location2.pathname = "";
      if (location2.search) {
        if (location2.search.charAt(0) !== "?")
          location2.search = "?" + location2.search;
      } else {
        location2.search = "";
      }
      if (location2.hash) {
        if (location2.hash.charAt(0) !== "#")
          location2.hash = "#" + location2.hash;
      } else {
        location2.hash = "";
      }
      if (state !== void 0 && location2.state === void 0)
        location2.state = state;
    }
    try {
      location2.pathname = decodeURI(location2.pathname);
    } catch (e) {
      if (e instanceof URIError) {
        throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
      } else {
        throw e;
      }
    }
    if (key)
      location2.key = key;
    if (currentLocation) {
      if (!location2.pathname) {
        location2.pathname = currentLocation.pathname;
      } else if (location2.pathname.charAt(0) !== "/") {
        location2.pathname = resolve_pathname_default(location2.pathname, currentLocation.pathname);
      }
    } else {
      if (!location2.pathname) {
        location2.pathname = "/";
      }
    }
    return location2;
  }
  function locationsAreEqual(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && value_equal_default(a.state, b.state);
  }
  function createTransitionManager() {
    var prompt = null;
    function setPrompt(nextPrompt) {
      true ? tiny_warning_esm_default(prompt == null, "A history supports only one prompt at a time") : void 0;
      prompt = nextPrompt;
      return function() {
        if (prompt === nextPrompt)
          prompt = null;
      };
    }
    function confirmTransitionTo(location2, action, getUserConfirmation, callback2) {
      if (prompt != null) {
        var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
        if (typeof result === "string") {
          if (typeof getUserConfirmation === "function") {
            getUserConfirmation(result, callback2);
          } else {
            true ? tiny_warning_esm_default(false, "A history needs a getUserConfirmation function in order to use a prompt message") : void 0;
            callback2(true);
          }
        } else {
          callback2(result !== false);
        }
      } else {
        callback2(true);
      }
    }
    var listeners = [];
    function appendListener(fn) {
      var isActive = true;
      function listener() {
        if (isActive)
          fn.apply(void 0, arguments);
      }
      listeners.push(listener);
      return function() {
        isActive = false;
        listeners = listeners.filter(function(item) {
          return item !== listener;
        });
      };
    }
    function notifyListeners() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      listeners.forEach(function(listener) {
        return listener.apply(void 0, args);
      });
    }
    return {
      setPrompt,
      confirmTransitionTo,
      appendListener,
      notifyListeners
    };
  }
  function getConfirmation(message, callback2) {
    callback2(window.confirm(message));
  }
  function supportsHistory() {
    var ua = window.navigator.userAgent;
    if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1)
      return false;
    return window.history && "pushState" in window.history;
  }
  function supportsPopStateOnHashChange() {
    return window.navigator.userAgent.indexOf("Trident") === -1;
  }
  function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf("Firefox") === -1;
  }
  function isExtraneousPopstateEvent(event) {
    return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
  }
  function getHistoryState() {
    try {
      return window.history.state || {};
    } catch (e) {
      return {};
    }
  }
  function createBrowserHistory(props) {
    if (props === void 0) {
      props = {};
    }
    !canUseDOM ? true ? invariant2(false, "Browser history needs a DOM") : invariant2(false) : void 0;
    var globalHistory = window.history;
    var canUseHistory = supportsHistory();
    var needsHashChangeListener = !supportsPopStateOnHashChange();
    var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
    function getDOMLocation(historyState) {
      var _ref = historyState || {}, key = _ref.key, state = _ref.state;
      var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
      var path = pathname + search + hash;
      true ? tiny_warning_esm_default(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
      if (basename)
        path = stripBasename(path, basename);
      return createLocation(path, state, key);
    }
    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    function handlePopState(event) {
      if (isExtraneousPopstateEvent(event))
        return;
      handlePop(getDOMLocation(event.state));
    }
    function handleHashChange() {
      handlePop(getDOMLocation(getHistoryState()));
    }
    var forceNextPop = false;
    function handlePop(location2) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = "POP";
        transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
          if (ok) {
            setState({
              action,
              location: location2
            });
          } else {
            revertPop(location2);
          }
        });
      }
    }
    function revertPop(fromLocation) {
      var toLocation = history.location;
      var toIndex = allKeys.indexOf(toLocation.key);
      if (toIndex === -1)
        toIndex = 0;
      var fromIndex = allKeys.indexOf(fromLocation.key);
      if (fromIndex === -1)
        fromIndex = 0;
      var delta = toIndex - fromIndex;
      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    }
    var initialLocation = getDOMLocation(getHistoryState());
    var allKeys = [initialLocation.key];
    function createHref(location2) {
      return basename + createPath(location2);
    }
    function push(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "PUSH";
      var location2 = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var href = createHref(location2);
        var key = location2.key, state2 = location2.state;
        if (canUseHistory) {
          globalHistory.pushState({
            key,
            state: state2
          }, null, href);
          if (forceRefresh) {
            window.location.href = href;
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            var nextKeys = allKeys.slice(0, prevIndex + 1);
            nextKeys.push(location2.key);
            allKeys = nextKeys;
            setState({
              action,
              location: location2
            });
          }
        } else {
          true ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot push state in browsers that do not support HTML5 history") : void 0;
          window.location.href = href;
        }
      });
    }
    function replace(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "REPLACE";
      var location2 = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var href = createHref(location2);
        var key = location2.key, state2 = location2.state;
        if (canUseHistory) {
          globalHistory.replaceState({
            key,
            state: state2
          }, null, href);
          if (forceRefresh) {
            window.location.replace(href);
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            if (prevIndex !== -1)
              allKeys[prevIndex] = location2.key;
            setState({
              action,
              location: location2
            });
          }
        } else {
          true ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot replace state in browsers that do not support HTML5 history") : void 0;
          window.location.replace(href);
        }
      });
    }
    function go(n) {
      globalHistory.go(n);
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    var listenerCount = 0;
    function checkDOMListeners(delta) {
      listenerCount += delta;
      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener)
          window.addEventListener(HashChangeEvent, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener)
          window.removeEventListener(HashChangeEvent, handleHashChange);
      }
    }
    var isBlocked = false;
    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      var unblock = transitionManager.setPrompt(prompt);
      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }
      return function() {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }
        return unblock();
      };
    }
    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function() {
        checkDOMListeners(-1);
        unlisten();
      };
    }
    var history = {
      length: globalHistory.length,
      action: "POP",
      location: initialLocation,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      block,
      listen
    };
    return history;
  }
  function stripHash(url2) {
    var hashIndex = url2.indexOf("#");
    return hashIndex === -1 ? url2 : url2.slice(0, hashIndex);
  }
  function getHashPath() {
    var href = window.location.href;
    var hashIndex = href.indexOf("#");
    return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
  }
  function pushHashPath(path) {
    window.location.hash = path;
  }
  function replaceHashPath(path) {
    window.location.replace(stripHash(window.location.href) + "#" + path);
  }
  function createHashHistory(props) {
    if (props === void 0) {
      props = {};
    }
    !canUseDOM ? true ? invariant2(false, "Hash history needs a DOM") : invariant2(false) : void 0;
    var globalHistory = window.history;
    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
    var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
    var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
    function getDOMLocation() {
      var path2 = decodePath2(getHashPath());
      true ? tiny_warning_esm_default(!basename || hasBasename(path2, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path2 + '" to begin with "' + basename + '".') : void 0;
      if (basename)
        path2 = stripBasename(path2, basename);
      return createLocation(path2);
    }
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    var forceNextPop = false;
    var ignorePath = null;
    function locationsAreEqual$$1(a, b) {
      return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
    }
    function handleHashChange() {
      var path2 = getHashPath();
      var encodedPath2 = encodePath2(path2);
      if (path2 !== encodedPath2) {
        replaceHashPath(encodedPath2);
      } else {
        var location2 = getDOMLocation();
        var prevLocation = history.location;
        if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2))
          return;
        if (ignorePath === createPath(location2))
          return;
        ignorePath = null;
        handlePop(location2);
      }
    }
    function handlePop(location2) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = "POP";
        transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
          if (ok) {
            setState({
              action,
              location: location2
            });
          } else {
            revertPop(location2);
          }
        });
      }
    }
    function revertPop(fromLocation) {
      var toLocation = history.location;
      var toIndex = allPaths.lastIndexOf(createPath(toLocation));
      if (toIndex === -1)
        toIndex = 0;
      var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
      if (fromIndex === -1)
        fromIndex = 0;
      var delta = toIndex - fromIndex;
      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    }
    var path = getHashPath();
    var encodedPath = encodePath2(path);
    if (path !== encodedPath)
      replaceHashPath(encodedPath);
    var initialLocation = getDOMLocation();
    var allPaths = [createPath(initialLocation)];
    function createHref(location2) {
      var baseTag = document.querySelector("base");
      var href = "";
      if (baseTag && baseTag.getAttribute("href")) {
        href = stripHash(window.location.href);
      }
      return href + "#" + encodePath2(basename + createPath(location2));
    }
    function push(path2, state) {
      true ? tiny_warning_esm_default(state === void 0, "Hash history cannot push state; it is ignored") : void 0;
      var action = "PUSH";
      var location2 = createLocation(path2, void 0, void 0, history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var path3 = createPath(location2);
        var encodedPath2 = encodePath2(basename + path3);
        var hashChanged = getHashPath() !== encodedPath2;
        if (hashChanged) {
          ignorePath = path3;
          pushHashPath(encodedPath2);
          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
          var nextPaths = allPaths.slice(0, prevIndex + 1);
          nextPaths.push(path3);
          allPaths = nextPaths;
          setState({
            action,
            location: location2
          });
        } else {
          true ? tiny_warning_esm_default(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack") : void 0;
          setState();
        }
      });
    }
    function replace(path2, state) {
      true ? tiny_warning_esm_default(state === void 0, "Hash history cannot replace state; it is ignored") : void 0;
      var action = "REPLACE";
      var location2 = createLocation(path2, void 0, void 0, history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var path3 = createPath(location2);
        var encodedPath2 = encodePath2(basename + path3);
        var hashChanged = getHashPath() !== encodedPath2;
        if (hashChanged) {
          ignorePath = path3;
          replaceHashPath(encodedPath2);
        }
        var prevIndex = allPaths.indexOf(createPath(history.location));
        if (prevIndex !== -1)
          allPaths[prevIndex] = path3;
        setState({
          action,
          location: location2
        });
      });
    }
    function go(n) {
      true ? tiny_warning_esm_default(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser") : void 0;
      globalHistory.go(n);
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    var listenerCount = 0;
    function checkDOMListeners(delta) {
      listenerCount += delta;
      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(HashChangeEvent$1, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(HashChangeEvent$1, handleHashChange);
      }
    }
    var isBlocked = false;
    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      var unblock = transitionManager.setPrompt(prompt);
      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }
      return function() {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }
        return unblock();
      };
    }
    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function() {
        checkDOMListeners(-1);
        unlisten();
      };
    }
    var history = {
      length: globalHistory.length,
      action: "POP",
      location: initialLocation,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      block,
      listen
    };
    return history;
  }
  function clamp2(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
  }
  function createMemoryHistory(props) {
    if (props === void 0) {
      props = {};
    }
    var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = history.entries.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }
    var index2 = clamp2(initialIndex, 0, initialEntries.length - 1);
    var entries = initialEntries.map(function(entry) {
      return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
    });
    var createHref = createPath;
    function push(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "PUSH";
      var location2 = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var prevIndex = history.index;
        var nextIndex = prevIndex + 1;
        var nextEntries = history.entries.slice(0);
        if (nextEntries.length > nextIndex) {
          nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
        } else {
          nextEntries.push(location2);
        }
        setState({
          action,
          location: location2,
          index: nextIndex,
          entries: nextEntries
        });
      });
    }
    function replace(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "REPLACE";
      var location2 = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        history.entries[history.index] = location2;
        setState({
          action,
          location: location2
        });
      });
    }
    function go(n) {
      var nextIndex = clamp2(history.index + n, 0, history.entries.length - 1);
      var action = "POP";
      var location2 = history.entries[nextIndex];
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location: location2,
            index: nextIndex
          });
        } else {
          setState();
        }
      });
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    function canGo(n) {
      var nextIndex = history.index + n;
      return nextIndex >= 0 && nextIndex < history.entries.length;
    }
    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      return transitionManager.setPrompt(prompt);
    }
    function listen(listener) {
      return transitionManager.appendListener(listener);
    }
    var history = {
      length: entries.length,
      action: "POP",
      location: entries[index2],
      index: index2,
      entries,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      canGo,
      block,
      listen
    };
    return history;
  }
  var canUseDOM, PopStateEvent, HashChangeEvent, HashChangeEvent$1, HashPathCoders;
  var init_history = __esm({
    "node_modules/history/esm/history.js"() {
      init_extends();
      init_resolve_pathname();
      init_value_equal();
      init_tiny_warning_esm();
      init_tiny_invariant_esm();
      canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      PopStateEvent = "popstate";
      HashChangeEvent = "hashchange";
      HashChangeEvent$1 = "hashchange";
      HashPathCoders = {
        hashbang: {
          encodePath: function encodePath(path) {
            return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
          },
          decodePath: function decodePath(path) {
            return path.charAt(0) === "!" ? path.substr(1) : path;
          }
        },
        noslash: {
          encodePath: stripLeadingSlash,
          decodePath: addLeadingSlash
        },
        slash: {
          encodePath: addLeadingSlash,
          decodePath: addLeadingSlash
        }
      };
    }
  });

  // node_modules/mini-create-react-context/dist/esm/index.js
  function getUniqueId() {
    var key = "__global_unique_id__";
    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
  }
  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function createEventEmitter(value2) {
    var handlers = [];
    return {
      on: function on2(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function(h) {
          return h !== handler;
        });
      },
      get: function get2() {
        return value2;
      },
      set: function set2(newValue, changedBits) {
        value2 = newValue;
        handlers.forEach(function(handler) {
          return handler(value2, changedBits);
        });
      }
    };
  }
  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }
  function createReactContext(defaultValue, calculateChangedBits) {
    var _Provider$childContex, _Consumer$contextType;
    var contextProp = "__create-react-context-" + getUniqueId() + "__";
    var Provider = /* @__PURE__ */ function(_Component) {
      _inheritsLoose(Provider2, _Component);
      function Provider2() {
        var _this;
        _this = _Component.apply(this, arguments) || this;
        _this.emitter = createEventEmitter(_this.props.value);
        return _this;
      }
      var _proto = Provider2.prototype;
      _proto.getChildContext = function getChildContext() {
        var _ref;
        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };
      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits;
          if (objectIs(oldValue, newValue)) {
            changedBits = 0;
          } else {
            changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            if (true) {
              tiny_warning_esm_default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: " + changedBits);
            }
            changedBits |= 0;
            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };
      _proto.render = function render() {
        return this.props.children;
      };
      return Provider2;
    }(import_react21.Component);
    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = import_prop_types.default.object.isRequired, _Provider$childContex);
    var Consumer = /* @__PURE__ */ function(_Component2) {
      _inheritsLoose(Consumer2, _Component2);
      function Consumer2() {
        var _this2;
        _this2 = _Component2.apply(this, arguments) || this;
        _this2.state = {
          value: _this2.getValue()
        };
        _this2.onUpdate = function(newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;
          if ((observedBits & changedBits) !== 0) {
            _this2.setState({
              value: _this2.getValue()
            });
          }
        };
        return _this2;
      }
      var _proto2 = Consumer2.prototype;
      _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var observedBits = nextProps.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
        var observedBits = this.props.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };
      _proto2.getValue = function getValue() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };
      _proto2.render = function render() {
        return onlyChild(this.props.children)(this.state.value);
      };
      return Consumer2;
    }(import_react21.Component);
    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = import_prop_types.default.object, _Consumer$contextType);
    return {
      Provider,
      Consumer
    };
  }
  var import_react21, import_prop_types, MAX_SIGNED_31_BIT_INT, commonjsGlobal, index, esm_default;
  var init_esm5 = __esm({
    "node_modules/mini-create-react-context/dist/esm/index.js"() {
      import_react21 = __toESM(require_react());
      init_inheritsLoose();
      import_prop_types = __toESM(require_prop_types());
      init_tiny_warning_esm();
      MAX_SIGNED_31_BIT_INT = 1073741823;
      commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
      index = import_react21.default.createContext || createReactContext;
      esm_default = index;
    }
  });

  // node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/isarray/index.js"(exports, module) {
      module.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/path-to-regexp/index.js
  var require_path_to_regexp = __commonJS({
    "node_modules/path-to-regexp/index.js"(exports, module) {
      var isarray = require_isarray();
      module.exports = pathToRegexp2;
      module.exports.parse = parse3;
      module.exports.compile = compile;
      module.exports.tokensToFunction = tokensToFunction;
      module.exports.tokensToRegExp = tokensToRegExp;
      var PATH_REGEXP = new RegExp([
        "(\\\\.)",
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
      ].join("|"), "g");
      function parse3(str, options) {
        var tokens = [];
        var key = 0;
        var index2 = 0;
        var path = "";
        var defaultDelimiter = options && options.delimiter || "/";
        var res;
        while ((res = PATH_REGEXP.exec(str)) != null) {
          var m = res[0];
          var escaped = res[1];
          var offset = res.index;
          path += str.slice(index2, offset);
          index2 = offset + m.length;
          if (escaped) {
            path += escaped[1];
            continue;
          }
          var next = str[index2];
          var prefix2 = res[2];
          var name = res[3];
          var capture = res[4];
          var group = res[5];
          var modifier = res[6];
          var asterisk = res[7];
          if (path) {
            tokens.push(path);
            path = "";
          }
          var partial = prefix2 != null && next != null && next !== prefix2;
          var repeat = modifier === "+" || modifier === "*";
          var optional = modifier === "?" || modifier === "*";
          var delimiter = res[2] || defaultDelimiter;
          var pattern = capture || group;
          tokens.push({
            name: name || key++,
            prefix: prefix2 || "",
            delimiter,
            optional,
            repeat,
            partial,
            asterisk: !!asterisk,
            pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
          });
        }
        if (index2 < str.length) {
          path += str.substr(index2);
        }
        if (path) {
          tokens.push(path);
        }
        return tokens;
      }
      function compile(str, options) {
        return tokensToFunction(parse3(str, options), options);
      }
      function encodeURIComponentPretty(str) {
        return encodeURI(str).replace(/[\/?#]/g, function(c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function encodeAsterisk(str) {
        return encodeURI(str).replace(/[?#]/g, function(c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function tokensToFunction(tokens, options) {
        var matches = new Array(tokens.length);
        for (var i2 = 0; i2 < tokens.length; i2++) {
          if (typeof tokens[i2] === "object") {
            matches[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$", flags(options));
          }
        }
        return function(obj, opts) {
          var path = "";
          var data = obj || {};
          var options2 = opts || {};
          var encode3 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
          for (var i3 = 0; i3 < tokens.length; i3++) {
            var token = tokens[i3];
            if (typeof token === "string") {
              path += token;
              continue;
            }
            var value2 = data[token.name];
            var segment;
            if (value2 == null) {
              if (token.optional) {
                if (token.partial) {
                  path += token.prefix;
                }
                continue;
              } else {
                throw new TypeError('Expected "' + token.name + '" to be defined');
              }
            }
            if (isarray(value2)) {
              if (!token.repeat) {
                throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value2) + "`");
              }
              if (value2.length === 0) {
                if (token.optional) {
                  continue;
                } else {
                  throw new TypeError('Expected "' + token.name + '" to not be empty');
                }
              }
              for (var j = 0; j < value2.length; j++) {
                segment = encode3(value2[j]);
                if (!matches[i3].test(segment)) {
                  throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                }
                path += (j === 0 ? token.prefix : token.delimiter) + segment;
              }
              continue;
            }
            segment = token.asterisk ? encodeAsterisk(value2) : encode3(value2);
            if (!matches[i3].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
            }
            path += token.prefix + segment;
          }
          return path;
        };
      }
      function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
      }
      function escapeGroup(group) {
        return group.replace(/([=!:$\/()])/g, "\\$1");
      }
      function attachKeys(re2, keys) {
        re2.keys = keys;
        return re2;
      }
      function flags(options) {
        return options && options.sensitive ? "" : "i";
      }
      function regexpToRegexp(path, keys) {
        var groups = path.source.match(/\((?!\?)/g);
        if (groups) {
          for (var i2 = 0; i2 < groups.length; i2++) {
            keys.push({
              name: i2,
              prefix: null,
              delimiter: null,
              optional: false,
              repeat: false,
              partial: false,
              asterisk: false,
              pattern: null
            });
          }
        }
        return attachKeys(path, keys);
      }
      function arrayToRegexp(path, keys, options) {
        var parts2 = [];
        for (var i2 = 0; i2 < path.length; i2++) {
          parts2.push(pathToRegexp2(path[i2], keys, options).source);
        }
        var regexp = new RegExp("(?:" + parts2.join("|") + ")", flags(options));
        return attachKeys(regexp, keys);
      }
      function stringToRegexp(path, keys, options) {
        return tokensToRegExp(parse3(path, options), keys, options);
      }
      function tokensToRegExp(tokens, keys, options) {
        if (!isarray(keys)) {
          options = keys || options;
          keys = [];
        }
        options = options || {};
        var strict = options.strict;
        var end = options.end !== false;
        var route = "";
        for (var i2 = 0; i2 < tokens.length; i2++) {
          var token = tokens[i2];
          if (typeof token === "string") {
            route += escapeString(token);
          } else {
            var prefix2 = escapeString(token.prefix);
            var capture = "(?:" + token.pattern + ")";
            keys.push(token);
            if (token.repeat) {
              capture += "(?:" + prefix2 + capture + ")*";
            }
            if (token.optional) {
              if (!token.partial) {
                capture = "(?:" + prefix2 + "(" + capture + "))?";
              } else {
                capture = prefix2 + "(" + capture + ")?";
              }
            } else {
              capture = prefix2 + "(" + capture + ")";
            }
            route += capture;
          }
        }
        var delimiter = escapeString(options.delimiter || "/");
        var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
        if (!strict) {
          route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
        }
        if (end) {
          route += "$";
        } else {
          route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
        }
        return attachKeys(new RegExp("^" + route, flags(options)), keys);
      }
      function pathToRegexp2(path, keys, options) {
        if (!isarray(keys)) {
          options = keys || options;
          keys = [];
        }
        options = options || {};
        if (path instanceof RegExp) {
          return regexpToRegexp(path, keys);
        }
        if (isarray(path)) {
          return arrayToRegexp(path, keys, options);
        }
        return stringToRegexp(path, keys, options);
      }
    }
  });

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var init_objectWithoutPropertiesLoose = __esm({
    "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i2 = 0; i2 < keys.length; ++i2) {
            var key = keys[i2];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // node_modules/react-router/esm/react-router.js
  function Prompt(_ref) {
    var message = _ref.message, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
    return /* @__PURE__ */ import_react22.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant2(false, "You should not use <Prompt> outside a <Router>") : invariant2(false) : void 0;
      if (!when || context2.staticContext)
        return null;
      var method = context2.history.block;
      return /* @__PURE__ */ import_react22.default.createElement(Lifecycle, {
        onMount: function onMount(self2) {
          self2.release = method(message);
        },
        onUpdate: function onUpdate(self2, prevProps) {
          if (prevProps.message !== message) {
            self2.release();
            self2.release = method(message);
          }
        },
        onUnmount: function onUnmount(self2) {
          self2.release();
        },
        message
      });
    });
  }
  function compilePath(path) {
    if (cache2[path])
      return cache2[path];
    var generator = import_path_to_regexp.default.compile(path);
    if (cacheCount < cacheLimit) {
      cache2[path] = generator;
      cacheCount++;
    }
    return generator;
  }
  function generatePath(path, params) {
    if (path === void 0) {
      path = "/";
    }
    if (params === void 0) {
      params = {};
    }
    return path === "/" ? path : compilePath(path)(params, {
      pretty: true
    });
  }
  function Redirect(_ref) {
    var computedMatch = _ref.computedMatch, to2 = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
    return /* @__PURE__ */ import_react22.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant2(false, "You should not use <Redirect> outside a <Router>") : invariant2(false) : void 0;
      var history = context2.history, staticContext = context2.staticContext;
      var method = push ? history.push : history.replace;
      var location2 = createLocation(computedMatch ? typeof to2 === "string" ? generatePath(to2, computedMatch.params) : _extends({}, to2, {
        pathname: generatePath(to2.pathname, computedMatch.params)
      }) : to2);
      if (staticContext) {
        method(location2);
        return null;
      }
      return /* @__PURE__ */ import_react22.default.createElement(Lifecycle, {
        onMount: function onMount() {
          method(location2);
        },
        onUpdate: function onUpdate(self2, prevProps) {
          var prevLocation = createLocation(prevProps.to);
          if (!locationsAreEqual(prevLocation, _extends({}, location2, {
            key: prevLocation.key
          }))) {
            method(location2);
          }
        },
        to: to2
      });
    });
  }
  function compilePath$1(path, options) {
    var cacheKey = "" + options.end + options.strict + options.sensitive;
    var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
    if (pathCache[path])
      return pathCache[path];
    var keys = [];
    var regexp = (0, import_path_to_regexp.default)(path, keys, options);
    var result = {
      regexp,
      keys
    };
    if (cacheCount$1 < cacheLimit$1) {
      pathCache[path] = result;
      cacheCount$1++;
    }
    return result;
  }
  function matchPath(pathname, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "string" || Array.isArray(options)) {
      options = {
        path: options
      };
    }
    var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
    var paths = [].concat(path);
    return paths.reduce(function(matched, path2) {
      if (!path2 && path2 !== "")
        return null;
      if (matched)
        return matched;
      var _compilePath = compilePath$1(path2, {
        end: exact,
        strict,
        sensitive
      }), regexp = _compilePath.regexp, keys = _compilePath.keys;
      var match = regexp.exec(pathname);
      if (!match)
        return null;
      var url2 = match[0], values = match.slice(1);
      var isExact = pathname === url2;
      if (exact && !isExact)
        return null;
      return {
        path: path2,
        url: path2 === "/" && url2 === "" ? "/" : url2,
        isExact,
        params: keys.reduce(function(memo6, key, index2) {
          memo6[key.name] = values[index2];
          return memo6;
        }, {})
      };
    }, null);
  }
  function isEmptyChildren(children) {
    return import_react22.default.Children.count(children) === 0;
  }
  function evalChildrenDev(children, props, path) {
    var value2 = children(props);
    true ? tiny_warning_esm_default(value2 !== void 0, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? ' path="' + path + '"' : "") + ">, but you ") + "should have returned a React element or `null`") : void 0;
    return value2 || null;
  }
  function addLeadingSlash2(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
  }
  function addBasename(basename, location2) {
    if (!basename)
      return location2;
    return _extends({}, location2, {
      pathname: addLeadingSlash2(basename) + location2.pathname
    });
  }
  function stripBasename2(basename, location2) {
    if (!basename)
      return location2;
    var base = addLeadingSlash2(basename);
    if (location2.pathname.indexOf(base) !== 0)
      return location2;
    return _extends({}, location2, {
      pathname: location2.pathname.substr(base.length)
    });
  }
  function createURL(location2) {
    return typeof location2 === "string" ? location2 : createPath(location2);
  }
  function staticHandler(methodName) {
    return function() {
      true ? invariant2(false, "You cannot %s with <StaticRouter>", methodName) : invariant2(false);
    };
  }
  function noop2() {
  }
  var import_react22, import_prop_types2, import_path_to_regexp, import_react_is, import_hoist_non_react_statics, createNamedContext, historyContext, context, Router, MemoryRouter, Lifecycle, messageType, cache2, cacheLimit, cacheCount, cache$1, cacheLimit$1, cacheCount$1, Route, StaticRouter, Switch, useContext2, global2, key, buildNames, initialBuildName, secondaryBuildName;
  var init_react_router = __esm({
    "node_modules/react-router/esm/react-router.js"() {
      init_inheritsLoose();
      import_react22 = __toESM(require_react());
      import_prop_types2 = __toESM(require_prop_types());
      init_history();
      init_tiny_warning_esm();
      init_esm5();
      init_tiny_invariant_esm();
      init_extends();
      import_path_to_regexp = __toESM(require_path_to_regexp());
      import_react_is = __toESM(require_react_is());
      init_objectWithoutPropertiesLoose();
      import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
      createNamedContext = function createNamedContext2(name) {
        var context2 = esm_default();
        context2.displayName = name;
        return context2;
      };
      historyContext = /* @__PURE__ */ createNamedContext("Router-History");
      context = /* @__PURE__ */ createNamedContext("Router");
      Router = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(Router2, _React$Component);
        Router2.computeRootMatch = function computeRootMatch(pathname) {
          return {
            path: "/",
            url: "/",
            params: {},
            isExact: pathname === "/"
          };
        };
        function Router2(props) {
          var _this;
          _this = _React$Component.call(this, props) || this;
          _this.state = {
            location: props.history.location
          };
          _this._isMounted = false;
          _this._pendingLocation = null;
          if (!props.staticContext) {
            _this.unlisten = props.history.listen(function(location2) {
              _this._pendingLocation = location2;
            });
          }
          return _this;
        }
        var _proto = Router2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          var _this2 = this;
          this._isMounted = true;
          if (this.unlisten) {
            this.unlisten();
          }
          if (!this.props.staticContext) {
            this.unlisten = this.props.history.listen(function(location2) {
              if (_this2._isMounted) {
                _this2.setState({
                  location: location2
                });
              }
            });
          }
          if (this._pendingLocation) {
            this.setState({
              location: this._pendingLocation
            });
          }
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          if (this.unlisten) {
            this.unlisten();
            this._isMounted = false;
            this._pendingLocation = null;
          }
        };
        _proto.render = function render() {
          return /* @__PURE__ */ import_react22.default.createElement(context.Provider, {
            value: {
              history: this.props.history,
              location: this.state.location,
              match: Router2.computeRootMatch(this.state.location.pathname),
              staticContext: this.props.staticContext
            }
          }, /* @__PURE__ */ import_react22.default.createElement(historyContext.Provider, {
            children: this.props.children || null,
            value: this.props.history
          }));
        };
        return Router2;
      }(import_react22.default.Component);
      if (true) {
        Router.propTypes = {
          children: import_prop_types2.default.node,
          history: import_prop_types2.default.object.isRequired,
          staticContext: import_prop_types2.default.object
        };
        Router.prototype.componentDidUpdate = function(prevProps) {
          true ? tiny_warning_esm_default(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
        };
      }
      MemoryRouter = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(MemoryRouter2, _React$Component);
        function MemoryRouter2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
          _this.history = createMemoryHistory(_this.props);
          return _this;
        }
        var _proto = MemoryRouter2.prototype;
        _proto.render = function render() {
          return /* @__PURE__ */ import_react22.default.createElement(Router, {
            history: this.history,
            children: this.props.children
          });
        };
        return MemoryRouter2;
      }(import_react22.default.Component);
      if (true) {
        MemoryRouter.propTypes = {
          initialEntries: import_prop_types2.default.array,
          initialIndex: import_prop_types2.default.number,
          getUserConfirmation: import_prop_types2.default.func,
          keyLength: import_prop_types2.default.number,
          children: import_prop_types2.default.node
        };
        MemoryRouter.prototype.componentDidMount = function() {
          true ? tiny_warning_esm_default(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
        };
      }
      Lifecycle = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(Lifecycle2, _React$Component);
        function Lifecycle2() {
          return _React$Component.apply(this, arguments) || this;
        }
        var _proto = Lifecycle2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          if (this.props.onMount)
            this.props.onMount.call(this, this);
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
          if (this.props.onUpdate)
            this.props.onUpdate.call(this, this, prevProps);
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          if (this.props.onUnmount)
            this.props.onUnmount.call(this, this);
        };
        _proto.render = function render() {
          return null;
        };
        return Lifecycle2;
      }(import_react22.default.Component);
      if (true) {
        messageType = import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.string]);
        Prompt.propTypes = {
          when: import_prop_types2.default.bool,
          message: messageType.isRequired
        };
      }
      cache2 = {};
      cacheLimit = 1e4;
      cacheCount = 0;
      if (true) {
        Redirect.propTypes = {
          push: import_prop_types2.default.bool,
          from: import_prop_types2.default.string,
          to: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object]).isRequired
        };
      }
      cache$1 = {};
      cacheLimit$1 = 1e4;
      cacheCount$1 = 0;
      Route = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(Route2, _React$Component);
        function Route2() {
          return _React$Component.apply(this, arguments) || this;
        }
        var _proto = Route2.prototype;
        _proto.render = function render() {
          var _this = this;
          return /* @__PURE__ */ import_react22.default.createElement(context.Consumer, null, function(context$1) {
            !context$1 ? true ? invariant2(false, "You should not use <Route> outside a <Router>") : invariant2(false) : void 0;
            var location2 = _this.props.location || context$1.location;
            var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
            var props = _extends({}, context$1, {
              location: location2,
              match
            });
            var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
            if (Array.isArray(children) && isEmptyChildren(children)) {
              children = null;
            }
            return /* @__PURE__ */ import_react22.default.createElement(context.Provider, {
              value: props
            }, props.match ? children ? typeof children === "function" ? true ? evalChildrenDev(children, props, _this.props.path) : children(props) : children : component ? /* @__PURE__ */ import_react22.default.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? true ? evalChildrenDev(children, props, _this.props.path) : children(props) : null);
          });
        };
        return Route2;
      }(import_react22.default.Component);
      if (true) {
        Route.propTypes = {
          children: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.node]),
          component: function component(props, propName) {
            if (props[propName] && !(0, import_react_is.isValidElementType)(props[propName])) {
              return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
            }
          },
          exact: import_prop_types2.default.bool,
          location: import_prop_types2.default.object,
          path: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]),
          render: import_prop_types2.default.func,
          sensitive: import_prop_types2.default.bool,
          strict: import_prop_types2.default.bool
        };
        Route.prototype.componentDidMount = function() {
          true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
          true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
          true ? tiny_warning_esm_default(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
        };
        Route.prototype.componentDidUpdate = function(prevProps) {
          true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
          true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
        };
      }
      StaticRouter = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(StaticRouter2, _React$Component);
        function StaticRouter2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
          _this.handlePush = function(location2) {
            return _this.navigateTo(location2, "PUSH");
          };
          _this.handleReplace = function(location2) {
            return _this.navigateTo(location2, "REPLACE");
          };
          _this.handleListen = function() {
            return noop2;
          };
          _this.handleBlock = function() {
            return noop2;
          };
          return _this;
        }
        var _proto = StaticRouter2.prototype;
        _proto.navigateTo = function navigateTo(location2, action) {
          var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
          context2.action = action;
          context2.location = addBasename(basename, createLocation(location2));
          context2.url = createURL(context2.location);
        };
        _proto.render = function render() {
          var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose2(_this$props2, ["basename", "context", "location"]);
          var history = {
            createHref: function createHref(path) {
              return addLeadingSlash2(basename + createURL(path));
            },
            action: "POP",
            location: stripBasename2(basename, createLocation(location2)),
            push: this.handlePush,
            replace: this.handleReplace,
            go: staticHandler("go"),
            goBack: staticHandler("goBack"),
            goForward: staticHandler("goForward"),
            listen: this.handleListen,
            block: this.handleBlock
          };
          return /* @__PURE__ */ import_react22.default.createElement(Router, _extends({}, rest, {
            history,
            staticContext: context2
          }));
        };
        return StaticRouter2;
      }(import_react22.default.Component);
      if (true) {
        StaticRouter.propTypes = {
          basename: import_prop_types2.default.string,
          context: import_prop_types2.default.object,
          location: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object])
        };
        StaticRouter.prototype.componentDidMount = function() {
          true ? tiny_warning_esm_default(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
        };
      }
      Switch = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(Switch2, _React$Component);
        function Switch2() {
          return _React$Component.apply(this, arguments) || this;
        }
        var _proto = Switch2.prototype;
        _proto.render = function render() {
          var _this = this;
          return /* @__PURE__ */ import_react22.default.createElement(context.Consumer, null, function(context2) {
            !context2 ? true ? invariant2(false, "You should not use <Switch> outside a <Router>") : invariant2(false) : void 0;
            var location2 = _this.props.location || context2.location;
            var element, match;
            import_react22.default.Children.forEach(_this.props.children, function(child) {
              if (match == null && /* @__PURE__ */ import_react22.default.isValidElement(child)) {
                element = child;
                var path = child.props.path || child.props.from;
                match = path ? matchPath(location2.pathname, _extends({}, child.props, {
                  path
                })) : context2.match;
              }
            });
            return match ? /* @__PURE__ */ import_react22.default.cloneElement(element, {
              location: location2,
              computedMatch: match
            }) : null;
          });
        };
        return Switch2;
      }(import_react22.default.Component);
      if (true) {
        Switch.propTypes = {
          children: import_prop_types2.default.node,
          location: import_prop_types2.default.object
        };
        Switch.prototype.componentDidUpdate = function(prevProps) {
          true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
          true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
        };
      }
      useContext2 = import_react22.default.useContext;
      if (true) {
        if (typeof window !== "undefined") {
          global2 = window;
          key = "__react_router_build__";
          buildNames = {
            cjs: "CommonJS",
            esm: "ES modules",
            umd: "UMD"
          };
          if (global2[key] && global2[key] !== "esm") {
            initialBuildName = buildNames[global2[key]];
            secondaryBuildName = buildNames["esm"];
            throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
          }
          global2[key] = "esm";
        }
      }
    }
  });

  // node_modules/react-router-dom/esm/react-router-dom.js
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function joinClassnames() {
    for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
      classnames[_key] = arguments[_key];
    }
    return classnames.filter(function(i2) {
      return i2;
    }).join(" ");
  }
  var import_react23, import_prop_types3, BrowserRouter, HashRouter, resolveToLocation, normalizeToLocation, forwardRefShim, forwardRef2, LinkAnchor, Link, toType, refType, forwardRefShim$1, forwardRef$1, NavLink, ariaCurrentType;
  var init_react_router_dom = __esm({
    "node_modules/react-router-dom/esm/react-router-dom.js"() {
      init_react_router();
      init_react_router();
      init_inheritsLoose();
      import_react23 = __toESM(require_react());
      init_history();
      import_prop_types3 = __toESM(require_prop_types());
      init_tiny_warning_esm();
      init_extends();
      init_objectWithoutPropertiesLoose();
      init_tiny_invariant_esm();
      BrowserRouter = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(BrowserRouter2, _React$Component);
        function BrowserRouter2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
          _this.history = createBrowserHistory(_this.props);
          return _this;
        }
        var _proto = BrowserRouter2.prototype;
        _proto.render = function render() {
          return /* @__PURE__ */ import_react23.default.createElement(Router, {
            history: this.history,
            children: this.props.children
          });
        };
        return BrowserRouter2;
      }(import_react23.default.Component);
      if (true) {
        BrowserRouter.propTypes = {
          basename: import_prop_types3.default.string,
          children: import_prop_types3.default.node,
          forceRefresh: import_prop_types3.default.bool,
          getUserConfirmation: import_prop_types3.default.func,
          keyLength: import_prop_types3.default.number
        };
        BrowserRouter.prototype.componentDidMount = function() {
          true ? tiny_warning_esm_default(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
        };
      }
      HashRouter = /* @__PURE__ */ function(_React$Component) {
        _inheritsLoose(HashRouter2, _React$Component);
        function HashRouter2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
          _this.history = createHashHistory(_this.props);
          return _this;
        }
        var _proto = HashRouter2.prototype;
        _proto.render = function render() {
          return /* @__PURE__ */ import_react23.default.createElement(Router, {
            history: this.history,
            children: this.props.children
          });
        };
        return HashRouter2;
      }(import_react23.default.Component);
      if (true) {
        HashRouter.propTypes = {
          basename: import_prop_types3.default.string,
          children: import_prop_types3.default.node,
          getUserConfirmation: import_prop_types3.default.func,
          hashType: import_prop_types3.default.oneOf(["hashbang", "noslash", "slash"])
        };
        HashRouter.prototype.componentDidMount = function() {
          true ? tiny_warning_esm_default(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
        };
      }
      resolveToLocation = function resolveToLocation2(to2, currentLocation) {
        return typeof to2 === "function" ? to2(currentLocation) : to2;
      };
      normalizeToLocation = function normalizeToLocation2(to2, currentLocation) {
        return typeof to2 === "string" ? createLocation(to2, null, null, currentLocation) : to2;
      };
      forwardRefShim = function forwardRefShim2(C) {
        return C;
      };
      forwardRef2 = import_react23.default.forwardRef;
      if (typeof forwardRef2 === "undefined") {
        forwardRef2 = forwardRefShim;
      }
      LinkAnchor = forwardRef2(function(_ref, forwardedRef) {
        var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose2(_ref, ["innerRef", "navigate", "onClick"]);
        var target = rest.target;
        var props = _extends({}, rest, {
          onClick: function onClick(event) {
            try {
              if (_onClick)
                _onClick(event);
            } catch (ex) {
              event.preventDefault();
              throw ex;
            }
            if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
              event.preventDefault();
              navigate();
            }
          }
        });
        if (forwardRefShim !== forwardRef2) {
          props.ref = forwardedRef || innerRef;
        } else {
          props.ref = innerRef;
        }
        return /* @__PURE__ */ import_react23.default.createElement("a", props);
      });
      if (true) {
        LinkAnchor.displayName = "LinkAnchor";
      }
      Link = forwardRef2(function(_ref2, forwardedRef) {
        var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to2 = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose2(_ref2, ["component", "replace", "to", "innerRef"]);
        return /* @__PURE__ */ import_react23.default.createElement(context.Consumer, null, function(context2) {
          !context2 ? true ? invariant2(false, "You should not use <Link> outside a <Router>") : invariant2(false) : void 0;
          var history = context2.history;
          var location2 = normalizeToLocation(resolveToLocation(to2, context2.location), context2.location);
          var href = location2 ? history.createHref(location2) : "";
          var props = _extends({}, rest, {
            href,
            navigate: function navigate() {
              var location3 = resolveToLocation(to2, context2.location);
              var isDuplicateNavigation = createPath(context2.location) === createPath(normalizeToLocation(location3));
              var method = replace || isDuplicateNavigation ? history.replace : history.push;
              method(location3);
            }
          });
          if (forwardRefShim !== forwardRef2) {
            props.ref = forwardedRef || innerRef;
          } else {
            props.innerRef = innerRef;
          }
          return /* @__PURE__ */ import_react23.default.createElement(component, props);
        });
      });
      if (true) {
        toType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.object, import_prop_types3.default.func]);
        refType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func, import_prop_types3.default.shape({
          current: import_prop_types3.default.any
        })]);
        Link.displayName = "Link";
        Link.propTypes = {
          innerRef: refType,
          onClick: import_prop_types3.default.func,
          replace: import_prop_types3.default.bool,
          target: import_prop_types3.default.string,
          to: toType.isRequired
        };
      }
      forwardRefShim$1 = function forwardRefShim3(C) {
        return C;
      };
      forwardRef$1 = import_react23.default.forwardRef;
      if (typeof forwardRef$1 === "undefined") {
        forwardRef$1 = forwardRefShim$1;
      }
      NavLink = forwardRef$1(function(_ref, forwardedRef) {
        var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to2 = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose2(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
        return /* @__PURE__ */ import_react23.default.createElement(context.Consumer, null, function(context2) {
          !context2 ? true ? invariant2(false, "You should not use <NavLink> outside a <Router>") : invariant2(false) : void 0;
          var currentLocation = locationProp || context2.location;
          var toLocation = normalizeToLocation(resolveToLocation(to2, currentLocation), currentLocation);
          var path = toLocation.pathname;
          var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
          var match = escapedPath ? matchPath(currentLocation.pathname, {
            path: escapedPath,
            exact,
            sensitive,
            strict
          }) : null;
          var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
          var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
          var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;
          if (isActive) {
            className = joinClassnames(className, activeClassName);
            style = _extends({}, style, activeStyle);
          }
          var props = _extends({
            "aria-current": isActive && ariaCurrent || null,
            className,
            style,
            to: toLocation
          }, rest);
          if (forwardRefShim$1 !== forwardRef$1) {
            props.ref = forwardedRef || innerRef;
          } else {
            props.innerRef = innerRef;
          }
          return /* @__PURE__ */ import_react23.default.createElement(Link, props);
        });
      });
      if (true) {
        NavLink.displayName = "NavLink";
        ariaCurrentType = import_prop_types3.default.oneOf(["page", "step", "location", "date", "time", "true", "false"]);
        NavLink.propTypes = _extends({}, Link.propTypes, {
          "aria-current": ariaCurrentType,
          activeClassName: import_prop_types3.default.string,
          activeStyle: import_prop_types3.default.object,
          className: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func]),
          exact: import_prop_types3.default.bool,
          isActive: import_prop_types3.default.func,
          location: import_prop_types3.default.object,
          sensitive: import_prop_types3.default.bool,
          strict: import_prop_types3.default.bool,
          style: import_prop_types3.default.oneOfType([import_prop_types3.default.object, import_prop_types3.default.func])
        });
      }
    }
  });

  // assets/src/admin/js/App.js
  var AdminPages, AutocompleteTemplates, ConfigProvider, App, App_default;
  var init_App = __esm({
    "assets/src/admin/js/App.js"() {
      init_MainContentSidebar();
      init_ContextMenu();
      init_LimitUsage();
      init_react_router_dom();
      ({ AdminPages, AutocompleteTemplates } = window.getGenie.Components);
      ({ ConfigProvider } = window.antd);
      App = () => {
        const sidebar4 = wp.data.select("getgenie").sidebar();
        return /* @__PURE__ */ React.createElement(ConfigProvider, {
          getPopupContainer: (node) => sidebar4.rootContainer || document.body,
          theme: {
            "components": {
              "Typography": {
                "fontWeightStrong": 500
              },
              "Slider": {
                "handleSize": 14,
                "controlSize": 14,
                "handleSizeHover": 16,
                "handleColor": "#4F6FEC",
                "trackBg": "#4F6FEC",
                "trackHoverBg": "#4F6FEC",
                "handleLineWidth": 2,
                "borderRadiusXS": 4,
                "handleLineWidthHover": 3,
                "margin": 0
              },
              "Tabs": {
                "cardHeight": 44,
                "padding": 16,
                "titleFontSize": 13,
                "inkBarColor": "#4f6fec",
                "colorTextHeading": "rgba(0, 0, 0, 0.88)",
                "colorText": "#031233",
                "colorTextDisabled": "#031233",
                "colorPrimaryHover": "#031233",
                "margin": 0
              }
            },
            "token": {
              "colorPrimary": "#4570f4",
              "borderRadius": 4
            }
          }
        }, " ", AutocompleteTemplates && /* @__PURE__ */ React.createElement(AutocompleteTemplates, null), /* @__PURE__ */ React.createElement(MainContentSidebar_default, null), /* @__PURE__ */ React.createElement(ContextMenu_default, null), /* @__PURE__ */ React.createElement(LimitUsage_default, null), AdminPages ? /* @__PURE__ */ React.createElement(HashRouter, {
          hashType: "noslash"
        }, /* @__PURE__ */ React.createElement(Switch, null, /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/getting-started",
          component: AdminPages.GettingStarted
        }), /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/write-for-me",
          component: AdminPages.WriteForMeAdminPage
        }), /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/keyword-research",
          component: AdminPages.KeywordResearchAdminPage
        }), /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/license",
          component: AdminPages.LicenseAdminPage
        }), /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/settings",
          component: AdminPages.SettingsAdminPage
        }), /* @__PURE__ */ React.createElement(Route, {
          exact: true,
          path: "/help",
          component: AdminPages.HelpAdminPage
        }))) : "");
      };
      App_default = App;
    }
  });

  // assets/src/admin/js/main-app-integration.js
  var main_app_integration_exports = {};
  var addAction, RenderElement3;
  var init_main_app_integration = __esm({
    "assets/src/admin/js/main-app-integration.js"() {
      init_App();
      ({ addAction } = wp.hooks);
      ({ RenderElement: RenderElement3 } = window.getGenie.Components.Common);
      addAction("getgenie-render-app", "getgenie_hooks", async () => {
        let appRoot = document.getElementById("getgenie-container");
        function onloadPromise(obj) {
          return new Promise((resolve2, reject) => {
            obj.onload = () => {
              resolve2(obj);
            };
            obj.onerror = reject;
          });
        }
        const injectCSS = async (file_path, shadowDom) => {
          let id = file_path;
          if (document.getElementById(id) == null) {
            let link = document.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("href", file_path);
            shadowDom.appendChild(link);
            await onloadPromise(link);
            return;
          }
        };
        if (appRoot) {
          const shadow = appRoot.attachShadow({ mode: "open" });
          let cssURL = `${window.getGenie.config.assetsUrl + `dist/admin/styles/admin.css?ver=${window.getGenie.config?.version}`}`;
          await injectCSS(cssURL, shadow);
          const renderIn = document.createElement("div");
          renderIn.classList.add("getgenie");
          renderIn.classList.add("getgenie-version-" + window.getGenie.config?.version);
          renderIn.classList.add("getgenie-root");
          shadow.appendChild(renderIn);
          wp.data.dispatch("getgenie").setSidebar({
            rootContainer: appRoot.shadowRoot.querySelector(".getgenie-root")
          });
          window.getGenie.shadow = shadow;
          RenderElement3(/* @__PURE__ */ React.createElement(App_default, null), renderIn);
          const handleClickEvent = (e) => {
            if (jQuery(e.target).parents(".getgenie").length || e.target.id === "getgenie-container" || e.target.id === "genie-head") {
            } else {
              wp.data.dispatch("getgenie").setContextMenu({ open: false });
            }
          };
          jQuery("body").click(handleClickEvent);
          jQuery("iframe").each(function() {
            const iframe = this;
            if (iframe.contentDocument) {
              const { body } = iframe.contentDocument;
              jQuery(body)?.click(handleClickEvent);
            }
          });
        } else {
          console.warn("There is no toolbar.");
        }
      });
      if (!window.getGenie?.isPlayground) {
        setInterval(async () => {
          const response = await fetch(window.getGenie.config?.authTokenLeaserApi + "&_wpnonce=" + window.getGenie.config.restNonce).catch((err) => {
          });
          if (!response) {
            return;
          }
          if (response.ok) {
            try {
              const res = await response.text();
              window.getGenie.config.authToken = res;
            } catch (e) {
            }
          }
        }, 180 * 1e3);
      }
    }
  });

  // assets/src/admin/js/wp-integrations.js
  var { addAction: addAction2 } = wp.hooks;
  var { WPEditorTopButtons: WPEditorTopButtons2 } = window.getGenie.Components?.BlogWizardUtils || {};
  var { WooCommerceTopButtons } = window.getGenie.Components?.WooWizardUtils || {};
  var { RenderElement: RenderElement4 } = window.getGenie.Components.Common;
  init_Integrations();
  init_main_app_integration();
  addAction2("getgenie-render-toolbar", "getgenie_hooks", () => {
    if (typeof WPEditorTopButtons2 === "undefined") {
      return;
    }
    let toolbar = document.getElementById("getgenie-editor-custom-toolbar");
    if (toolbar) {
      RenderElement4(/* @__PURE__ */ React.createElement(WPEditorTopButtons2, null), toolbar);
    } else {
      console.warn("No toolbar is found.");
    }
  });
  addAction2("getgenie_woocommerce_menu", "getgenie_hooks", () => {
    if (typeof WooCommerceTopButtons === "undefined") {
      return;
    }
    let toolbar = document.getElementById("getgenie-editor-custom-toolbar");
    if (toolbar) {
      RenderElement4(/* @__PURE__ */ React.createElement(WooCommerceTopButtons, null), toolbar);
    } else {
      console.warn("No toolbar is found.");
    }
  });
  addAction2("getgenie_adminbar_menu", "getgenie_hooks", () => {
    let writeTemplateBtn = document.getElementById("wp-admin-bar-getgenie-template-list");
    writeTemplateBtn.addEventListener("click", function(e) {
      e.preventDefault();
      wp.data.dispatch("getgenie").setSidebar({
        open: true,
        component: "TemplateListScreen"
      });
    });
  });
  addAction2("getgenie_adminbar_chat", "getgenie_hooks", () => {
    let writeTemplateBtn = document.getElementById("wp-admin-bar-getgenie-chat");
    writeTemplateBtn.addEventListener("click", function(e) {
      e.preventDefault();
      wp.data.dispatch("getgenie").setSidebar({
        open: true,
        component: "GenieChat",
        analyzeKeyword: {
          open: false,
          triggered: false
        },
        generatedOutlines: {
          open: false
        }
      });
    });
  });
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-plugin-datalabels v2.1.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
/*!
* chartjs-plugin-annotation v2.1.1
* https://www.chartjs.org/chartjs-plugin-annotation/index
 * (c) 2022 chartjs-plugin-annotation Contributors
 * Released under the MIT License
 */
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
